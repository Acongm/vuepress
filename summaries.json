{
  "_meta": {
    "version": "2.0",
    "generatedAt": "2026-02-05T05:42:12.145Z",
    "totalFiles": 145,
    "successCount": 135,
    "errorCount": 0,
    "enabled": true,
    "model": "glm-4-flash",
    "enhanced": true,
    "features": [
      "summary",
      "keyPoints",
      "keywords",
      "techStack",
      "difficulty",
      "contentType"
    ]
  },
  "summaries": {
    "/JavaScript/call、apply与bind.md": {
      "summary": "技术文档介绍了JavaScript中的三个函数方法：call、apply和bind，它们用于改变函数的执行上下文。call方法允许调用一个对象的方法，apply方法接受一个参数数组，而bind方法创建一个新的函数，该函数的执行上下文被绑定到指定的对象。",
      "keyPoints": [
        "call方法允许在对象上借用另一个对象的方法",
        "apply方法接受一个参数数组，用于调用函数",
        "bind方法创建一个新的函数，其执行上下文被绑定到指定的对象",
        "这三个方法都用于改变函数的执行上下文"
      ],
      "keywords": [
        "JavaScript",
        "call",
        "apply",
        "bind",
        "执行上下文"
      ],
      "techStack": [
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理"
    },
    "/JavaScript/js模拟bind方法.md": {
      "summary": "本文介绍了如何模拟实现 JavaScript 的 bind 方法。bind 方法是 Function.prototype 的一个属性，用于修改函数的 this 指向并合并参数。模拟实现 bind 方法可以考察对 this 指向、原型链、闭包和函数等知识的理解。",
      "keyPoints": [
        "bind 方法是 Function.prototype 的一个属性，用于修改函数的 this 指向。",
        "bind 方法可以合并参数传递给原函数，并返回一个新的函数。",
        "模拟实现 bind 方法可以考察对 JavaScript 高级概念的理解，如 this 指向、原型链、闭包等。",
        "模拟实现 bind 方法时，需要考虑 new 操作符对 this 指向的影响。",
        "模拟实现 bind 方法可以用于面试或学习目的，但实际应用中很少需要自定义实现。"
      ],
      "keywords": [
        "bind",
        "JavaScript",
        "this 指向",
        "原型链",
        "闭包"
      ],
      "techStack": [
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/JavaScript/js模拟new操作.md": {
      "summary": "本文探讨了如何模拟 JavaScript 的 new 操作符，通过分析 new 操作符的工作原理，提供了使用 Object.create() 方法创建新对象并设置原型链的方法，并针对不支持 ES5 的浏览器提供了 polyfill 方案。",
      "keyPoints": [
        "通过 Object.create() 方法可以模拟 new 操作符创建新对象并设置原型链。",
        "new 操作符的工作原理包括创建新对象、设置原型链、绑定 this 以及返回新对象。",
        "对于不支持 ES5 的浏览器，可以通过 polyfill 来实现 new 操作符的功能。"
      ],
      "keywords": [
        "new 操作符",
        "Object.create()",
        "原型链",
        "polyfill",
        "JavaScript"
      ],
      "techStack": [
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/JavaScript/执行上下文-作用域链-闭包.md": {
      "summary": "本文档深入探讨了JavaScript中的执行上下文、作用域链和闭包的概念。它解释了全局、函数和Eval执行上下文，以及如何通过闭包访问外部函数的变量。文档还讨论了如何使用闭包定义私有变量，以及JavaScript的继承和模块化编程。此外，它还介绍了变量提升的概念。",
      "keyPoints": [
        "JavaScript有三种执行上下文类型：全局、函数和Eval。",
        "闭包允许内部函数访问外部函数的作用域。",
        "使用闭包可以定义私有变量。",
        "JavaScript通过prototype属性支持继承。",
        "模块化可以通过立即执行函数实现，以控制属性和方法的访问性。",
        "JavaScript存在变量提升的现象。"
      ],
      "keywords": [
        "执行上下文",
        "作用域链",
        "闭包",
        "JavaScript",
        "模块化"
      ],
      "techStack": [
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理"
    },
    "/JavaScript/经典闭包处理.md": {
      "summary": "本文档探讨了闭包的概念及其在JavaScript中的应用，包括闭包的基本原理、改进方法以及ES6和ES7中相关特性的使用。文档通过代码示例展示了如何通过IIFE、setTimeout、函数传值、let关键字、setTimeout异步、Promise异步、async/await和Generator等手段处理闭包问题。",
      "keyPoints": [
        "闭包的基本概念和作用",
        "使用IIFE改进闭包的变量作用域问题",
        "通过setTimeout和函数传值处理闭包中的变量更新问题",
        "使用let关键字避免闭包中的变量提升问题",
        "ES6中Promise和setTimeout的异步处理方法",
        "ES7中async/await和Generator的使用"
      ],
      "keywords": [
        "闭包",
        "IIFE",
        "setTimeout",
        "ES6",
        "ES7",
        "async/await",
        "Generator"
      ],
      "techStack": [
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/Pattern/BroadcastChannel/BroadcastBridge.md": {
      "summary": "BroadcastBridge.ts 文件描述了一个 TypeScript 编写的广播桥接类，用于在客户端和服务器之间实现实时通信。",
      "keyPoints": [
        "定义了一个 BroadcastBridge 类，用于广播消息",
        "支持客户端和服务器之间的实时通信",
        "可能使用了 WebSocket 或类似技术来实现双向通信",
        "提供了消息发送和接收的接口",
        "可能涉及事件监听和回调机制"
      ],
      "keywords": [
        "BroadcastBridge",
        "real-time communication",
        "WebSocket",
        "TypeScript",
        "event-driven"
      ],
      "techStack": [
        "TypeScript",
        "Node.js",
        "WebSocket"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/Pattern/BroadcastChannel/BroadcastSingleton.md": {
      "summary": "BroadcastSingleton.ts 文件定义了一个单例模式的广播服务，用于在应用程序中实现跨组件的数据通信。",
      "keyPoints": [
        "实现单例模式，确保全局只有一个实例",
        "提供广播机制，允许组件订阅和发布消息",
        "支持消息的异步传递和接收",
        "适用于需要跨组件通信的场景，如状态管理"
      ],
      "keywords": [
        "单例模式",
        "广播",
        "消息传递",
        "组件通信",
        "状态管理"
      ],
      "techStack": [
        "TypeScript"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/Pattern/COMPARISON.md": {
      "summary": "本文对比了观察者模式和代理模式在实现状态容器时的不同，通过两个实现方式（手动发布和写入即发布）的代码示例，分析了它们的优缺点、适用场景以及与 Vue3 的相似之处。",
      "keyPoints": [
        "观察者模式和代理模式在实现状态容器时提供了不同的发布订阅机制。",
        "手动发布（Observer）适合事件广播和消息总线，而写入即发布（ProxyStore）适合状态管理和细粒度响应式。",
        "两种模式在触发时机、订阅粒度、回调签名、是否有 prevValue 以及典型场景上存在差异。",
        "ProxyStore 利用 Proxy 拦截实现赋值即发布，与 Vue3 的响应式系统有相似之处。"
      ],
      "keywords": [
        "观察者模式",
        "代理模式",
        "状态容器",
        "响应式",
        "Vue3"
      ],
      "techStack": [
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 对比"
    },
    "/Pattern/CustomEvent/CustomEventBridge.md": {
      "summary": "CustomEventBridge.ts 是一个 TypeScript 编写的库，用于在客户端和服务器端之间桥接自定义事件，实现异步通信。它允许开发者定义和触发自定义事件，并在不同的环境（如浏览器和Node.js）中监听和处理这些事件。",
      "keyPoints": [
        "支持在客户端和服务器端之间传递自定义事件",
        "使用 TypeScript 编写，提供类型安全",
        "支持异步事件监听和处理",
        "兼容不同环境，如浏览器和Node.js",
        "易于集成和使用"
      ],
      "keywords": [
        "CustomEventBridge",
        "TypeScript",
        "event bridge",
        "cross-environment",
        "asynchronous communication"
      ],
      "techStack": [
        "TypeScript",
        "JavaScript",
        "Node.js",
        "Browser"
      ],
      "difficulty": "进阶",
      "contentType": "工具"
    },
    "/Pattern/CustomEvent/CustomEventSingleton.md": {
      "summary": "CustomEventSingleton.ts 文件定义了一个 TypeScript 类，该类用于创建和管理单例模式的自定义事件。它允许全局访问和触发特定的事件，常用于模块间通信。",
      "keyPoints": [
        "单例模式实现，确保全局只有一个实例",
        "提供事件注册和触发功能",
        "支持跨模块事件通信",
        "使用 TypeScript 编写，提供类型安全"
      ],
      "keywords": [
        "单例模式",
        "自定义事件",
        "模块通信",
        "TypeScript",
        "事件管理"
      ],
      "techStack": [
        "TypeScript",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/Pattern/EventBus/EventBus.md": {
      "summary": "内容太短，暂无摘要",
      "keyPoints": [],
      "keywords": [],
      "techStack": [],
      "difficulty": "未分级",
      "contentType": "综合"
    },
    "/Pattern/EventBus/EventBusSingleton.md": {
      "summary": "EventBusSingleton.ts 文档描述了一个单例模式的 EventBus 实现文件，该文件定义了一个全局的事件总线，用于在应用程序的不同组件之间传递消息。",
      "keyPoints": [
        "单例模式实现的事件总线",
        "全局事件传递机制",
        "组件间通信的解决方案",
        "支持事件订阅和发布",
        "确保全局只有一个事件总线实例"
      ],
      "keywords": [
        "单例模式",
        "事件总线",
        "组件通信",
        "全局状态管理",
        "消息传递"
      ],
      "techStack": [
        "TypeScript"
      ],
      "difficulty": "进阶",
      "contentType": "工具"
    },
    "/Pattern/Observer/ObserverSingleton.md": {
      "summary": "ObserverSingleton.ts 文件描述了一个观察者模式的单例实现，用于确保全局只有一个观察者实例，并提供注册和通知机制。",
      "keyPoints": [
        "实现观察者模式，确保全局只有一个观察者实例",
        "提供注册观察者对象的方法",
        "提供通知所有观察者的方法",
        "单例模式确保全局访问点的一致性",
        "适用于需要集中管理事件监听和通知的场景"
      ],
      "keywords": [
        "观察者模式",
        "单例",
        "事件通知",
        "全局访问",
        "注册"
      ],
      "techStack": [
        "TypeScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/Pattern/Observer/Subject.md": {
      "summary": "内容太短，暂无摘要",
      "keyPoints": [],
      "keywords": [],
      "techStack": [],
      "difficulty": "未分级",
      "contentType": "综合"
    },
    "/Pattern/ProxyStore/ProxyStore.md": {
      "summary": "内容太短，暂无摘要",
      "keyPoints": [],
      "keywords": [],
      "techStack": [],
      "difficulty": "未分级",
      "contentType": "综合"
    },
    "/Pattern/ProxyStore/ProxyStoreSingleton.md": {
      "summary": "ProxyStoreSingleton.ts 文件定义了一个单例模式的 ProxyStore 类，该类用于封装数据存储逻辑，提供统一的接口来访问和修改数据，常用于需要集中管理数据流的应用场景。",
      "keyPoints": [
        "单例模式实现：确保全局只有一个 ProxyStore 实例。",
        "数据封装：提供数据访问和修改的接口，隐藏数据存储的具体实现。",
        "数据存储：支持数据的持久化和缓存，优化数据访问效率。",
        "接口统一：提供统一的接口来访问和修改数据，简化应用逻辑。",
        "应用场景：适用于需要集中管理数据流的应用，如状态管理、缓存管理等。"
      ],
      "keywords": [
        "单例模式",
        "数据封装",
        "数据存储",
        "接口统一",
        "状态管理"
      ],
      "techStack": [
        "TypeScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/Pattern/ServiceRequest/Registry.md": {
      "summary": "内容太短，暂无摘要",
      "keyPoints": [],
      "keywords": [],
      "techStack": [],
      "difficulty": "未分级",
      "contentType": "综合"
    },
    "/Pattern/ServiceRequest/ServiceRequestRegistry.md": {
      "summary": "由于您没有提供具体的 `ServiceRequestRegistry.ts` 技术文档的内容，我无法直接分析并提炼关键信息。不过，我可以为您提供一个假设性的分析，假设文档内容如下：\n\n```typescript\n// ServiceRequestRegistry.ts\nclass ServiceRequestRegistry {\n  private static instance: ServiceRequestRegistry;\n  private services: Map<string, Function>;\n\n  private constructor() {\n    this.services = new Map();\n  }\n\n  public static getInstance(): ServiceRequestRegistry {\n    if (!ServiceRequestRegistry.instance) {\n      ServiceRequestRegistry.instance = new ServiceRequestRegistry();\n    }\n    return ServiceRequestRegistry.instance;\n  }\n\n  public registerService(serviceName: string, serviceFunction: Function): void {\n    if (!this.services.has(serviceName)) {\n      this.services.set(serviceName, serviceFunction);\n    }\n  }\n\n  public getService(serviceName: string): Function | undefined {\n    return this.services.get(serviceName);\n  }\n\n  public unregisterService(serviceName: string): void {\n    this.services.delete(serviceName);\n  }\n}\n```\n\n基于这个假设性的文档内容，以下是对应的 JSON 格式分析：\n\n```json\n{\n  \"summary\": \"ServiceRequestRegistry.ts 是一个 TypeScript 类，用于注册、获取和注销服务请求。它采用单例模式，确保全局只有一个实例，并提供方法来管理服务。\",\n  \"keyPoints\": [\n    \"采用单例模式确保全局唯一实例\",\n    \"提供注册、获取和注销服务的方法\",\n    \"使用 Map 对象存储服务名称和函数的映射关系\"\n  ],\n  \"keywords\": [\"单例模式\", \"服务注册\", \"TypeScript\", \"Map\", \"服务管理\"],\n  \"techStack\": [\"TypeScript\"],\n  \"difficulty\": \"进阶\",\n  \"contentType\": \"原理 + 实践\"\n}\n```\n\n请注意，这个分析是基于假设的文档内容，实际的文档内容可能会影响提炼出的关键信息。",
      "keyPoints": [],
      "keywords": [],
      "techStack": [],
      "difficulty": "未分级",
      "contentType": "综合"
    },
    "/Pattern/ServiceRequest/SharedStateBridge.md": {
      "summary": "SharedStateBridge.ts 文件定义了一个 TypeScript 类，用于实现跨组件或跨库共享状态的管理和通信。该类通过提供订阅和发布状态变化的方法，使得组件能够响应状态的变化，而无需直接引用状态源。",
      "keyPoints": [
        "实现跨组件或跨库的状态共享",
        "提供订阅和发布状态变化的方法",
        "无需直接引用状态源即可响应状态变化",
        "可能支持异步状态更新",
        "适用于大型应用或复杂组件结构"
      ],
      "keywords": [
        "状态管理",
        "共享状态",
        "事件订阅",
        "TypeScript",
        "组件通信"
      ],
      "techStack": [
        "TypeScript",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "工具"
    },
    "/Pattern/ServiceRequest/SharedStateBridgeSingleton.md": {
      "summary": "SharedStateBridgeSingleton.ts 文件定义了一个单例模式的共享状态桥接器，用于在应用程序的不同组件之间同步状态。",
      "keyPoints": [
        "使用单例模式确保全局只有一个共享状态实例。",
        "提供方法来获取和设置共享状态。",
        "支持跨组件状态同步。",
        "可能使用观察者模式来监听状态变化并通知相关组件。",
        "适用于需要集中管理状态的大型应用程序。"
      ],
      "keywords": [
        "单例模式",
        "共享状态",
        "状态桥接器",
        "组件通信",
        "观察者模式"
      ],
      "techStack": [
        "TypeScript",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/Pattern/Store/Store.md": {
      "summary": "内容太短，暂无摘要",
      "keyPoints": [],
      "keywords": [],
      "techStack": [],
      "difficulty": "未分级",
      "contentType": "综合"
    },
    "/Pattern/Store/StoreSingleton.md": {
      "summary": "内容太短，暂无摘要",
      "keyPoints": [],
      "keywords": [],
      "techStack": [],
      "difficulty": "未分级",
      "contentType": "综合"
    },
    "/Pattern/模式来源与类比.md": {
      "summary": "本文档探讨了跨组件通信模式，指出这些模式并非框架专属，而是软件工程中常见的经典形态。文档提供了快速对照表，将常见的API与对应模式进行类比，帮助读者识别和了解这些模式在何处见过。",
      "keyPoints": [
        "跨组件通信模式是软件工程中的经典形态，并非框架专属。",
        "不同框架和库将相同的模式包装成不同的API。",
        "文档提供了快速对照表，帮助识别和了解模式的应用场景。",
        "模式包括事件总线、发布订阅、状态容器等。",
        "通过类比常见API，读者可以更容易地理解这些模式。"
      ],
      "keywords": [
        "跨组件通信",
        "模式",
        "API",
        "事件总线",
        "发布订阅"
      ],
      "techStack": [
        "Node.js",
        "前端",
        "RxJS",
        "Vue2"
      ],
      "difficulty": "进阶",
      "contentType": "概念 + 实践"
    },
    "/TypeScript/Study.md": {
      "summary": "这份技术文档详细介绍了 TypeScript 中的高级类型特性，包括泛型参数、条件类型、类型转换、类型推断等，并通过代码示例展示了如何在实际项目中应用这些特性。",
      "keyPoints": [
        "介绍了 TypeScript 中的高级类型特性，如泛型、条件类型、类型转换等",
        "提供了多个代码示例，展示如何使用这些特性来处理类型",
        "涵盖了 `Parameters`, `ConstructorParameters`, `ReturnType`, `InstanceType` 等实用工具类型",
        "讨论了类型推断和 infer 关键字的使用"
      ],
      "keywords": [
        "TypeScript",
        "泛型",
        "条件类型",
        "类型推断",
        "工具类型"
      ],
      "techStack": [
        "TypeScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/css/scss.md": {
      "summary": "本文档介绍了常用SCSS宏的使用，包括如何显示省略号、实现滚动效果以及垂直居中布局，旨在帮助开发者通过SCSS提高CSS的编写效率。",
      "keyPoints": [
        "介绍如何使用SCSS宏来显示省略号",
        "展示如何通过SCSS实现滚动效果",
        "讲解如何使用SCSS宏实现垂直居中布局"
      ],
      "keywords": [
        "SCSS",
        "宏",
        "省略号",
        "滚动",
        "垂直居中"
      ],
      "techStack": [
        "SCSS",
        "CSS"
      ],
      "difficulty": "入门",
      "contentType": "实践"
    },
    "/css/skill.md": {
      "summary": "本文介绍了CSS中`white-space`属性的使用，该属性控制HTML元素中的空白字符处理方式，包括换行符、空格和制表符的处理，适用于处理文本布局。",
      "keyPoints": [
        "介绍`white-space`属性及其作用",
        "列举了`white-space`的不同属性值及其对换行符、空格和制表符的处理方式",
        "提供了代码示例和MDN链接供进一步学习"
      ],
      "keywords": [
        "CSS",
        "white-space",
        "文本布局",
        "空白处理"
      ],
      "techStack": [
        "CSS"
      ],
      "difficulty": "入门",
      "contentType": "概念 + 实践"
    },
    "/git/command.md": {
      "summary": "本文档提供了一系列Git命令的清单，包括如何新建仓库、配置、添加/删除文件到暂存区、提交代码、管理分支和标签、查看信息、撤销操作以及查看日志等，旨在帮助用户快速查阅和使用Git版本控制工具。",
      "keyPoints": [
        "提供Git命令的详细清单和代码示例",
        "涵盖从新建仓库到撤销操作的各个阶段",
        "适合Git用户快速查阅和参考",
        "包含配置、分支管理、提交和日志查看等关键操作"
      ],
      "keywords": [
        "Git",
        "版本控制",
        "命令清单",
        "代码提交",
        "分支管理"
      ],
      "techStack": [
        "Git"
      ],
      "difficulty": "入门",
      "contentType": "工具"
    },
    "/git/commit.md": {
      "summary": "本文档介绍了Git提交消息的规范格式，包括Header、type、scope和subject等字段，以及不同type的用途和示例，旨在提高代码的可读性和可维护性。",
      "keyPoints": [
        "Header部分包含type、scope和subject字段，type是必需的，其余可选。",
        "type字段有七个标识：feat、fix、docs、style、refactor、test和chore，用于描述commit的类别。",
        "任何一行不得超过72个字符，以保持美观。",
        "遵循规范化的commit message有助于团队协作和代码管理。"
      ],
      "keywords": [
        "Git",
        "commit message",
        "规范",
        "type",
        "Header"
      ],
      "techStack": [
        "Git"
      ],
      "difficulty": "入门",
      "contentType": "概念 + 实践"
    },
    "/interview/2025-04-28-analysis.md": {
      "summary": "这份技术文档主要针对面试中的笔试和面试高频考点进行预测和准备，涵盖了框架原理、工程化实战、性能优化方案设计、算法题以及技术面试中的框架深度追问和工程化实践等内容。",
      "keyPoints": [
        "笔试重点预测包括框架原理题、工程化实战题、性能优化方案设计以及算法题。",
        "性能优化方案设计要求针对万级数据表格进行优化，包括数据加载策略、渲染优化手段和内存管理技巧。",
        "技术面试高频考点涉及框架深度追问，如Vue3响应式原理、Quasar定制能力和微前端沙箱机制。",
        "工程化实践方面，重点准备低代码平台设计，特别是JSON Schema驱动方案。",
        "文档中提供了代码示例，用于说明相关概念和实现细节。"
      ],
      "keywords": [
        "框架原理",
        "性能优化",
        "算法题",
        "Vue3",
        "React"
      ],
      "techStack": [
        "Vue.js",
        "React",
        "JavaScript",
        "JSON Schema",
        "低代码平台"
      ],
      "difficulty": "进阶",
      "contentType": "面试准备 + 框架原理 + 工程化实践"
    },
    "/interview/2025-04-28.md": {
      "summary": "这份技术文档主要针对面试中的笔试和面试高频考点进行预测和准备，涵盖了框架原理、工程化实战、性能优化方案设计、算法题以及技术面试中的框架深度追问、工程化实践、性能优化体系、架构设计能力等多个方面。",
      "keyPoints": [
        "笔试重点预测包括框架原理题、工程化实战题、性能优化方案设计、算法题等。",
        "技术面试高频考点涉及Vue3响应式原理、Quasar定制能力、微前端沙箱机制、低代码平台设计、构建优化指标、CI/CD全流程、LCP优化方案、内存泄漏排查、编译时优化、插件系统设计、状态管理方案、微前端通信等。",
        "性能优化方案设计要求针对万级数据表格提供至少5点优化方案，包括数据加载策略、渲染优化手段、内存管理技巧等。"
      ],
      "keywords": [
        "框架原理",
        "工程化实战",
        "性能优化",
        "算法题",
        "Vue3",
        "Quasar",
        "微前端",
        "低代码平台",
        "CI/CD",
        "LCP",
        "内存泄漏",
        "编译时优化",
        "插件系统",
        "状态管理",
        "微前端通信"
      ],
      "techStack": [
        "Vue3",
        "Quasar",
        "Rollup",
        "Preact",
        "Babel",
        "Chrome Memory",
        "Web Components",
        "Iframe"
      ],
      "difficulty": "进阶",
      "contentType": "面试准备 + 框架原理 + 实践"
    },
    "/interview-prep/BLINDSPOTS.md": {
      "summary": "该技术文档记录了多个技术选型与项目维护过程中的关键问题和解决方案，包括构建工具、表单方案、Monorepo管理、跨平台公告插件系统以及大疆DevOps平台。文档着重于选型原因、潜在风险、事故处理和改进建议。",
      "keyPoints": [
        "构建工具选型：比较Webpack、Vite和Rollup的优劣。",
        "表单方案选型：对比Formily、RJSF和自研无依赖表单。",
        "Monorepo选型：分析Lerna和Nx的适用性。",
        "跨平台公告插件系统：探讨插件系统的加载、卸载、版本冲突处理和故障恢复。",
        "大疆DevOps平台维护：记录平台维护中的问题和解决方案。"
      ],
      "keywords": [
        "构建工具",
        "表单方案",
        "Monorepo",
        "跨平台插件",
        "DevOps"
      ],
      "techStack": [
        "Webpack",
        "Vite",
        "Rollup",
        "Formily",
        "RJSF",
        "Lerna",
        "Nx"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/interview-prep/INDEX.md": {
      "summary": "该文档提供了一个面试准备的入口页面，作为 `/interview-prep/` 路径的索引，并提供了两个子文档的链接：README.md 和 BLINDSPOTS.md，用于指导用户如何开始面试准备和识别盲点。",
      "keyPoints": [
        "提供面试准备的入口页面",
        "链接到 README.md 和 BLINDSPOTS.md 子文档",
        "README.md 用于指导用户如何开始面试准备",
        "BLINDSPOTS.md 用于识别面试准备中的盲点"
      ],
      "keywords": [
        "面试准备",
        "入口页面",
        "README.md",
        "BLINDSPOTS.md",
        "面试指导"
      ],
      "techStack": [
        "无特定的技术栈，主要是文档和链接"
      ],
      "difficulty": "入门",
      "contentType": "概念"
    },
    "/interview-prep/matrix__bundler-webpack-vite-rollup.md": {
      "summary": "技术文档摘要了作者在多个大疆项目中担任的角色，包括用户中心重构、售后RMS系统重构等，涉及性能优化、HTTP原理、Webpack架构等关键技术。文档强调了性能指标与方法论，以及HTTP常考点和Webpack架构的面试常考内容。",
      "keyPoints": [
        "在多个大疆项目中担任关键角色，涉及性能优化和架构设计",
        "关注HTTP原理、Webpack架构等关键技术",
        "强调性能指标与方法论，以及面试常考内容",
        "涉及大存量应用场景下的技术选型",
        "探讨项目中的最大事故/踩坑及回滚策略"
      ],
      "keywords": [
        "性能优化",
        "HTTP原理",
        "Webpack架构",
        "大存量应用",
        "技术选型"
      ],
      "techStack": [
        "Webpack",
        "HTTP",
        "性能优化"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/interview-prep/matrix__cicd-release-strategy.md": {
      "summary": "该技术文档主要关注CI/CD流水线阶段拆解、质量与安全门禁、Docker分层与缓存命中、多种发布策略（蓝绿、金丝雀、滚动发布）以及可追溯和回滚机制。文档旨在解决多团队并行交付、构建/测试慢、安全与合规等问题，强调质量可控、可追溯和可回滚。",
      "keyPoints": [
        "流水线阶段拆解：build → test → scan → package → deploy",
        "产物与版本管理：使用buildMeta记录版本信息，统一管理artifact与镜像",
        "发布策略：蓝绿、金丝雀、滚动发布，结合健康检查和自动回滚",
        "可追溯性：commit→构建→镜像→发布",
        "回滚与降级：基于错误率、性能和关键接口耗时进行决策"
      ],
      "keywords": [
        "CI/CD",
        "流水线",
        "Docker",
        "发布策略",
        "可追溯",
        "回滚"
      ],
      "techStack": [
        "Docker",
        "CI/CD",
        "自动化部署"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/interview-prep/matrix__form-formily-rjsf-custom.md": {
      "summary": "该文档描述了作者在多个大疆项目中担任技术角色，涉及性能优化、HTTP原理、Webpack架构、表单能力平台化等。文档强调了性能指标、方法论、排查与定位问题、架构调整等关键点。",
      "keyPoints": [
        "在多个大疆项目中担任技术角色，包括用户中心重构、售后系统重构等。",
        "关注性能优化、HTTP原理、Webpack架构等关键技术。",
        "提出表单能力平台化的概念，实现schema驱动、可配置、可复用。",
        "强调性能指标、方法论在项目中的应用。",
        "讨论架构调整和边界问题，以应对潜在的技术挑战。"
      ],
      "keywords": [
        "性能优化",
        "HTTP原理",
        "Webpack架构",
        "表单能力平台化",
        "架构调整"
      ],
      "techStack": [
        "React",
        "TypeScript",
        "Webpack"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/interview-prep/matrix__lowcode-ssr-csr-export.md": {
      "summary": "该技术文档关注于Schema驱动渲染链路、编辑器一致性、运行时性能治理、SSR/Hydration、导出一致性与权限隔离、稳定性与降级。文档探讨了低代码平台中的选型问题，包括渲染器选择、渲染模式（SSR/CSR/流式SSR）以及导出方式，并涉及了Schema驱动的低代码原理、SSR/CSR的优缺点以及相关技术。",
      "keyPoints": [
        "Schema驱动低代码架构，通过序列化的UI、数据和事件描述实现渲染。",
        "探讨了SSR、CSR和流式SSR的优缺点，以及它们在首屏加载、SEO、鉴权、稳定性等方面的权衡。",
        "讨论了导出的一致性、权限隔离和失败处理机制。",
        "涉及低代码平台中的物料版本治理和schema迁移问题。",
        "强调了编辑器一致性和运行时性能治理的重要性。"
      ],
      "keywords": [
        "Schema驱动",
        "低代码",
        "SSR",
        "CSR",
        "渲染模式",
        "导出"
      ],
      "techStack": [
        "React",
        "TypeScript",
        "性能优化"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/interview-prep/matrix__monorepo-lerna-nx.md": {
      "summary": "技术文档描述了多个项目重构和维护的经验，包括大疆用户中心重构、售后 RMS 系统重构等，涉及性能优化、HTTP 原理、Webpack 架构等关键技术。文档强调了性能指标、方法论、排查与定位问题、优化方案的实施和验证，并讨论了依赖治理、CI 流程优化和发布策略。",
      "keyPoints": [
        "大疆用户中心重构涉及性能优化和HTTP原理",
        "Webpack架构在工程化面试中常考",
        "性能优化方案包括排查、定位、选择和验证",
        "依赖治理和CI流程优化是关键问题",
        "发布策略包括版本管理、变更记录和回滚"
      ],
      "keywords": [
        "性能优化",
        "HTTP",
        "Webpack",
        "依赖治理",
        "CI流程"
      ],
      "techStack": [
        "Webpack",
        "HTTP",
        "Lerna"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/interview-prep/project__announce-plugin.md": {
      "summary": "该文档描述了一个可热插拔、可灰度、可回滚的前端公告插件系统，重点在于插件的生命周期管理、隔离策略、版本治理和多宿主接入协议。文档涉及性能优化、HTTP原理、Webpack架构等知识，并探讨了项目中的角色与使用场景。",
      "keyPoints": [
        "可热插拔、可灰度、可回滚的前端公告插件系统",
        "生命周期管理、隔离策略、版本治理和多宿主接入协议",
        "性能优化、HTTP原理、Webpack架构的应用",
        "独立开发者角色，负责插件加载生命周期和版本治理",
        "涉及项目重构和维护经验"
      ],
      "keywords": [
        "前端公告插件系统",
        "生命周期管理",
        "隔离策略",
        "版本治理",
        "性能优化"
      ],
      "techStack": [
        "Webpack",
        "HTTP",
        "单页面应用架构"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/interview-prep/project__dji-devops.md": {
      "summary": "该文档描述了一位核心开发者在大疆参与的多项目经验，包括用户中心重构、售后系统重构等，涉及性能优化、HTTP原理、Webpack架构等。文档强调了性能指标与方法论，以及如何通过排查、定位、选择和验证来优化方案。此外，文档还涉及了微前端架构、TypeScript、Monorepo、Lerna、Nx等技术和工具的使用。",
      "keyPoints": [
        "参与大疆多个核心项目，如用户中心重构和售后系统重构",
        "关注性能优化，包括HTTP原理和Webpack架构",
        "采用微前端架构实现独立部署与统一治理",
        "通过CI/CD提升发布效率",
        "熟悉TypeScript、Monorepo、Lerna、Nx等技术"
      ],
      "keywords": [
        "大疆",
        "微前端",
        "性能优化",
        "Webpack",
        "HTTP"
      ],
      "techStack": [
        "微前端",
        "TypeScript",
        "Monorepo",
        "Lerna",
        "Nx"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/interview-prep/project__dji-rms.md": {
      "summary": "技术文档摘要了多个项目经验，包括大疆用户中心重构、售后RMS系统重构等，涉及性能优化、HTTP原理、Webpack架构等关键技术。文档强调了性能指标与方法论，以及HTTP常考点和Webpack架构的面试常考内容。",
      "keyPoints": [
        "大疆用户中心重构，涉及性能优化和HTTP原理",
        "Webpack架构在工程化面试中的常考内容",
        "性能指标与方法论在项目中的应用",
        "HTTP常考点分析",
        "跨平台公告插件系统与DevOps平台维护经验"
      ],
      "keywords": [
        "大疆用户中心重构",
        "性能优化",
        "HTTP原理",
        "Webpack架构",
        "性能指标"
      ],
      "techStack": [
        "React",
        "TypeScript",
        "Webpack",
        "HTTP",
        "DevOps"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/interview-prep/project__dji-user-center.md": {
      "summary": "技术文档摘要了作者在多个大疆项目中的技术贡献，包括用户中心重构、售后系统重构等，涉及性能优化、HTTP原理、Webpack架构等。文档强调了性能指标与方法论，以及如何通过关键渲染路径（CRP）、资源优先级、传输层和包体积来提升性能。",
      "keyPoints": [
        "在多个大疆项目中负责前端重构和性能优化",
        "关注HTTP原理、Webpack架构和性能指标",
        "采用关键渲染路径（CRP）和资源优先级优化性能",
        "降低维护成本并提升登录转化",
        "使用传输层优化和减小包体积"
      ],
      "keywords": [
        "性能优化",
        "HTTP",
        "Webpack",
        "关键渲染路径",
        "资源优先级"
      ],
      "techStack": [
        "Webpack",
        "HTTP",
        "性能优化"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/interview-prep/project__xdr-dashboard-report.md": {
      "summary": "技术文档描述了一个项目，其中核心开发者负责低代码物料与渲染链路、报表导出与定时任务等跨端交付。项目涉及性能优化、HTTP原理、Webpack架构，以及Schema驱动的低代码渲染和大屏高频刷新治理。",
      "keyPoints": [
        "核心开发者角色，负责低代码物料与渲染链路",
        "性能优化，包括HTTP原理和Webpack架构",
        "Schema驱动的低代码渲染",
        "大屏高频刷新治理",
        "报表导出与定时任务"
      ],
      "keywords": [
        "低代码",
        "渲染链路",
        "性能优化",
        "HTTP",
        "Webpack",
        "Schema驱动"
      ],
      "techStack": [
        "React",
        "TypeScript",
        "Webpack",
        "HTTP"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/interview-prep/tech__eslint-engineering.md": {
      "summary": "该技术文档介绍了如何在中后台多人协作项目中使用Prettier、ESLint和TypeScript来提高代码质量和协作效率。文档强调了格式化、语义规则、类型正确性以及模块边界治理的重要性，并提供了一套执行链路和闭环策略来确保代码质量。",
      "keyPoints": [
        "使用Prettier、ESLint和TypeScript分工合作，分别负责格式化、语义规则和类型正确性。",
        "通过IDE、提交、PR/CI等环节确保代码规则得到执行，并快速反馈。",
        "实施模块边界治理，通过技术债清单和分阶段收敛策略来管理技术债务。",
        "通过husky和lint-staged工具在提交时只检查改动文件，提高反馈速度。"
      ],
      "keywords": [
        "Prettier",
        "ESLint",
        "TypeScript",
        "代码质量",
        "模块边界治理"
      ],
      "techStack": [
        "Prettier",
        "ESLint",
        "TypeScript",
        "husky",
        "lint-staged"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/interview-prep/tech__micro-frontend-qiankun.md": {
      "summary": "该文档描述了作者在多个项目中的技术经验，包括大疆用户中心重构、大疆售后 RMS 系统重构等，涉及性能优化、HTTP 原理、Webpack 架构等关键技术。文档还提到了面试大纲关键词，如性能优化、HTTP 原理、Webpack 架构等，并提出了在 DevOps 平台和多业务线中的使用场景。",
      "keyPoints": [
        "作者在多个大疆项目中负责技术重构和优化",
        "涉及性能优化、HTTP 原理、Webpack 架构等技术",
        "在 DevOps 平台和多业务线中实现独立部署和独立回滚",
        "处理隔离与共享的平衡，避免污染和重复依赖",
        "定义子应用接入规范，实现资源加载、通信协议、样式隔离等"
      ],
      "keywords": [
        "性能优化",
        "HTTP 原理",
        "Webpack 架构",
        "DevOps",
        "微前端"
      ],
      "techStack": [
        "Webpack",
        "HTTP",
        "DevOps",
        "微前端"
      ],
      "difficulty": "高级",
      "contentType": "实践"
    },
    "/interview-prep/tech__performance.md": {
      "summary": "该文档主要讨论了网站性能优化的关键指标和策略，包括LCP、FCP、TTI、CLS、INP等指标，以及如何通过Performance、Network、Lighthouse等工具进行性能和资源分析。文档还介绍了关键渲染路径（CRP）、渐进式渲染和资源优先级等优化策略，并针对不同项目（如用户中心和RMS）提供了性能优化的具体方法和落地实践。",
      "keyPoints": [
        "性能指标包括LCP、FCP、TTI、CLS、INP等，用于评估网站性能",
        "使用Performance、Network、Lighthouse等工具进行性能和资源分析",
        "优化策略包括关键渲染路径、渐进式渲染和资源优先级",
        "针对不同项目提供性能优化的具体方法和落地实践",
        "强调建立基线、定位问题和闭环管理的重要性"
      ],
      "keywords": [
        "网站性能优化",
        "性能指标",
        "Web Vitals",
        "性能分析",
        "优化策略"
      ],
      "techStack": [
        "Performance API",
        "Network API",
        "Lighthouse",
        "Webpack"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/interview-prep/tech__react.md": {
      "summary": "技术文档摘要了多个项目，包括大疆用户中心重构、大疆售后 RMS 系统重构等，涉及性能优化、HTTP 原理、Webpack 架构等关键技术。文档强调了性能指标与方法论，以及如何通过优化方案来提升系统性能。",
      "keyPoints": [
        "大疆用户中心重构涉及性能优化和HTTP原理",
        "Webpack架构在工程化面试中常考",
        "性能优化方案包括排查、定位、选择和验证",
        "文档关注渲染性能和可维护性",
        "文档强调高频更新和大量可视化组件的性能治理"
      ],
      "keywords": [
        "性能优化",
        "HTTP原理",
        "Webpack架构",
        "性能指标",
        "可维护性"
      ],
      "techStack": [
        "Webpack",
        "HTTP",
        "性能优化"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/interview-prep/tech__rollup.md": {
      "summary": "技术文档摘要了多个项目经验，包括大疆用户中心重构、售后 RMS 系统重构等，涉及性能优化、HTTP 原理、Webpack 架构等关键技术。文档强调了性能指标与方法论，以及如何通过优化四板斧来提升性能。",
      "keyPoints": [
        "大疆用户中心重构涉及性能优化和 HTTP 原理",
        "Webpack 架构在工程化面试中常考",
        "通过优化四板斧提升性能，包括排查、定位、选择和验证",
        "设计多产物输出以满足不同集成需求",
        "控制 breaking change 以确保兼容性"
      ],
      "keywords": [
        "性能优化",
        "HTTP",
        "Webpack",
        "工程化",
        "多产物输出"
      ],
      "techStack": [
        "Webpack",
        "HTTP",
        "性能优化"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/interview-prep/tech__typescript.md": {
      "summary": "该文档描述了作者在多个大疆项目中担任的角色，包括用户中心重构、售后RMS系统重构、跨平台公告插件系统、DevOps平台维护和XDR系统。文档重点提及了性能优化、HTTP原理、Webpack架构、性能指标与方法论等关键技术，并强调了在多人协作和快速迭代环境下的错误预防和成本降低。",
      "keyPoints": [
        "在多个大疆项目中担任关键角色，涉及性能优化和架构重构",
        "关注HTTP原理、Webpack架构和性能指标",
        "在多人协作和快速迭代环境中实施错误预防和成本降低策略",
        "使用类型表达和跨模块协作技术减少运行时错误"
      ],
      "keywords": [
        "性能优化",
        "HTTP",
        "Webpack",
        "错误预防",
        "DevOps"
      ],
      "techStack": [
        "Webpack",
        "HTTP",
        "TypeScript",
        "DevOps"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/interview-prep/tech__vite.md": {
      "summary": "该文档描述了作者在多个大疆项目中担任技术角色，涉及性能优化、HTTP原理、Webpack架构等。文档强调了性能指标与方法论，以及如何通过优化方案提升项目性能。",
      "keyPoints": [
        "在多个大疆项目中负责性能优化和架构重构",
        "关注HTTP原理和Webpack架构在项目中的应用",
        "采用性能指标与方法论进行项目优化",
        "实施优化方案，包括排查、定位、选择和验证",
        "使用Vite的ESM Dev Server提升开发体验"
      ],
      "keywords": [
        "性能优化",
        "HTTP原理",
        "Webpack架构",
        "Vite",
        "ESM Dev Server"
      ],
      "techStack": [
        "Webpack",
        "Vite",
        "ESM"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/interview-prep/tech__webpack.md": {
      "summary": "该文档描述了作者在多个大疆项目中的技术实践，包括用户中心重构、售后RMS系统重构、跨平台公告插件系统、DevOps平台维护和XDR系统。文档重点讨论了性能优化、HTTP原理、Webpack架构、性能指标与方法论，以及如何通过优化策略提高系统性能。",
      "keyPoints": [
        "在大型项目中实施性能优化策略",
        "深入理解HTTP原理和Webpack架构",
        "通过工程化方法提高系统稳定性和可维护性",
        "优化关键渲染路径以提升用户体验",
        "实施有效的构建和持续集成策略"
      ],
      "keywords": [
        "性能优化",
        "HTTP",
        "Webpack",
        "工程化",
        "DevOps"
      ],
      "techStack": [
        "Webpack",
        "HTTP",
        "CI/CD"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/issue/h5.md": {
      "summary": "该文档讨论了在H5应用中，WebView返回上一页时如何避免页面刷新的问题。由于缓存机制的存在，页面可能会从缓存中加载，导致内容不更新。文档提供了通过监听`pageshow`事件并检查`persisted`或`performance.navigation.type`属性来解决这个问题的方法。",
      "keyPoints": [
        "WebView缓存机制可能导致返回上一页时不刷新",
        "使用`pageshow`事件来判断页面是否从缓存加载",
        "检查`persisted`或`performance.navigation.type`属性来确定页面加载方式"
      ],
      "keywords": [
        "H5",
        "WebView",
        "缓存",
        "pageshow",
        "persisted",
        "performance.navigation.type"
      ],
      "techStack": [
        "HTML5",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/issue/pc.md": {
      "summary": "技术文档讨论了在使用 CSS `transform` 属性时，由于渲染非整数像素值导致的字体模糊问题，并提供了两种解决方案。",
      "keyPoints": [
        "使用 `transform` 属性可能导致字体模糊，因为其渲染非整数像素值。",
        "提供了两种解决方案来解决这个问题。",
        "解决方案涉及 CSS 和可能的代码示例。"
      ],
      "keywords": [
        "CSS",
        "transform",
        "字体模糊",
        "解决方案",
        "代码示例"
      ],
      "techStack": [
        "CSS"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/job-description/ASK.md": {
      "summary": "技术文档描述了一位前端开发者的自我介绍和项目经验，特别是针对用户中心重构项目的详细描述，包括项目背景、遇到的问题、解决方案以及项目价值。",
      "keyPoints": [
        "前端开发者自我介绍，包括工作经历和项目经验",
        "用户中心重构项目，涉及技术栈升级、性能优化和用户体验提升",
        "项目背景分析，包括技术挑战和业务需求",
        "性能优化措施，如打包优化、资源加载优化和图片格式升级",
        "项目成果，如登录转化率提升和客诉率下降"
      ],
      "keywords": [
        "前端开发",
        "用户中心重构",
        "性能优化",
        "打包优化",
        "用户体验"
      ],
      "techStack": [
        "Vue.js",
        "JavaScript",
        "CSS",
        "HTTP/2.0",
        "TLS 1.3"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/job-description/ASK_CODE_EXAMPLES.md": {
      "summary": "本文档深入探讨了Webpack拆包、性能优化、资源优先级、脚本加载、图片格式、ESLint配置以及React错误处理等前端工程化实践。涵盖了Webpack配置、性能监控、资源加载策略、代码质量保证等多个方面，旨在提升前端项目的性能和可维护性。",
      "keyPoints": [
        "Webpack配置：使用`splitChunks`和`runtimeChunk`进行代码拆分，利用`contenthash`实现静态资源缓存，正确配置`sideEffects`。",
        "性能优化：通过RUM（Web-Vitals）上报闭环进行性能监控，关注关键性能指标，实现可定位、可回归、可持续的性能优化。",
        "资源优先级：使用`preconnect`和`preload`优化资源加载，`defer`和`async`合理使用脚本加载策略。",
        "图片格式：采用WebP格式并使用`<picture>`标签兜底，确保图片加载稳定。",
        "代码质量保证：ESLint配置从0-1的落地方式，结合Prettier进行代码格式化，确保代码质量。",
        "React错误处理：未具体说明，但文档中包含React错误处理的代码示例。"
      ],
      "keywords": [
        "Webpack",
        "性能优化",
        "资源加载",
        "代码质量",
        "React错误处理"
      ],
      "techStack": [
        "Webpack",
        "JavaScript",
        "React",
        "ESLint",
        "Prettier"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/job-description/ASK_LIST.md": {
      "summary": "这份技术文档主要介绍了一位前端开发者的自我介绍和项目经验，特别是关于用户中心重构项目。该项目涉及Vue2技术栈的重构，包括性能优化、打包优化、资源处理和UI重构，旨在提升用户体验和维护效率。",
      "keyPoints": [
        "前端开发者自我介绍，包括工作经历和项目经验",
        "用户中心重构项目，涉及性能瓶颈排查和优化",
        "打包优化策略，包括精简依赖、CSS优化和字体压缩",
        "性能优化措施，如升级TLS和HTTP版本，使用WebP图片格式",
        "项目成果，如登录转化率提升和客诉率下降"
      ],
      "keywords": [
        "前端开发",
        "Vue2",
        "性能优化",
        "打包优化",
        "用户中心重构"
      ],
      "techStack": [
        "Vue.js",
        "JavaScript",
        "CSS",
        "HTTP",
        "TLS"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/job-description/ASK_RECORD.md": {
      "summary": "该技术文档描述了一位前端负责人的工作经历，包括在一个老旧的React技术栈项目中进行重构，优化性能和用户体验，以及如何通过技术手段提升开发效率和团队协作能力。项目背景复杂，涉及多端适配、大数据量处理和性能优化等多个挑战。",
      "keyPoints": [
        "在老旧的React技术栈上进行项目重构，提升开发效率和用户体验",
        "通过技术优化实现多端适配，处理1000万用户和100万数据量的业务需求",
        "采用Umi框架和ESLint进行代码规范和性能优化",
        "实施低代码平台，提高开发效率和组件复用性",
        "实现跨平台热拔插功能，提升项目灵活性和可维护性"
      ],
      "keywords": [
        "React",
        "重构",
        "性能优化",
        "多端适配",
        "低代码平台"
      ],
      "techStack": [
        "React",
        "Umi",
        "ESLint",
        "低代码平台"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/job-description/ASK_RECORD_AI.md": {
      "summary": "本文档介绍了模拟面试回答稿的两种版本：书面版和口语版，用于不同的面试场景。书面版用于准备和复盘，结构化回答问题；口语版用于现场表达，注重自然流畅和信息密度。文档还详细描述了一个项目案例，即大疆用户中心的重构，包括项目背景、技术选型、实施步骤和项目价值。",
      "keyPoints": [
        "模拟面试回答稿分为书面版和口语版，针对不同面试场景设计。",
        "书面版用于准备和复盘，结构化回答问题；口语版用于现场表达。",
        "以大疆用户中心重构项目为例，展示了技术选型、实施步骤和项目价值。",
        "项目重构旨在解决代码不一致、性能问题和高风险登录链路等挑战。",
        "重构采用Vue2 + webpack，引入TypeScript和响应式方案，实现多端统一和性能优化。"
      ],
      "keywords": [
        "模拟面试",
        "书面版",
        "口语版",
        "用户中心重构",
        "Vue2",
        "TypeScript"
      ],
      "techStack": [
        "Vue2",
        "webpack",
        "TypeScript"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/job-description/ASK_RECORD_BOOK_AI.md": {
      "summary": "本文档描述了一种模拟面试回答稿的书面版结构，用于面试准备和复盘。它包括自我介绍、项目经验和问题解决策略的详细描述。文档强调了项目重构、工程化、质量体系、跨系统能力和全栈交付等方面的经验。",
      "keyPoints": [
        "模拟面试回答稿的书面版结构",
        "自我介绍和项目经验详细描述",
        "项目重构和工程化经验",
        "质量体系和全栈交付实践",
        "问题解决策略的阐述"
      ],
      "keywords": [
        "模拟面试",
        "回答稿",
        "项目经验",
        "工程化",
        "质量体系"
      ],
      "techStack": [
        "TypeScript",
        "Vue2",
        "webpack",
        "NestJS"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/job-description/ASK_RECORD_KEY.md": {
      "summary": "大疆用户中心重构技术文档介绍了骨架屏和core-js/polyfill策略的优化方法，旨在提升首屏加载速度和兼容性。骨架屏通过在首屏关键区域预渲染骨架结构来减少白屏时间，而core-js则通过按需注入兼容性代码来减小首屏包体积。",
      "keyPoints": [
        "骨架屏用于解决首屏白屏感知问题，通过预渲染关键区域骨架来提升LCP并避免CLS。",
        "core-js的优化策略是按需注入兼容性代码，避免过度兼容导致首屏包体积过大。",
        "骨架屏的验证方法包括线上RUM数据和人工慢网测试。",
        "骨架屏实施时需注意避免CSS过大、尺寸不一致和动画过多的问题。",
        "core-js的兼容矩阵需要根据目标浏览器范围来设定，避免默认全兼容导致的性能问题。"
      ],
      "keywords": [
        "骨架屏",
        "首屏加载",
        "core-js",
        "polyfill",
        "兼容性"
      ],
      "techStack": [
        "Web开发"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/job-description/ASK_RECORD_SPEAK_AI.md": {
      "summary": "该文档提供了一种模拟面试的回答稿，旨在帮助面试者准备面试时的口语表达。文档中涵盖了自我介绍、项目经验介绍以及问题解决策略的描述，强调了事实与决策过程的重要性，并提供了关于性能指标（LCP、FCP、CLS、INP、TTFB）的简要说明。",
      "keyPoints": [
        "模拟面试回答稿，针对不同场景提供书面版和口语版",
        "强调事实与决策过程，让面试官感受能力",
        "自我介绍中突出个人背景和项目经验",
        "用户中心重构案例展示技术能力和项目管理经验",
        "介绍性能指标（LCP、FCP、CLS、INP、TTFB）"
      ],
      "keywords": [
        "模拟面试",
        "自我介绍",
        "项目经验",
        "性能指标",
        "用户体验"
      ],
      "techStack": [
        "前端开发"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/job-description/history/web前端开发工程师-彭聪-软通.md": {
      "summary": "彭聪是一位拥有9年经验的前端开发工程师，擅长复杂系统重构、工程化、性能优化和架构设计。他在大疆用户中心重构和售后RMS系统重构项目中发挥了关键作用，通过技术优化提升了系统性能和开发效率。",
      "keyPoints": [
        "主导千万级用户系统重构，日均承载120W+请求",
        "自研工具链提升效能30%，优化性能和开发流程",
        "在用户中心重构中实现性能优化，登录转化率提升18%，客诉率下降12%",
        "在售后RMS系统重构中建立Code Review机制，团队BUG率下降25%"
      ],
      "keywords": [
        "前端开发",
        "系统重构",
        "性能优化",
        "工程化",
        "架构设计"
      ],
      "techStack": [
        "JavaScript",
        "React",
        "Node.js",
        "Webpack",
        "ESLint"
      ],
      "difficulty": "高级",
      "contentType": "实践"
    },
    "/job-description/history/简历.md": {
      "summary": "彭聪是一位拥有9年经验的前端开发工程师，擅长复杂系统重构、工程化、性能优化，精通Vue和React双栈开发，以及微信小程序开发。他在大疆售后RMS系统重构和大疆用户中心重构项目中展现了出色的技术能力和业务价值。",
      "keyPoints": [
        "主导千万级用户量系统重构，实现响应式代码融合方案",
        "制定ESLint规范，提升代码可读性和开发效率",
        "优化LCP指标，实现首屏加载时间小于1.5秒",
        "开发通用组件库，提高代码复用率",
        "落地低代码平台，降低人力成本"
      ],
      "keywords": [
        "前端开发",
        "系统重构",
        "性能优化",
        "Vue",
        "React",
        "低代码平台"
      ],
      "techStack": [
        "React",
        "TypeScript",
        "ESLint",
        "低代码平台",
        "微信小程序"
      ],
      "difficulty": "高级",
      "contentType": "实践"
    },
    "/job-description/lib/01-大疆用户中心重构-面试技术大纲.md": {
      "summary": "大疆用户中心重构项目采用Vue3、TypeScript、Vite和Pinia技术栈，重点在于性能优化和HTTP原理理解。文档详细介绍了性能优化的指标体系、定位方法和优化策略，以及简历可落地点的优化措施。此外，还涵盖了HTTP协议的常见考点和Webpack构建流程及优化。",
      "keyPoints": [
        "性能优化指标体系包括LCP、FCP、TTI等",
        "采用骨架屏预渲染、代码体积优化、资源加载优化等策略",
        "深入理解HTTP/1.1、HTTP/2、HTTP/3协议差异和TLS握手流程",
        "Webpack构建流程和优化策略，如splitChunks和tree-shaking"
      ],
      "keywords": [
        "Vue3",
        "TypeScript",
        "性能优化",
        "HTTP",
        "Webpack"
      ],
      "techStack": [
        "Vue3",
        "TypeScript",
        "Vite",
        "Pinia",
        "Webpack"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/job-description/lib/02-大疆售后RMS系统重构-面试技术大纲.md": {
      "summary": "大疆售后 RMS 系统重构项目主要采用 React 18 和 TypeScript 技术栈，重点在于多人协作的工程化治理，包括 ESLint 规范、React 和 TypeScript 规范的落地，以及中后台系统的可维护性和模块化。项目通过 Umi 落地方式，结合 husky、lint-staged 和 commitlint 工具，实现代码风格统一、质量控制和流程约束。",
      "keyPoints": [
        "采用 React 18 和 TypeScript 进行系统重构",
        "实施 ESLint 规范以提升代码质量和一致性",
        "通过 Umi 落地方式实现多人协作的工程化治理",
        "使用 husky、lint-staged 和 commitlint 工具进行代码风格和流程控制",
        "注重中后台系统的可维护性和模块化设计"
      ],
      "keywords": [
        "React 18",
        "TypeScript",
        "ESLint",
        "Umi",
        "多人协作",
        "工程化治理"
      ],
      "techStack": [
        "React 18",
        "TypeScript",
        "Webpack",
        "Ant Design",
        "Umi",
        "ESLint",
        "husky",
        "lint-staged",
        "commitlint"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/job-description/lib/03-跨平台公告插件系统-面试技术大纲.md": {
      "summary": "该文档详细介绍了跨平台公告插件系统的技术架构和实现细节，包括构建工具的横向对比、Preact选型、热插拔和多路复用等关键特性。文档强调了Rollup的tree-shaking和产物体积优势，Preact的信号机制，以及热插拔和多路复用技术，旨在实现极致包体积和跨系统标准化接入。",
      "keyPoints": [
        "Rollup与Webpack、Vite的构建工具对比，突出Rollup在库友好、tree-shaking和产物体积方面的优势。",
        "Preact选型分析，包括与React的体积、兼容性、生态差异和信号机制的特点。",
        "热插拔架构设计，包括生命周期设计、隔离策略、灰度与回滚机制以及植入模式的选择。",
        "多路复用技术实现，探讨一次构建/一次运行服务多个系统的复用层级。",
        "跨系统标准化接入，通过CDN、Iframe和Web Component等模式实现插件系统的多模式植入。"
      ],
      "keywords": [
        "Rollup",
        "Webpack",
        "Vite",
        "Preact",
        "Tree Shaking",
        "热插拔",
        "多路复用"
      ],
      "techStack": [
        "Rollup",
        "Webpack",
        "Vite",
        "Preact",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/job-description/lib/04-大疆DevOps平台维护-面试技术大纲.md": {
      "summary": "本技术文档主要针对大疆DevOps平台维护期间的技术面试大纲，涵盖了CI/CD流水线原理、Docker部署、微前端选型与原理（qiankun）等内容，旨在考察面试者对DevOps流程、容器化技术以及微前端架构的理解和实践能力。",
      "keyPoints": [
        "CI/CD流水线的基础链路和阶段，包括触发方式、产物管理和环境治理",
        "Docker镜像原理、发布模式和发布策略",
        "微前端选型维度和qiankun的核心原理，包括注册与加载、隔离机制、通信方式以及与其他方案的对比"
      ],
      "keywords": [
        "CI/CD",
        "Docker",
        "微前端",
        "qiankun",
        "DevOps"
      ],
      "techStack": [
        "Vue3",
        "TypeScript",
        "Docker",
        "qiankun"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/job-description/lib/05-XDR系统-魔方大屏+报表-面试技术大纲.md": {
      "summary": "本技术文档详细介绍了XDR系统中的魔方大屏和报表系统的开发技术。魔方大屏采用低代码架构，重点解析了其内部原理，包括物料体系、渲染器和编辑器能力。报表系统则基于NestJS的SSR（服务器端渲染）原理，探讨了其渲染流程、Hydration机制、流式SSR的价值和缓存策略。",
      "keyPoints": [
        "魔方大屏的低代码架构和内部原理",
        "报表系统基于NestJS的SSR实现及其价值",
        "数据源、事件编排和编辑器能力的详细解析",
        "SSR的渲染流程、Hydration和流式SSR的优缺点",
        "缓存策略和稳定性与降级机制的探讨"
      ],
      "keywords": [
        "XDR系统",
        "魔方大屏",
        "低代码",
        "NestJS",
        "SSR",
        "ECharts",
        "mongoose"
      ],
      "techStack": [
        "React",
        "ECharts",
        "NestJS",
        "mongoose"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/job-description/lib/06-大疆用户中心重构-hard-mode-面试题.md": {
      "summary": "本技术文档讨论了大疆用户中心的重构，重点在于使用Vue3、TypeScript、Vite和Pinia等技术栈，实现PC/移动端融合，并优化性能指标。文档详细探讨了架构取舍、性能指标定位、以及如何量化维护成本降低等关键问题。",
      "keyPoints": [
        "PC/移动端融合的维护成本降低50%的量化方法",
        "一套代码多端适配的可复用边界定义和避免过度复用的策略",
        "媒体查询、容器查询和组件响应式方案的比较和选择依据",
        "移动端适配中处理DPR、1px、字体缩放与第三方组件冲突的方法",
        "同一路由同时服务PC/移动端时，如何表达不同布局和模块组合"
      ],
      "keywords": [
        "Vue3",
        "TypeScript",
        "Vite",
        "Pinia",
        "PC/移动端融合",
        "性能优化",
        "LCP"
      ],
      "techStack": [
        "Vue3",
        "TypeScript",
        "Vite",
        "Pinia"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/job-description/lib/07-大疆售后RMS系统重构-Hard-Mode-面试题.md": {
      "summary": "本技术文档讨论了大疆售后RMS系统重构的Hard-Mode面试题，涵盖了大型项目协作与代码质量、低代码平台架构与可扩展性，以及性能与稳定性等方面。文档深入探讨了多人协作中的质量体系、低代码平台的架构设计、以及如何保证系统的性能和稳定性。",
      "keyPoints": [
        "探讨大型项目多人协作中的质量体系，包括代码质量、评审、测试等环节。",
        "分析低代码平台的架构设计，包括Schema设计、组件注册、动态渲染等。",
        "讨论性能与稳定性，包括稳定性指标的定义和实现。",
        "评估低代码平台的可扩展性，包括扩展点的设计和治理。",
        "分析如何保证低代码平台的数据流一致性和性能优化。"
      ],
      "keywords": [
        "大疆售后RMS",
        "低代码平台",
        "性能稳定性",
        "代码质量",
        "多人协作"
      ],
      "techStack": [
        "低代码开发",
        "前端架构",
        "性能优化",
        "代码审查工具"
      ],
      "difficulty": "高级",
      "contentType": "面试题 + 原理"
    },
    "/job-description/lib/08-跨平台公告插件系统-Hard-Mode-面试题.md": {
      "summary": "该文档探讨了如何构建一个跨平台的公告插件系统，重点在于实现小于15KB的体积限制，使用Rollup进行体积治理，Tree Shaking优化，结合Preact signals实现响应式更新，并设计热插拔架构。文档深入讨论了体积控制、依赖管理、响应式更新机制、插件生命周期和资源回收等关键问题。",
      "keyPoints": [
        "实现小于15KB的公告插件体积，通过Rollup和Tree Shaking优化",
        "使用Preact signals实现高效的响应式更新机制",
        "设计热插拔架构，确保插件的生命周期管理和资源回收",
        "讨论了体积控制、依赖管理和响应式更新的实现细节和挑战",
        "分析了插件集成和宿主环境约束对决策的影响"
      ],
      "keywords": [
        "Rollup",
        "Tree Shaking",
        "Preact signals",
        "热插拔",
        "插件系统"
      ],
      "techStack": [
        "Rollup",
        "Preact",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/job-description/lib/09-DevOps平台-qiankun微前端-Hard-Mode-面试题.md": {
      "summary": "本文档深入探讨了DevOps平台中qiankun微前端的Hard-Mode面试题，涵盖了qiankun的原理、沙箱隔离、样式隔离、通信机制、独立部署与版本治理，以及性能与稳定性治理等多个方面。文档详细分析了qiankun的工作机制、隔离策略、通信方式、部署策略和性能优化方法，旨在帮助开发者全面理解qiankun微前端框架。",
      "keyPoints": [
        "qiankun微前端的原理和核心能力",
        "沙箱隔离和样式隔离的实现机制及选择策略",
        "子应用的加载、挂载、卸载生命周期管理",
        "应用间通信和共享状态的策略与实现",
        "独立部署与版本兼容性管理",
        "性能与稳定性治理的方法和最佳实践"
      ],
      "keywords": [
        "qiankun",
        "微前端",
        "沙箱隔离",
        "样式隔离",
        "通信",
        "独立部署",
        "版本治理",
        "性能优化"
      ],
      "techStack": [
        "JavaScript",
        "React",
        "TypeScript"
      ],
      "difficulty": "高级",
      "contentType": "原理 + 实践"
    },
    "/job-description/lib/10-XDR系统-NestJS全栈-Hard-Mode-面试题.md": {
      "summary": "本面试题针对使用 NestJS 构建的 XDR 系统，涉及 NestJS 架构与工程设计、MongoDB/Mongoose 数据建模、定时任务可靠性、报表导出链路以及实时大屏性能等多个方面，旨在考察应聘者对全栈开发的深入理解和实践经验。",
      "keyPoints": [
        "NestJS 架构与工程设计，包括模块划分、依赖注入、中间件等",
        "MongoDB/Mongoose 数据建模策略，如嵌入 vs 引用，索引设计，聚合管道使用",
        "定时任务（cron）的可靠性和可观测性，包括任务队列的使用和监控",
        "报表导出链路设计，包括异步处理、进度估算和失败补偿",
        "模板引擎的选择和维护"
      ],
      "keywords": [
        "NestJS",
        "DI",
        "MongoDB",
        "Mongoose",
        "定时任务",
        "报表导出"
      ],
      "techStack": [
        "NestJS",
        "JavaScript",
        "MongoDB",
        "Mongoose",
        "Bull"
      ],
      "difficulty": "高级",
      "contentType": "实践 + 原理"
    },
    "/job-description/lib/11-frontend-hard-mode-interview-原题提取-基于简历.md": {
      "summary": "本文档介绍了TCP、UDP、TLS等网络通信协议的基本概念和作用，强调了这些知识对于前端工程师的重要性，特别是在面试和日常工作中。文档详细描述了TCP/IP协议集的结构，包括应用层、传输层、网络层和网络访问层，并列举了每个层次中包含的协议及其功能。",
      "keyPoints": [
        "TCP/IP协议集包括应用层、传输层、网络层和网络访问层",
        "应用层协议如HTTP、TFTP、Telnet、SNMP、DNS等",
        "传输层协议包括TLS（传输层安全）",
        "了解网络通信原理有助于前端工程师与后端工程师的沟通和协作"
      ],
      "keywords": [
        "TCP/IP",
        "TCP",
        "UDP",
        "TLS",
        "网络通信"
      ],
      "techStack": [
        "网络协议"
      ],
      "difficulty": "进阶",
      "contentType": "原理"
    },
    "/job-description/lib/Framework.md": {
      "summary": "本技术文档深入探讨了React 16+版本的核心原理和差异，包括Fiber架构、Hooks、渲染机制、Diff算法、Hooks原理与常见问题，以及工程实践中的性能优化、可靠性保障和调试技巧。",
      "keyPoints": [
        "React 16+版本的核心特性及其演进",
        "渲染机制中的render phase和commit phase，以及Scheduler的调度策略",
        "Diff算法的核心规则和key的作用",
        "Hooks的原理和常见问题处理",
        "工程实践中的性能优化、可靠性和调试方法"
      ],
      "keywords": [
        "React",
        "Fiber",
        "Hooks",
        "渲染机制",
        "Diff算法"
      ],
      "techStack": [
        "React"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/job-description/web前端开发工程师-彭聪-面试技术大纲.md": {
      "summary": "本技术大纲针对大疆用户中心重构项目，涵盖了性能优化、HTTP原理、Webpack架构等方面，包括性能指标、优化策略、HTTP协议版本比较、TLS机制、缓存体系、Webpack构建流程和优化技巧等，旨在帮助前端工程师提升面试技能。",
      "keyPoints": [
        "性能优化指标包括LCP、FCP、TTI、CLS、INP等，以及首屏/白屏时间、资源体积、接口耗时、缓存命中率等。",
        "HTTP/1.1、HTTP/2、HTTP/3的比较，包括队头阻塞、并发模型、HPACK/QPACK、0-RTT等特性。",
        "Webpack构建流程和优化，如splitChunks、runtimeChunk、tree-shaking、scope hoisting等。",
        "性能优化策略包括骨架屏预渲染、代码体积优化、资源加载优化、传输层优化、图片优化等。",
        "HTTP缓存体系，包括强缓存、协商缓存、CDN缓存、版本号/哈希策略、Service Worker缓存与更新等。"
      ],
      "keywords": [
        "性能优化",
        "HTTP",
        "Webpack",
        "缓存",
        "HTTP/2",
        "HTTP/3"
      ],
      "techStack": [
        "Webpack",
        "HTTP/2",
        "HTTP/3",
        "Service Worker"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/job-description/web前端开发工程师-彭聪.md": {
      "summary": "彭聪是一位拥有9年经验的前端开发工程师，擅长复杂系统重构、工程化、性能优化和架构设计。他主导了千万级用户系统的重构，并自研工具链提升效能。彭聪具备全栈能力，熟练使用React、Vue、TypeScript、Node.js等技术，并在性能优化和微前端架构方面有深入实践。",
      "keyPoints": [
        "主导千万级用户系统重构，日均承载120W+请求",
        "自研工具链提升工程效能30%",
        "在性能优化方面有显著成果，如LCP优化28.9%，首屏加载时间小于1.5秒",
        "具备全栈能力，使用NestJS进行全栈开发",
        "在多个项目中担任前端负责人，成功实现多端适配和性能提升"
      ],
      "keywords": [
        "前端开发",
        "系统重构",
        "性能优化",
        "全栈开发",
        "NestJS"
      ],
      "techStack": [
        "React",
        "Vue",
        "TypeScript",
        "JavaScript",
        "Node.js",
        "NestJS",
        "Webpack",
        "Rollup",
        "Vite",
        "Docker",
        "CI/CD"
      ],
      "difficulty": "高级",
      "contentType": "实践"
    },
    "/job-description/web前端开发工程师-彭聪2.md": {
      "summary": "彭聪是一位拥有9年经验的前端开发工程师，擅长复杂系统重构、工程化建设和性能优化。他在大疆用户中心重构项目中实现了多端适配和性能提升，在大疆售后RMS系统重构中推动了工程化建设，并独立开发了跨平台公告插件系统。",
      "keyPoints": [
        "主导千万级用户系统重构，日均承载120W+请求",
        "自研工具链提升效能30%，优化性能，实现首屏加载<1.5s",
        "跨系统插件体系和微前端解决方案的设计与实施",
        "响应式融合开发，一套代码多端适配",
        "建立Code Review机制，输出技术文档，降低团队BUG率"
      ],
      "keywords": [
        "前端开发",
        "系统重构",
        "性能优化",
        "工程化",
        "低代码平台"
      ],
      "techStack": [
        "JavaScript",
        "React",
        "Node.js",
        "Webpack",
        "ESLint"
      ],
      "difficulty": "高级",
      "contentType": "实践"
    },
    "/job-description/简历分析-彭聪.md": {
      "summary": "彭聪的简历分析报告指出，这是一份内容丰富、结构清晰的前端开发工程师简历，强调了其技术能力和项目经验。报告对简历的优点和缺点进行了详细分析，并给出了改进建议。",
      "keyPoints": [
        "简历结构清晰，视觉层次分明，易于快速浏览",
        "量化数据充分，展现技术深度和业务价值",
        "技术能力全面，涵盖前端到后端，具有全栈思维",
        "项目时间线问题已修复，工作经历时间线准确",
        "存在获奖与影响力，显示技术贡献和影响力"
      ],
      "keywords": [
        "简历分析",
        "前端开发",
        "技术能力",
        "项目经验",
        "量化数据"
      ],
      "techStack": [
        "前端",
        "Node.js",
        "性能优化",
        "工程化建设"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/job-description/高级前端面试题-基于简历.md": {
      "summary": "本文档为高级前端面试题，针对彭聪的简历内容整理，涵盖系统重构与架构设计、性能优化、技术选型、团队协作等多个方面。文档通过具体项目经验，考察面试者的响应式设计、性能优化、Vue3特性、状态管理、代码规范、低代码平台设计等能力。",
      "keyPoints": [
        "用户中心重构项目通过响应式融合开发降低维护成本，优化LCP性能，采用Vue3 + Vite + Pinia技术栈。",
        "RMS系统重构项目保证多人协作代码质量，实施低代码平台提升页面开发效率。",
        "性能优化包括骨架屏预渲染、按需引入、资源加载优先级、压缩配置等。",
        "技术选型考虑Vue3的Composition API、Vite的快速冷启动、Pinia的轻量级和TypeScript支持。",
        "团队协作通过ESLint、Prettier、Git commit规范、Code Review等确保代码质量。"
      ],
      "keywords": [
        "系统重构",
        "架构设计",
        "性能优化",
        "Vue3",
        "低代码平台",
        "团队协作"
      ],
      "techStack": [
        "Vue3",
        "Vite",
        "Pinia",
        "ESLint",
        "Prettier",
        "Git",
        "TypeScript"
      ],
      "difficulty": "高级",
      "contentType": "实践 + 原理"
    },
    "/mark/01-React核心原理-补充.md": {
      "summary": "React 19 引入了多项新特性和优化，包括自动优化编译器、表单处理增强、统一资源读取 API、简化 ref 传递、内置 SEO 支持、资源预加载 API、Suspense 和 Context 性能优化。同时，文档深入解析了 useMemo 和 useCallback 的使用场景和原理。",
      "keyPoints": [
        "React Compiler 自动优化组件性能，减少手动使用 memo/useMemo/useCallback 的需求",
        "新增 Actions Hooks 增强表单处理能力，支持乐观更新 UI",
        "use() API 统一资源读取，简化异步操作和 Context 使用",
        "ref 作为 prop 简化 ref 传递过程",
        "Document Metadata 组件直接管理 SEO 元数据",
        "资源预加载 API 提升页面加载性能",
        "Suspense 和 Context 性能优化，提高应用响应速度"
      ],
      "keywords": [
        "React 19",
        "自动优化",
        "表单处理",
        "资源读取",
        "SEO",
        "预加载",
        "Suspense",
        "Context"
      ],
      "techStack": [
        "React"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/mark/01-React核心原理.md": {
      "summary": "本文档深入探讨了 React 16 及以上版本的核心特性、Fiber 架构、更新流程、协调与 Key 的使用、并发与并行渲染的区别、以及 React 18 的 automatic batching。它涵盖了 React 的核心原理，适合对 React 有一定了解的开发者。",
      "keyPoints": [
        "React 16/17/18 版本在渲染/更新层面的关键变化点",
        "Fiber 架构的详解，包括其解决的问题、核心数据结构及关联方式",
        "React 更新流程的各个阶段及其主要工作",
        "协调（reconciliation）与 Key 的作用及错误使用的影响",
        "并发（Concurrent）与并行（Parallel）的区别及 React 18 的并发渲染实现",
        "React 18 Automatic Batching 的覆盖场景及与 React 17 的差异",
        "Fiber 架构的可中断性及其依赖的底层机制",
        "Render 阶段与 Commit 阶段的区别及为什么 Commit 阶段不能被打断"
      ],
      "keywords": [
        "React",
        "Fiber",
        "Concurrent",
        "Reconciliation",
        "Key",
        "Automatic Batching"
      ],
      "techStack": [
        "React"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/mark/02-Webpack与构建工具.md": {
      "summary": "本文档深入探讨了 Webpack 架构，包括其构建流程、与 Rollup 和 Vite 的对比，以及核心原理。文档详细解释了 Webpack 的入口、loader、plugin、chunk 和 asset 的概念和作用，并提供了构建流程的图示和代码示例。",
      "keyPoints": [
        "Webpack 构建流程包括入口、loader、plugin、chunk 和 asset 等关键步骤。",
        "Loader 用于转换非 JavaScript 文件为 Webpack 可处理的模块。",
        "Plugin 在 Webpack 构建流程的特定时机执行自定义逻辑。",
        "Chunk 是多个模块的集合，是 Webpack 内部的中间产物。",
        "Asset 是最终输出到 dist 目录的文件，包括 JavaScript bundle、CSS 文件、图片、字体等。"
      ],
      "keywords": [
        "Webpack",
        "构建流程",
        "loader",
        "plugin",
        "chunk",
        "asset"
      ],
      "techStack": [
        "Webpack"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/mark/03-性能优化.md": {
      "summary": "本文档详细介绍了从用户输入URL到页面可交互的全链路过程，并分析了每个环节的性能优化点，旨在提高页面加载速度和交互响应性。",
      "keyPoints": [
        "从DNS解析到页面可交互的全链路分析",
        "网络层、资源加载和渲染环节的优化策略",
        "DNS解析、TCP连接、TLS握手、HTTP请求等环节的优化点",
        "HTML、CSS、JS和图片的加载优化方法",
        "减少DOM层级、避免强制同步布局等渲染优化技巧"
      ],
      "keywords": [
        "性能优化",
        "URL到页面交互",
        "DNS解析",
        "TCP连接",
        "TLS握手",
        "HTTP请求",
        "资源加载",
        "渲染优化"
      ],
      "techStack": [
        "网络协议",
        "HTTP/2",
        "CDN",
        "JavaScript",
        "CSS",
        "HTML"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/mark/04-微前端.md": {
      "summary": "本技术文档探讨了微前端架构的核心问题、主流方案对比、适用性判断、基础设施设计、部署发布策略以及子应用性能治理。文档通过对比iframe、single-spa、qiankun、Module Federation等方案，分析了微前端的实现原理和复杂度，并提供了相应的解决方案。",
      "keyPoints": [
        "微前端解决大型应用开发中的模块化、团队协作和持续集成问题。",
        "微前端引入了模块间通信、权限控制、统一登录态等新复杂度。",
        "对比了主流微前端方案的优缺点，包括iframe、single-spa、qiankun和Module Federation。",
        "讨论了微前端的适用性判断标准、基础设施设计、部署发布策略和子应用性能治理方法。"
      ],
      "keywords": [
        "微前端",
        "架构",
        "iframe",
        "single-spa",
        "qiankun",
        "Module Federation"
      ],
      "techStack": [
        "JavaScript",
        "框架",
        "模块化"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/mark/05-低代码.md": {
      "summary": "本文档深入探讨了低代码开发平台的核心原理，包括其核心抽象如Schema/DSL、组件物料、引擎和渲染器，以及搭建态和运行态的区别和各自所需实现的能力。",
      "keyPoints": [
        "低代码平台的核心抽象包括Schema/DSL、组件物料、引擎和渲染器。",
        "Schema/DSL定义页面/组件结构，组件物料提供可复用的UI组件，引擎负责解析和协调工作，渲染器负责可视化渲染。",
        "搭建态是可视化编辑环境，运行态是页面实际运行环境，两者分层以实现不同的功能。"
      ],
      "keywords": [
        "低代码",
        "Schema/DSL",
        "组件物料",
        "引擎",
        "渲染器",
        "搭建态",
        "运行态"
      ],
      "techStack": [
        "React",
        "Vue",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理"
    },
    "/mark/06-插件系统.md": {
      "summary": "本文探讨了插件系统的核心要素，包括生命周期、扩展点、上下文、隔离和通信。详细解释了每个要素的定义、作用和实现方式，旨在帮助理解插件系统的架构和设计原则。",
      "keyPoints": [
        "插件系统是一种可扩展的架构模式，允许第三方代码动态扩展应用功能。",
        "插件生命周期包括注册、初始化、激活、执行、停用和卸载等阶段。",
        "扩展点允许插件在特定接口注入自定义逻辑，如Hook点、命令点和UI扩展点。",
        "上下文提供插件执行时的环境信息，包括系统API、配置信息、共享状态和依赖注入。",
        "隔离确保插件之间的互不干扰，包括命名空间、资源、错误和沙箱隔离。",
        "插件通信机制包括事件总线、服务注册和消息传递等。"
      ],
      "keywords": [
        "插件系统",
        "生命周期",
        "扩展点",
        "上下文",
        "隔离",
        "通信"
      ],
      "techStack": [
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "概念"
    },
    "/mark/07-NestJS与SSR.md": {
      "summary": "本文档深入探讨了 NestJS 全栈开发框架，包括其核心概念如模块、控制器、服务、依赖注入和装饰器，以及它们如何协同工作。此外，文档还比较了 NestJS 与 Express/Koa 的异同，并简要介绍了 SSR（服务器端渲染）的概念和原理。",
      "keyPoints": [
        "NestJS 的核心概念包括模块、控制器、服务、依赖注入和装饰器",
        "模块是应用的基本组织单位，控制器处理HTTP请求，服务封装业务逻辑，依赖注入通过IoC容器实现，装饰器用于元编程",
        "NestJS 与 Express/Koa 相比，提供了更完整的全栈开发解决方案和更好的可维护性",
        "SSR是文档中提到的另一个重要概念，它涉及服务器端渲染技术"
      ],
      "keywords": [
        "NestJS",
        "模块",
        "控制器",
        "服务",
        "依赖注入",
        "装饰器",
        "SSR",
        "服务器端渲染"
      ],
      "techStack": [
        "NestJS",
        "TypeScript",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "概念 + 比较"
    },
    "/mark/08-代码规范.md": {
      "summary": "本文探讨了代码规范的重要性，包括提升代码可读性、减少Bug率、建立工程化标准等。详细介绍了代码规范的维度，如格式、命名、架构和最佳实践，并提出了平衡规范与效率的策略，如使用自动化工具、渐进式推进和团队共识。",
      "keyPoints": [
        "代码规范提升代码质量和团队协作效率",
        "规范维度包括格式、命名、架构和最佳实践",
        "平衡规范与效率的策略包括自动化工具和团队共识",
        "使用ESLint和Prettier等工具实现自动化格式化",
        "渐进式推进规范，逐步收紧非关键规则"
      ],
      "keywords": [
        "代码规范",
        "Umi",
        "ESLint",
        "格式化",
        "命名规范",
        "架构"
      ],
      "techStack": [
        "ESLint",
        "Prettier",
        "React"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/mark/09-Promise原理.md": {
      "summary": "本文档深入探讨了 JavaScript 中 Promise 的设计原因、实现原理、规范、使用方法以及与 async/await 的关系。它涵盖了 Promise 的必要性、状态机、A+ 规范、静态方法、手写实现以及与 async/await 的对比。",
      "keyPoints": [
        "Promise 解决了回调地狱、错误处理和异步操作组合的问题。",
        "Promise 有三种状态：pending、fulfilled 和 rejected，状态转换不可逆。",
        "Promise A+ 规范定义了 Promise 的行为，包括 then 方法的处理和链式调用。",
        "Promise 提供了多种静态方法，如 all、race、allSettled 和 any，用于处理多个异步操作。",
        "手写实现 Promise 可以加深对 Promise 内部工作原理的理解。",
        "async/await 是基于 Promise 实现的，它简化了异步代码的编写，并提供了更好的错误处理机制。",
        "Promise 在实际使用中存在一些常见问题，如未捕获错误和忘记 return，需要小心处理。",
        "Promise、回调和 async/await 三者各有优缺点，适用于不同的场景。"
      ],
      "keywords": [
        "Promise",
        "Promise A+",
        "async/await",
        "回调地狱",
        "状态机",
        "手写实现"
      ],
      "techStack": [
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/mark/10-骨架屏.md": {
      "summary": "骨架屏是一种页面加载占位符技术，通过展示页面结构轮廓，提升页面加载性能和用户体验。它通过减少FCP、LCP和CLS等性能指标，提供视觉反馈，减少用户等待感和焦虑。骨架屏可以通过手写、自动生成、SSR内联或图片占位等方式实现，各有优缺点。",
      "keyPoints": [
        "骨架屏通过展示页面结构轮廓，在数据加载前提供视觉反馈，提升用户体验。",
        "骨架屏可减少FCP、LCP和CLS等性能指标，优化页面加载速度。",
        "骨架屏有手写、自动生成、SSR内联和图片占位等多种实现方式，各有适用场景和优缺点。"
      ],
      "keywords": [
        "骨架屏",
        "性能优化",
        "用户体验",
        "FCP",
        "LCP",
        "CLS"
      ],
      "techStack": [
        "HTML",
        "CSS"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/mark/11-HTTP与缓存.md": {
      "summary": "本技术文档深入探讨了 HTTP 协议的版本差异、缓存机制、缓存策略设计、Service Worker 缓存以及缓存失效与更新等问题，旨在帮助开发者理解并优化网站性能。",
      "keyPoints": [
        "对比 HTTP/1.1、HTTP/2、HTTP/3 的核心差异及其对前端性能的影响",
        "解析 HTTP 缓存机制，包括强缓存和协商缓存",
        "详细说明 Cache-Control 指令及其常用指令的作用和区别",
        "设计不同资源的缓存策略，包括 HTML、JS/CSS、图片、API，并探讨文件指纹的作用",
        "区分 Service Worker 缓存与 HTTP 缓存，介绍 SW 缓存策略",
        "解决缓存更新问题，包括版本号、文件指纹和缓存清理策略",
        "设计网站的全局缓存策略，包括 HTTP 缓存、CDN 和 Service Worker",
        "分析 HTTP/2 下传统性能优化策略的变化",
        "排查缓存问题，从浏览器、CDN、服务器等多个层面进行",
        "分享缓存优化实践经验"
      ],
      "keywords": [
        "HTTP/1.1",
        "HTTP/2",
        "HTTP/3",
        "缓存机制",
        "Cache-Control",
        "Service Worker",
        "缓存策略",
        "性能优化"
      ],
      "techStack": [
        "HTTP",
        "Web Development"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/mark/React更新流程详解.md": {
      "summary": "本文详细解析了 React 更新流程，从调度阶段到副作用执行，涵盖了 setState 到 DOM 更新的完整旅程，包括调度、协调、提交和副作用执行等关键阶段，以及相关的核心职责、流程和算法。",
      "keyPoints": [
        "调度阶段决定何时和如何执行更新任务，使用时间切片原理和优先级模型。",
        "协调阶段计算DOM变更，不执行实际操作，采用双缓冲机制和Diff算法。",
        "提交阶段执行真实的DOM操作和生命周期方法，分为mutation和layout两个子阶段。",
        "副作用执行阶段处理useEffect和useLayoutEffect的异步调度和执行。",
        "整个更新流程涉及多个阶段和复杂算法，确保高效和正确的DOM更新。"
      ],
      "keywords": [
        "React",
        "更新流程",
        "调度",
        "协调",
        "提交",
        "副作用"
      ],
      "techStack": [
        "React"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/mark/ai-doc-content-enhancement.md": {
      "summary": "该技术文档描述了AI文档生成系统的全面优化，旨在解决文档内容简短的问题。优化包括增强文档模板结构、优化AI生成提示词和提升Token配额，以生成更详尽、实用和专业的技术文档。",
      "keyPoints": [
        "增强文档模板结构，增加概述、详细解析、常见问题和扩展阅读章节",
        "优化AI生成提示词，提高文档内容质量和深度",
        "提升Token配额，支持生成更长、更详细的内容",
        "增加代码示例数量，覆盖基础、进阶和实战场景",
        "提供常见问题和解答，增强文档实用性"
      ],
      "keywords": [
        "AI文档生成",
        "文档模板",
        "内容优化",
        "代码示例",
        "Token配额"
      ],
      "techStack": [
        "AI",
        "Natural Language Processing",
        "Machine Learning"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/node/npm.md": {
      "summary": "本文档提供了关于 npm（Node Package Manager）的一些基本操作指南，包括设置镜像、查看和管理依赖包、清除缓存、导航到相关页面以及脚本命令的执行顺序和获取当前脚本名称的方法。",
      "keyPoints": [
        "如何设置淘宝镜像以加速 npm 包的下载",
        "查看和清除 npm 缓存",
        "查看已安装依赖包及其安装路径",
        "使用脚本命令并行或继发执行任务",
        "获取当前正在运行的 npm 脚本名称"
      ],
      "keywords": [
        "npm",
        "镜像",
        "依赖包",
        "缓存",
        "脚本命令"
      ],
      "techStack": [
        "Node.js"
      ],
      "difficulty": "入门",
      "contentType": "实践"
    },
    "/node/toolkit.md": {
      "summary": "本文档介绍了几个常用的Node.js开发工具包，包括nvm、nrm、nodemon、npm-check-updates和yalc，涵盖了它们的安装方法、设置步骤和常用命令，旨在帮助开发者更高效地管理Node.js环境和依赖。",
      "keyPoints": [
        "nvm：用于管理Node.js版本，支持Windows和Mac系统。",
        "nrm：用于切换npm的注册表，方便使用不同源。",
        "nodemon：自动重启Node.js应用程序，便于开发和调试。",
        "npm-check-updates：自动查找并更新package.json中的依赖包。",
        "yalc：用于调试npm包，模拟发布和全局使用npm包资源。"
      ],
      "keywords": [
        "nvm",
        "nrm",
        "nodemon",
        "npm-check-updates",
        "yalc"
      ],
      "techStack": [
        "Node.js",
        "npm"
      ],
      "difficulty": "入门",
      "contentType": "工具"
    },
    "/online-tools/bookmark-scripts.md": {
      "summary": "该技术文档提供了两个书签脚本的代码示例，一个用于平滑滚动到页面顶部，另一个用于切换密码字段的显示状态，以显示密码内容。",
      "keyPoints": [
        "提供两个书签脚本示例",
        "第一个脚本实现平滑滚动到页面顶部",
        "第二个脚本切换密码字段的类型，从 'password' 切换到 'text' 以显示密码内容"
      ],
      "keywords": [
        "书签脚本",
        "滚动到顶部",
        "显示密码",
        "JavaScript",
        "DOM操作"
      ],
      "techStack": [
        "JavaScript"
      ],
      "difficulty": "入门",
      "contentType": "实践"
    },
    "/react/class-hooks.md": {
      "summary": "本文档深入探讨了 React 框架的核心概念，包括合成事件机制、setState 和 batchUpdate、JSX 和虚拟 DOM、组件更新过程以及性能问题。文档强调了 React 事件处理的兼容性和效率，以及 setState 的异步和同步行为，以及组件更新的两个阶段：reconciliation 和 commit。",
      "keyPoints": [
        "合成事件机制提供更好的兼容性和跨平台支持，减少内存消耗，并方便事件统一管理。",
        "setState 有时异步，有时同步，有时合并，有时不合并，理解其主流程和 batchUpdate 机制是关键。",
        "JSX 是 React 的构建块，通过 createElement 函数生成虚拟 DOM，并通过 patch 算法更新。",
        "组件更新分为 reconciliation 和 commit 两个阶段，前者进行 diff 计算，后者渲染 DOM。",
        "React 的单线程模型和 DOM 渲染共享线程可能导致性能问题，特别是在复杂组件更新时。"
      ],
      "keywords": [
        "React",
        "合成事件",
        "setState",
        "batchUpdate",
        "JSX",
        "虚拟 DOM",
        "组件更新",
        "性能问题"
      ],
      "techStack": [
        "React"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/react/react-render.md": {
      "summary": "本文从 React 18+ 源码角度，详细解析了 React 从创建根节点到渲染真实 DOM 的完整流程，重点关注 Fiber 架构下的核心机制，包括初始化、调度、渲染阶段、提交阶段以及副作用处理。流程分为 Render Phase 和 Commit Phase，涉及 Fiber 树的构建、Effect 链表的生成和真实 DOM 的更新。",
      "keyPoints": [
        "React 渲染流程分为 Render Phase 和 Commit Phase",
        "Fiber 架构是 React 18+ 的核心机制，负责构建和更新 Fiber 树",
        "Scheduler 负责调度更新，使渲染过程可中断和异步",
        "Effect 链表记录了需要更新的 DOM 元素和副作用",
        "commit 阶段负责将更新应用到真实 DOM 并执行副作用"
      ],
      "keywords": [
        "React",
        "Fiber 架构",
        "渲染流程",
        "Scheduler",
        "Effect 链表"
      ],
      "techStack": [
        "React",
        "JavaScript",
        "React 18+",
        "react-reconciler",
        "react-dom"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/react/react16.md": {
      "summary": "React 16 引入了革命性的 Fiber 架构，解决了 React 15 及之前版本中递归调和导致的性能问题，并引入了错误边界机制，增强了应用的健壮性。本文旨在用 15 分钟时间帮助熟悉 React 的开发者快速理解 React 16 的核心突破。",
      "keyPoints": [
        "Fiber 架构的引入，解决了递归调和导致的性能问题，支持异步渲染。",
        "错误边界机制允许捕获组件内部的错误，防止整个应用崩溃。",
        "React 16 的升级是理解现代 React 版本的基础，对前端开发者至关重要。"
      ],
      "keywords": [
        "React 16",
        "Fiber 架构",
        "错误边界",
        "异步渲染",
        "性能优化"
      ],
      "techStack": [
        "React"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/react/react17.md": {
      "summary": "本文深入探讨了 React 17 版本，尽管没有引入新特性，但仍然包含重要的更新，如 JSX 转换的改进，对 React 开发者和源码学习者来说，理解这些变化对于保持技术领先至关重要。",
      "keyPoints": [
        "React 17 没有引入新特性，但包含重要的更新。",
        "JSX 转换的改进，简化了代码并提高了性能。",
        "React 开发者需要了解这些变化以保持技术领先。",
        "文档提供了 JSX 转换的代码示例和解释。",
        "强调了源码学习的重要性。"
      ],
      "keywords": [
        "React 17",
        "JSX 转换",
        "性能优化",
        "源码学习",
        "开发者"
      ],
      "techStack": [
        "React"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/react/react18.md": {
      "summary": "React 18 引入了并发渲染（Concurrent rendering）机制，通过新的 API 如 `startTransition`、`useDeferredValue` 和 `<SuspenseList>` 提升应用性能和用户体验。同时，React 18 支持多种入口模式，包括 legacy、blocking 和 concurrent，并引入了异步批处理和 `flushSync` API 来控制更新过程。",
      "keyPoints": [
        "并发渲染（Concurrent rendering）机制提升性能和响应性",
        "新的 API `startTransition`、`useDeferredValue` 和 `<SuspenseList>`",
        "多种入口模式：legacy、blocking 和 concurrent",
        "异步批处理和 `flushSync` API 控制 React 更新过程"
      ],
      "keywords": [
        "React 18",
        "Concurrent rendering",
        "startTransition",
        "useDeferredValue",
        "SuspenseList"
      ],
      "techStack": [
        "React"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/software/browser.md": {
      "summary": "本文档介绍了浏览器扩展的相关信息，包括扩展商店、体验优化工具和广告拦截工具等，旨在帮助用户了解和选择适合自己的浏览器扩展。",
      "keyPoints": [
        "提供了多个浏览器扩展商店的链接，如Chrome网上应用店和CrxDL等。",
        "介绍了多种体验优化工具，如自定义新标签页、二维码生成器和广告拦截工具。",
        "列举了Infinity新标签页、Momentum、MONKNOW新标签页等具体扩展应用。",
        "提到了uBlock Origin和Adblock for YouTube等广告拦截工具。",
        "提供了哔哩哔哩助手的链接，但未详细描述其功能。"
      ],
      "keywords": [
        "浏览器扩展",
        "扩展商店",
        "体验优化",
        "广告拦截",
        "自定义新标签页"
      ],
      "techStack": [
        "Chrome"
      ],
      "difficulty": "入门",
      "contentType": "工具"
    },
    "/software/claude-skills-guide.md": {
      "summary": "Claude Skills 是 Claude AI 的模块化扩展机制，允许用户为 Claude 添加特定领域的知识、工作流程和工具，使其成为特定任务的专家。文档介绍了 Skills 的核心价值、原理、文件结构以及如何编写适合自己项目的 Skill。",
      "keyPoints": [
        "Skills 是 Claude AI 的模块化扩展机制，提供专业工作流、工具集成、领域知识和资源捆绑。",
        "Skills 使用三层渐进加载机制和自由度匹配原则来高效管理上下文空间和指令形式。",
        "Skill 文件结构遵循标准目录结构，包括资源类型说明和加载时机。",
        "文档提供了编写 Skills 的指南，包括代码示例和目录结构说明。"
      ],
      "keywords": [
        "Claude AI",
        "Skills",
        "模块化扩展",
        "工作流",
        "工具集成"
      ],
      "techStack": [
        "AI",
        "Machine Learning"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/software/cross-platform.md": {
      "summary": "本技术文档介绍了多款效率工具，包括插件化的uTools、下载神器Motrix、Hosts管理工具SwitchHosts、Android设备连接工具QtScrcpy以及图床工具PicGo，涵盖了从文件管理、网络连接到图片上传等多个应用场景。",
      "keyPoints": [
        "uTools：强大的插件化多功能输入框，支持多种文件和内容处理。",
        "Motrix：基于Aria2的下载工具，支持BT和磁力链任务，界面简洁。",
        "SwitchHosts：Hosts文件管理工具，支持语法高亮和快速切换。",
        "QtScrcpy：通过USB或TCP/IP连接Android设备，支持多设备同时连接和控制。",
        "PicGo：图床工具，支持多种云存储服务，提供便捷的图片上传和链接获取功能。"
      ],
      "keywords": [
        "uTools",
        "Motrix",
        "SwitchHosts",
        "QtScrcpy",
        "PicGo"
      ],
      "techStack": [
        "插件系统",
        "Aria2",
        "USB",
        "TCP/IP",
        "云存储"
      ],
      "difficulty": "入门",
      "contentType": "工具"
    },
    "/software/mac.md": {
      "summary": "本文档介绍了Mac平台上的一些常用工具和软件，包括Homebrew包管理器、iTerm2终端、Alfred效率神器、Mac微信功能拓展、IINA视频播放器和eZip压缩软件，旨在提升用户在Mac平台上的使用体验。",
      "keyPoints": [
        "Homebrew是Mac上安装命令行程序的便捷工具，支持镜像切换。",
        "iTerm2是Mac上优秀的终端，具有子窗口、自动补全等功能。",
        "Alfred是Mac上的效率神器，支持文件定位、网址打开、自定义搜索等。",
        "Mac微信功能拓展提供了防撤回、免认证登录等实用功能。",
        "IINA是一款简洁美观的视频播放器，支持多种功能如在线字幕、画中画等。",
        "eZip是专为Mac设计的压缩软件，界面美观，支持多种压缩格式和批量加密。"
      ],
      "keywords": [
        "Homebrew",
        "iTerm2",
        "Alfred",
        "Mac微信",
        "IINA",
        "eZip"
      ],
      "techStack": [
        "MacOS"
      ],
      "difficulty": "入门",
      "contentType": "工具"
    },
    "/software/vscode.md": {
      "summary": "该文档介绍了Visual Studio Code（VS Code）的扩展，包括主题相关扩展和针对React、Vue框架的扩展，旨在提升开发效率和代码体验。",
      "keyPoints": [
        "提供多种主题扩展，如One Dark Pro、Shades of Purple等，以改善代码编辑的视觉体验。",
        "包含React和Vue框架的代码片段插件，如ES7 React/Redux/GraphQL/React-Native snippets和Vue 2 Snippets，提高开发效率。",
        "支持文件图标美化、自定义背景等实用功能，增强编辑环境个性化。"
      ],
      "keywords": [
        "Visual Studio Code",
        "扩展",
        "主题",
        "React",
        "Vue",
        "代码片段"
      ],
      "techStack": [
        "Visual Studio Code",
        "React",
        "Vue"
      ],
      "difficulty": "入门",
      "contentType": "工具"
    },
    "/software/webstorm.md": {
      "summary": "本文档介绍了如何为WebStorm编辑器获取许可证、进行汉化配置以及美化编辑器界面。提供了多种汉化方案和美化主题的安装方法。",
      "keyPoints": [
        "提供免费开源许可证申请方式",
        "详细描述了WebStorm汉化步骤和版本匹配方法",
        "介绍了编辑器美化插件及其安装方法"
      ],
      "keywords": [
        "WebStorm",
        "汉化",
        "许可证",
        "美化",
        "插件"
      ],
      "techStack": [
        "WebStorm"
      ],
      "difficulty": "入门",
      "contentType": "工具 + 实践"
    },
    "/software/windows.md": {
      "summary": "本技术文档介绍了五款在Windows平台上广受欢迎的工具，包括便携的终端Cmder、快速的文件搜索软件Everything、高效的启动器Wox、强大的视频播放器PotPlayer以及功能全面的压缩解压工具bandizip，以及音量管理工具EarTrumpet，旨在提高用户的工作效率和体验。",
      "keyPoints": [
        "Cmder：便携式终端，支持子窗口和自定义配置。",
        "Everything：快速文件搜索工具，支持整词、路径匹配和正则表达式搜索。",
        "Wox：启动器，支持程序搜索、书签搜索、快速全局搜索和插件扩展。",
        "PotPlayer：视频播放器，界面简洁，功能强大，支持多种视频音频格式。",
        "bandizip：压缩解压工具，界面简洁，支持乱码处理和完整性检查。",
        "EarTrumpet：音量管理工具，基于UWP，支持多种模式和快捷键设置。"
      ],
      "keywords": [
        "Cmder",
        "Everything",
        "Wox",
        "PotPlayer",
        "bandizip",
        "EarTrumpet"
      ],
      "techStack": [
        "Windows",
        "UWP"
      ],
      "difficulty": "入门",
      "contentType": "工具"
    },
    "/software/zsh.md": {
      "summary": "oh-my-zsh 是一个用于自定义 zsh 配置的工具，支持主题配置和插件安装。文档中介绍了多个插件，如 autojump、z、fast-syntax-highlighting 和 zsh-autosuggestions，以及一个流行的主题 powerlevel10k。这些工具和主题旨在提高 zsh 的用户体验，包括目录跳转、语法高亮和自动命令建议。",
      "keyPoints": [
        "oh-my-zsh 用于自定义 zsh 配置",
        "支持主题配置和插件安装",
        "插件包括 autojump、z、fast-syntax-highlighting 和 zsh-autosuggestions",
        "powerlevel10k 主题提供丰富的配置选项和扩展性",
        "文档提供了插件的安装代码示例和 GitHub 链接"
      ],
      "keywords": [
        "oh-my-zsh",
        "zsh",
        "plugins",
        "themes",
        "autojump",
        "powerlevel10k"
      ],
      "techStack": [
        "zsh",
        "bash"
      ],
      "difficulty": "进阶",
      "contentType": "工具 + 实践"
    },
    "/theory/interview-question/2025-04-28-analysis.md": {
      "summary": "这份技术文档主要针对面试中的笔试和面试高频考点进行预测和准备，涵盖了框架原理、工程化实战、性能优化方案设计、算法题以及技术面试中的框架深度追问和工程化实践等内容。",
      "keyPoints": [
        "笔试重点预测包括框架原理题、工程化实战题、性能优化方案设计以及算法题",
        "性能优化方案设计需考虑数据加载策略、渲染优化手段、内存管理技巧等",
        "技术面试高频考点包括框架深度追问和工程化实践，如Vue3响应式原理、Quasar定制能力、微前端沙箱机制等",
        "低代码平台设计需基于JSON Schema驱动方案，实现配置化表单和组件渲染"
      ],
      "keywords": [
        "框架原理",
        "性能优化",
        "算法题",
        "Vue3",
        "React",
        "低代码平台"
      ],
      "techStack": [
        "Vue.js",
        "React",
        "JavaScript",
        "JSON Schema",
        "Formily"
      ],
      "difficulty": "进阶",
      "contentType": "面试准备 + 框架原理 + 工程化实践"
    },
    "/theory/interview-question/2025-04-28.md": {
      "summary": "这份技术文档包含了一系列关于JavaScript编程问题的面试题，涵盖了变量作用域、闭包、异步编程、Promise、以及操作符等概念。文档通过代码示例和解析，帮助读者理解JavaScript的执行机制和编程技巧。",
      "keyPoints": [
        "变量作用域和闭包的影响",
        "异步编程和Promise的使用",
        "操作符的隐式类型转换和逻辑运算",
        "JavaScript事件循环和任务队列",
        "Promise链式调用的实现"
      ],
      "keywords": [
        "JavaScript",
        "作用域",
        "闭包",
        "异步",
        "Promise",
        "操作符"
      ],
      "techStack": [
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/theory/job-description-lib/01-大疆用户中心重构-面试技术大纲.md": {
      "summary": "大疆用户中心重构项目采用Vue3、TypeScript、Vite和Pinia技术栈，重点在于性能优化和HTTP原理。文档详细介绍了性能优化的指标体系、定位方法和优化策略，包括骨架屏预渲染、代码体积优化、加载与渲染优化、传输层优化和图片优化。此外，还探讨了HTTP协议的版本差异、TLS和缓存体系，以及Webpack构建流程和优化。",
      "keyPoints": [
        "性能优化指标体系包括LCP、FCP、TTI等",
        "采用骨架屏预渲染、代码体积优化等策略提升性能",
        "深入理解HTTP/1.1、HTTP/2、HTTP/3协议差异和TLS机制",
        "Webpack构建流程和优化策略是工程化面试常考内容"
      ],
      "keywords": [
        "Vue3",
        "TypeScript",
        "性能优化",
        "HTTP",
        "Webpack"
      ],
      "techStack": [
        "Vue3",
        "TypeScript",
        "Vite",
        "Pinia",
        "Webpack"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/theory/job-description-lib/02-大疆售后RMS系统重构-面试技术大纲.md": {
      "summary": "大疆售后 RMS 系统重构项目使用 React 18 和 TypeScript，重点在于多人协作工程化治理，包括 ESLint 规范、中后台可维护性与模块化。项目采用 Umi 落地方式，实施严格的代码规范和流程约束，以提高开发效率和代码质量。",
      "keyPoints": [
        "采用 React 18 和 TypeScript 进行系统重构",
        "实施 ESLint 规范以统一代码风格和质量",
        "使用 Umi 作为项目落地框架，实现配置策略和流程约束",
        "通过 husky、lint-staged 和 commitlint 实现代码审查和门禁机制",
        "关注中后台可维护性和模块化设计"
      ],
      "keywords": [
        "React 18",
        "TypeScript",
        "ESLint",
        "Umi",
        "多人协作"
      ],
      "techStack": [
        "React 18",
        "TypeScript",
        "Webpack",
        "Ant Design",
        "Umi",
        "ESLint",
        "husky",
        "lint-staged",
        "commitlint"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/theory/job-description-lib/03-跨平台公告插件系统-面试技术大纲.md": {
      "summary": "该技术文档详细介绍了跨平台公告插件系统的技术架构和实现细节，包括构建工具的横向对比、Preact选型、热插拔和多路复用等关键特性。文档强调了Rollup的tree-shaking能力、Preact的信号机制、热插拔的生命周期设计以及多路复用的复用层级。",
      "keyPoints": [
        "构建工具Rollup、Webpack、Vite的横向对比，侧重于产物格式、tree-shaking、code-splitting等维度",
        "Preact选型原因分析，包括体积、兼容层、信号机制等",
        "热插拔架构设计，包括生命周期、隔离策略、灰度与回滚机制",
        "多路复用技术实现，包括复用层级和植入模式的选择"
      ],
      "keywords": [
        "Rollup",
        "Webpack",
        "Vite",
        "Preact",
        "Tree Shaking",
        "热插拔",
        "多路复用"
      ],
      "techStack": [
        "Rollup",
        "Webpack",
        "Vite",
        "Preact",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/theory/job-description-lib/04-大疆DevOps平台维护-面试技术大纲.md": {
      "summary": "本技术文档详细介绍了大疆DevOps平台在2024年3月至2025年4月期间的维护工作，重点涵盖CI/CD流水线原理、Docker部署、微前端选型与qiankun微前端的原理。文档深入探讨了流水线的基础链路、Docker镜像原理、发布策略、质量与安全措施，以及微前端的选型维度、核心原理和与其他方案的对比。",
      "keyPoints": [
        "CI/CD流水线的基础链路和阶段",
        "Docker镜像原理和发布策略",
        "微前端选型维度和qiankun的核心原理",
        "质量与安全措施，包括门禁和代码扫描",
        "与其他微前端方案的对比分析"
      ],
      "keywords": [
        "CI/CD",
        "Docker",
        "微前端",
        "qiankun",
        "DevOps"
      ],
      "techStack": [
        "Vue3",
        "TypeScript",
        "Docker",
        "qiankun"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/theory/job-description-lib/05-XDR系统-魔方大屏+报表-面试技术大纲.md": {
      "summary": "本技术大纲介绍了XDR系统的魔方大屏和报表系统的开发原理，重点涵盖低代码大屏的内部架构、数据交互、工程化与稳定性，以及NestJS的SSR原理和报表场景下的SSR价值。",
      "keyPoints": [
        "魔方大屏采用Schema驱动架构，支持物料体系和布局系统，具备编辑器能力。",
        "报表系统利用NestJS的SSR实现首屏加载和SEO优化，支持导出和定时任务。",
        "详细探讨了SSR的渲染流程、Hydration机制、流式SSR的优缺点以及缓存策略。",
        "分析了NestJS与Next.js/Remix在SSR实现上的差异，以及稳定性与降级策略。"
      ],
      "keywords": [
        "XDR系统",
        "魔方大屏",
        "低代码",
        "NestJS",
        "SSR",
        "报表系统",
        "ECharts",
        "mongoose"
      ],
      "techStack": [
        "React",
        "ECharts",
        "NestJS",
        "mongoose"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/theory/job-description-lib/06-大疆用户中心重构-hard-mode-面试题.md": {
      "summary": "本技术文档讨论了大疆用户中心的重构，重点在于使用Vue3、TypeScript、Vite和Pinia等技术实现PC/移动端融合，并优化性能指标，如LCP。文档详细分析了架构取舍、性能指标定位、优化策略等关键问题。",
      "keyPoints": [
        "PC/移动端融合代码维护成本降低50%的量化方法",
        "一套代码多端适配的可复用边界定义及避免过度复用",
        "媒体查询、容器查询、组件响应式方案的比较与选择",
        "移动端适配中处理DPR、1px、字体缩放与第三方组件冲突的方法",
        "同一路由服务PC/移动端时，如何表达不同布局/模块组合",
        "LCP性能指标优化的验证方法及瓶颈分析"
      ],
      "keywords": [
        "Vue3",
        "TypeScript",
        "Vite",
        "Pinia",
        "PC/移动端融合",
        "性能优化",
        "LCP"
      ],
      "techStack": [
        "Vue3",
        "TypeScript",
        "Vite",
        "Pinia",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "实践 + 原理"
    },
    "/theory/job-description-lib/07-大疆售后RMS系统重构-Hard-Mode-面试题.md": {
      "summary": "本技术文档讨论了大疆售后RMS系统重构的Hard-Mode面试题，涉及大型项目协作、代码质量、低代码平台架构、可扩展性以及性能与稳定性等方面。文档深入探讨了如何提升协作效率、设计规则治理、实现低代码平台、保证系统性能和稳定性等问题。",
      "keyPoints": [
        "如何实现100+页面的多人协作并保证代码质量",
        "低代码平台的架构设计与可扩展性，以及如何避免统计偏差",
        "性能与稳定性指标的定义及实现方法"
      ],
      "keywords": [
        "大疆售后RMS",
        "协作治理",
        "低代码平台",
        "性能稳定性",
        "代码质量"
      ],
      "techStack": [
        "低代码平台",
        "前端架构",
        "性能优化"
      ],
      "difficulty": "高级",
      "contentType": "面试题 + 原理 + 实践"
    },
    "/theory/job-description-lib/08-跨平台公告插件系统-Hard-Mode-面试题.md": {
      "summary": "该文档探讨了如何构建一个跨平台的公告插件系统，重点在于实现小于15KB的极致体积，并涉及Rollup打包、Tree Shaking、Preact signals、热插拔等高级技术。文档详细讨论了体积控制、响应式更新机制、插件生命周期设计等关键问题。",
      "keyPoints": [
        "实现小于15KB的公告插件体积，通过Rollup和Tree Shaking技术",
        "使用Preact signals实现响应式更新，优化更新粒度",
        "设计热插拔架构，确保插件的生命周期管理和资源回收",
        "处理依赖链和sideEffects声明，确保功能完整性和可维护性"
      ],
      "keywords": [
        "Rollup",
        "Tree Shaking",
        "Preact signals",
        "热插拔",
        "插件系统"
      ],
      "techStack": [
        "Rollup",
        "Preact",
        "JavaScript"
      ],
      "difficulty": "高级",
      "contentType": "原理 + 实践"
    },
    "/theory/job-description-lib/09-DevOps平台-qiankun微前端-Hard-Mode-面试题.md": {
      "summary": "本文档深入探讨了 DevOps 平台中的 qiankun 微前端框架，涵盖了其原理、沙箱隔离、样式隔离、通信机制、独立部署与版本治理，以及性能与稳定性治理等多个方面。文档通过对比 iframe 和 module federation，详细解析了 qiankun 的核心能力、生命周期管理、沙箱机制、JS/CSS/资源隔离策略、通信方式、独立部署策略、版本兼容性以及性能优化等关键问题。",
      "keyPoints": [
        "qiankun 微前端框架的核心能力及其与 iframe 和 module federation 的对比",
        "子应用的加载、挂载、卸载生命周期管理及沙箱机制",
        "JS/CSS/资源隔离策略，包括 Proxy 沙箱、CSS 隔离方法及资源重复加载处理",
        "应用间通信机制及避免全局污染的策略",
        "独立部署与版本兼容性管理，包括发布策略和接口契约管理",
        "微前端性能问题及优化策略"
      ],
      "keywords": [
        "qiankun",
        "微前端",
        "沙箱隔离",
        "样式隔离",
        "通信",
        "独立部署",
        "版本治理",
        "性能优化"
      ],
      "techStack": [
        "JavaScript",
        "React",
        "TypeScript",
        "Node.js"
      ],
      "difficulty": "高级",
      "contentType": "原理 + 实践"
    },
    "/theory/job-description-lib/10-XDR系统-NestJS全栈-Hard-Mode-面试题.md": {
      "summary": "本面试题针对使用 NestJS 构建的 XDR 系统，涉及 NestJS 架构设计、MongoDB 数据建模、定时任务可靠性、报表导出链路以及实时大屏性能等多个方面，旨在考察应聘者对全栈开发的深入理解和实践经验。",
      "keyPoints": [
        "NestJS 架构设计与依赖注入（DI）的应用",
        "MongoDB/Mongoose 数据建模与性能优化",
        "定时任务（cron）的可靠性和可观测性",
        "报表导出链路的设计与异步处理",
        "模板引擎的选择与维护"
      ],
      "keywords": [
        "NestJS",
        "DI",
        "MongoDB",
        "Mongoose",
        "定时任务",
        "报表导出",
        "性能优化"
      ],
      "techStack": [
        "NestJS",
        "JavaScript",
        "MongoDB",
        "Mongoose",
        "Bull"
      ],
      "difficulty": "高级",
      "contentType": "实践 + 原理"
    },
    "/theory/job-description-lib/11-frontend-hard-mode-interview-原题提取-基于简历.md": {
      "summary": "本文档深入探讨了网络通信原理中的TCP/IP协议集，特别是TCP、UDP和TLS协议。它强调了这些协议对于前端工程师的重要性，特别是在面试和日常工作中。文档详细介绍了TCP/IP协议集的结构，包括应用层、传输层、网络层和网络访问层，以及每个层中包含的协议，如HTTP、TFTP、Telnet、SNMP和DNS。传输层特别提到了TLS（传输层安全），它是SSL的标准化版本。",
      "keyPoints": [
        "TCP/IP协议集是网络通信的基础，包括TCP、UDP和TLS等协议。",
        "TCP/IP协议集分为应用层、传输层、网络层和网络访问层。",
        "应用层协议如HTTP、TFTP、Telnet、SNMP和DNS等。",
        "传输层包括TLS（传输层安全），它是SSL的标准化版本。",
        "了解这些协议对于前端工程师的日常工作和面试非常重要。"
      ],
      "keywords": [
        "TCP/IP",
        "TCP",
        "UDP",
        "TLS",
        "网络通信"
      ],
      "techStack": [
        "网络协议"
      ],
      "difficulty": "进阶",
      "contentType": "原理"
    },
    "/theory/job-description-lib/Framework copy.md": {
      "summary": "本技术文档深入探讨了React 16+版本的核心原理和区别，包括Fiber架构、Hooks、渲染机制、Diff算法、Hooks原理与常见问题，以及工程落地时的性能优化、可靠性保障和调试技巧。",
      "keyPoints": [
        "React 16+版本演进主线及差异分析",
        "渲染机制，包括render phase、commit phase、Scheduler调度和更新入队",
        "Diff算法的核心规则和key的作用",
        "Hooks原理、常见问题和最佳实践",
        "工程落地时的性能优化、可靠性保障和调试技巧"
      ],
      "keywords": [
        "React",
        "Fiber",
        "Hooks",
        "渲染机制",
        "Diff算法"
      ],
      "techStack": [
        "React"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/theory/job-description-lib/Framework.md": {
      "summary": "本技术文档深入探讨了React 16+版本的核心原理和区别，包括Fiber架构、Hooks、渲染机制、Diff算法、Hooks原理与常见问题，以及工程落地时的性能优化、可靠性保障和调试技巧。",
      "keyPoints": [
        "React 16+版本演进主线及差异分析",
        "渲染机制，包括render phase、commit phase、Scheduler调度和更新入队",
        "Diff算法的核心规则和key的作用",
        "Hooks原理及常见问题，如依赖调用顺序、闭包陷阱和StrictMode下的effect重复执行",
        "工程落地时的性能优化、可靠性保障和调试技巧"
      ],
      "keywords": [
        "React",
        "Fiber",
        "Hooks",
        "渲染机制",
        "Diff算法"
      ],
      "techStack": [
        "React"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/utils/function.md": {
      "summary": "该技术文档提供了三个常用方法的描述，包括提取身份证信息、环境判断和微信API的Promise化处理，旨在简化数据处理和API调用。",
      "keyPoints": [
        "提取身份证信息：根据身份证号码解析年龄、出生日期和性别。",
        "环境判断：通过代码示例展示如何判断运行环境。",
        "微信API Promise化：将微信API调用转换为Promise形式，便于异步处理。"
      ],
      "keywords": [
        "身份证信息提取",
        "环境判断",
        "微信API",
        "Promise化"
      ],
      "techStack": [
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "工具 + 实践"
    },
    "/utils/library.md": {
      "summary": "本文档收集了个人使用过或遇到的多种JavaScript类库，涵盖了工具库、时间处理、请求处理、精度处理、本地存储、滚动处理和事件处理等多个方面，旨在提供高效、便捷的编程解决方案。",
      "keyPoints": [
        "提供了多种JavaScript库的链接和简要描述",
        "涵盖了从工具库到本地存储等多个编程领域",
        "强调了库的特性和应用场景，如lodash的实用工具、moment的时间处理等",
        "推荐了适用于不同需求的库，如axios用于HTTP请求、localForage用于本地存储"
      ],
      "keywords": [
        "JavaScript",
        "库",
        "工具库",
        "时间处理",
        "请求处理"
      ],
      "techStack": [
        "JavaScript"
      ],
      "difficulty": "入门",
      "contentType": "工具"
    },
    "/utils/regexp.md": {
      "summary": "本技术文档提供了关于正则表达式的使用，包括验证金额、手机号、邮箱号、QQ号、链接地址和身份证号码，以及如何格式化手机号等格式相关的内容。",
      "keyPoints": [
        "使用正则表达式验证各种类型的数据格式",
        "提供具体代码示例展示如何实现正则表达式验证",
        "涵盖金额、手机号、邮箱号、QQ号、链接地址和身份证号码的验证",
        "展示如何格式化手机号，包括从左到右和从右到左两种格式",
        "包含隐藏手机号中间四位的功能"
      ],
      "keywords": [
        "正则表达式",
        "验证",
        "格式化",
        "手机号",
        "身份证号码"
      ],
      "techStack": [
        "正则表达式"
      ],
      "difficulty": "进阶",
      "contentType": "实践"
    },
    "/vue/code/Object.defineproperty.md": {
      "summary": "内容太短，暂无摘要",
      "keyPoints": [],
      "keywords": [],
      "techStack": [],
      "difficulty": "未分级",
      "contentType": "综合"
    },
    "/vue/code/Proxy.md": {
      "summary": "内容太短，暂无摘要",
      "keyPoints": [],
      "keywords": [],
      "techStack": [],
      "difficulty": "未分级",
      "contentType": "综合"
    },
    "/vue/code/proxy-observe.md": {
      "summary": "内容太短，暂无摘要",
      "keyPoints": [],
      "keywords": [],
      "techStack": [],
      "difficulty": "未分级",
      "contentType": "综合"
    },
    "/vue/vue-render.md": {
      "summary": "本文深入解析了 Vue 3 的渲染流程，从模板编译到真实 DOM 的生成，包括响应式、编译、虚拟 DOM 和 patch 等核心环节，适用于使用 Vue 3 开发者，基于 `vue@3.4+` 版本。",
      "keyPoints": [
        "Vue 3 的渲染流程分为初次渲染和更新渲染两个阶段。",
        "模板通过编译生成 render 函数，然后执行 render 函数生成 VNode。",
        "Vue 3 使用响应式系统来收集依赖并在数据变化时进行精准更新。",
        "Vue 3 的编译时优化如静态节点提升和事件缓存，提高了运行时的效率。",
        "本文基于 Vue 3.4+ 版本，适用于熟悉 Vue 3 Composition API 的开发者。"
      ],
      "keywords": [
        "Vue 3",
        "渲染流程",
        "响应式",
        "编译",
        "虚拟 DOM",
        "patch"
      ],
      "techStack": [
        "Vue 3",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/vue/vue2.md": {
      "summary": "本技术文档深入探讨了 Vue.js 的核心原理，包括组件化、响应式系统、虚拟 DOM、模板编译、渲染过程、前端路由以及面试真题演练等。文档涵盖了 Vue 的架构设计、API 使用、生命周期、组件通信和性能优化等多个方面。",
      "keyPoints": [
        "组件化架构，实现数据驱动视图和MVVM模式",
        "响应式系统使用Object.defineProperty（Vue 3中使用Proxy）进行数据劫持，监听对象和数组的变化",
        "虚拟DOM和diff算法优化DOM操作，提高渲染效率",
        "模板编译过程，将模板转换为render函数，生成虚拟DOM",
        "渲染过程包括初次渲染和更新过程，支持异步渲染",
        "前端路由实现，包括hash和h5 history模式",
        "Vue面试真题演练，包括v-show与v-if的区别、v-for中的key使用、组件生命周期、组件通信、双向数据绑定v-model的实现原理等"
      ],
      "keywords": [
        "Vue.js",
        "组件化",
        "响应式",
        "虚拟DOM",
        "模板编译",
        "渲染过程",
        "前端路由"
      ],
      "techStack": [
        "Vue.js",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/vue/vue3.md": {
      "summary": "内容太短，暂无摘要",
      "keyPoints": [],
      "keywords": [],
      "techStack": [],
      "difficulty": "未分级",
      "contentType": "综合"
    },
    "/vue/vue_interview.md": {
      "summary": "这份文档提供了一系列关于 Vue.js 框架的面试题，主要围绕 Vue 组件的通讯机制和渲染更新过程。文档中虽然具体内容被省略为‘啥啥啥’，但可以推断出它旨在帮助面试者理解 Vue 组件的基本概念和实现细节。",
      "keyPoints": [
        "Vue 组件通讯机制",
        "组件渲染和更新过程",
        "Vue 组件通讯的面试题"
      ],
      "keywords": [
        "Vue.js",
        "组件通讯",
        "渲染过程",
        "面试题"
      ],
      "techStack": [
        "Vue.js"
      ],
      "difficulty": "进阶",
      "contentType": "概念 + 面试题"
    },
    "/vue/vue_theory.md": {
      "summary": "本文档介绍了 Vue.js 的核心原理，包括组件化、MVVM 模型、MVC 模型、数据驱动视图以及响应式系统。它解释了如何通过数据绑定和发布订阅模式实现数据和视图的双向同步，以及如何监听对象和数组的变化。",
      "keyPoints": [
        "Vue.js 使用 MVVM 模型实现组件化，其中 ViewModel 作为 View 和 Model 的桥梁。",
        "数据驱动视图是 Vue.js 的一个关键特性，它允许开发者通过操作数据来直接更新视图，而不需要直接操作 DOM。",
        "Vue.js 的响应式系统利用 Object.defineProperty 来监听数据的变化，实现数据的双向绑定。"
      ],
      "keywords": [
        "Vue.js",
        "MVVM",
        "MVC",
        "数据绑定",
        "响应式系统"
      ],
      "techStack": [
        "Vue.js",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理"
    },
    "/webpack/install/ni.md": {
      "summary": "本文档探讨了不同版本的包管理工具（如npm、yarn、pnpm、ni）的安装机制及其存在的问题，包括嵌套安装、扁平安装、npm分身和幽灵依赖等，并提供了相应的代码示例。",
      "keyPoints": [
        "比较了不同包管理工具的安装机制和存在的问题",
        "分析了嵌套安装、扁平安装、npm分身和幽灵依赖等问题的具体表现和影响",
        "通过代码示例展示了不同工具的安装过程"
      ],
      "keywords": [
        "npm",
        "yarn",
        "pnpm",
        "ni",
        "包管理",
        "安装机制",
        "依赖问题"
      ],
      "techStack": [
        "npm",
        "yarn",
        "pnpm",
        "ni"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/webpack/install/npm.md": {
      "summary": "本文档介绍了早期npm版本的设计及其依赖管理问题，如依赖树的复杂性导致的嵌套地狱、资源浪费、安装时间过长等问题，并探讨了在实际开发中可能遇到的相关问题，如依赖包管理、版本一致性等。",
      "keyPoints": [
        "早期npm版本依赖管理简单，但可能导致依赖树复杂，形成嵌套地狱。",
        "嵌套地狱可能导致资源浪费、安装时间过长和文件路径过长问题。",
        "实际开发中，依赖包管理、版本一致性等问题需要特别注意。",
        "npm install执行后，会检查和获取npm配置，并保持版本一致性。",
        "lockfiles文件是否提交到仓库中需要根据具体情况决定。"
      ],
      "keywords": [
        "npm",
        "依赖管理",
        "嵌套地狱",
        "资源浪费",
        "版本一致性"
      ],
      "techStack": [
        "npm"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/webpack/install/pnpm.md": {
      "summary": "文档讨论了传统的Node.js项目中`node_modules`目录的问题，包括其低效的生成过程、I/O密集型操作、缺乏包的概念导致的问题，以及运行时的高成本。文档提出了Yarn作为解决方案，它能够更有效地管理依赖树，并避免Node直接查找包的位置。",
      "keyPoints": [
        "传统的`node_modules`目录生成过程低效且I/O密集。",
        "Node.js缺乏对包的概念理解，可能导致运行时错误。",
        "Yarn能够更有效地管理依赖树，避免Node直接查找包。",
        "Yarn在安装依赖时更智能，减少了不必要的文件操作。",
        "Yarn优化了依赖树的布局，减少了磁盘和内存的使用。"
      ],
      "keywords": [
        "node_modules",
        "Yarn",
        "dependency management",
        "I/O",
        "performance"
      ],
      "techStack": [
        "Node.js",
        "Yarn"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 工具"
    },
    "/webpack/install/yarn.md": {
      "summary": "本文档探讨了不同版本的包管理工具（如npm、yarn、pnpm、ni）的安装机制及其存在的问题，包括嵌套安装、扁平安装、npm分身和幽灵依赖等，并提供了相应的代码示例。",
      "keyPoints": [
        "不同包管理工具的安装机制和升级变化",
        "嵌套安装和扁平安装的问题及影响",
        "npm分身和幽灵依赖的概念及解决方法",
        "代码示例展示了不同工具的安装过程"
      ],
      "keywords": [
        "npm",
        "yarn",
        "pnpm",
        "ni",
        "包管理",
        "安装机制",
        "依赖问题"
      ],
      "techStack": [
        "npm",
        "yarn",
        "pnpm",
        "ni"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/webpack/vite-架构及原理.md": {
      "summary": "Vite 是一种新型前端构建工具，它通过不打包开发时的应用，利用现代浏览器的原生 ES 模块支持，提供快速的开发服务器启动和高效的模块热替换。Vite 的架构由开发服务器和生产构建器组成，使用 Koa、ESM、esbuild 和 Rollup 等技术，旨在解决传统构建工具在开发阶段的性能问题。",
      "keyPoints": [
        "Vite 利用原生 ES 模块支持，实现开发时不打包，生产时再打包的理念",
        "Vite 的开发服务器使用 Koa 和 esbuild，提供快速启动和高效的 HMR",
        "Vite 的生产构建器基于 Rollup，支持 Tree-shaking、代码分割和压缩"
      ],
      "keywords": [
        "Vite",
        "ESM",
        "esbuild",
        "Koa",
        "Rollup",
        "HMR"
      ],
      "techStack": [
        "Koa",
        "ESM",
        "esbuild",
        "Rollup",
        "TypeScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 工具"
    },
    "/webpack/vite-知识梳理.md": {
      "summary": "Vite 是由 Vue 作者尤雨溪开发的新一代前端构建工具，以其快速的开发阶段性能和框架无关性著称。它基于原生 ES 模块提供按需加载，使用 Rollup 进行生产构建，并原生支持多种前端框架。Vite 的核心原理包括利用浏览器原生模块支持和 Rollup 的打包能力，同时提供开箱即用的配置选项。",
      "keyPoints": [
        "Vite 是新一代前端构建工具，基于原生 ES 模块提供快速的开发体验。",
        "Vite 使用 Rollup 进行生产构建，支持多种前端框架。",
        "Vite 提供开箱即用的配置，无需额外配置即可支持 TypeScript、JSX、CSS 预处理器等。",
        "Vite 的开发服务器利用浏览器原生模块支持，实现快速热更新。",
        "Vite 的配置项通过 `vite.config.ts` 文件进行管理。"
      ],
      "keywords": [
        "Vite",
        "前端构建工具",
        "Rollup",
        "ES 模块",
        "热更新"
      ],
      "techStack": [
        "Vue",
        "Rollup",
        "ES 模块",
        "TypeScript",
        "JSX"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 工具"
    },
    "/webpack/webpack-vite-rollup.md": {
      "summary": "本文对Webpack、Vite和Rollup三种构建工具进行了深度分析，对比了它们的定位、架构原理、优缺点以及适用场景。Webpack是一个全能的模块打包器，Rollup专注于JavaScript库的打包，而Vite则提供极致的开发体验和构建优化。",
      "keyPoints": [
        "Webpack是一个通用模块打包器，支持复杂定制。",
        "Rollup专注于JavaScript库的打包，输出更小、更干净的代码。",
        "Vite提供快速的开发体验和稳定的构建过程，适合现代前端应用。",
        "Webpack、Rollup和Vite各有优缺点，适用于不同的项目需求。",
        "选择合适的构建工具对于提高开发效率和项目质量至关重要。"
      ],
      "keywords": [
        "Webpack",
        "Vite",
        "Rollup",
        "构建工具",
        "前端工程化"
      ],
      "techStack": [
        "Webpack",
        "Vite",
        "Rollup"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/webpack/打包工具.md": {
      "summary": "本文档探讨了不同版本包管理工具（如npm、yarn、pnpm、ni）的安装机制及其存在的问题，包括嵌套安装、扁平安装、npm分身和幽灵依赖等，并提供了相应的代码示例。",
      "keyPoints": [
        "不同包管理工具的安装机制和问题分析",
        "嵌套安装和扁平安装的优缺点",
        "npm分身和幽灵依赖的概念及影响",
        "代码示例展示不同工具的安装方式"
      ],
      "keywords": [
        "npm",
        "yarn",
        "pnpm",
        "ni",
        "包管理工具",
        "安装机制",
        "依赖问题"
      ],
      "techStack": [
        "npm",
        "yarn",
        "pnpm",
        "ni"
      ],
      "difficulty": "进阶",
      "contentType": "原理 + 实践"
    },
    "/webpack/架构及原理.md": {
      "summary": "Webpack 是一个基于插件和加载器的模块打包系统，它通过入口文件构建依赖图，并通过输出配置将打包后的文件存放到指定位置。Webpack 的核心架构包括入口、输出、模块、插件、加载器和依赖图。本文深入探讨了 Webpack 的内部结构和工作原理，包括初始化、编译和加载过程。",
      "keyPoints": [
        "Webpack 是一个模块打包系统，基于插件和加载器。",
        "Webpack 构建过程从入口文件开始，生成依赖图。",
        "Webpack 使用配置文件来定义入口、输出、加载器和插件。",
        "Webpack 插件和加载器扩展其功能，处理不同类型的文件。",
        "Webpack 的核心组件包括 Compiler 和 Compilation，负责管理构建过程。"
      ],
      "keywords": [
        "Webpack",
        "模块打包",
        "插件",
        "加载器",
        "依赖图"
      ],
      "techStack": [
        "Webpack",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "原理"
    },
    "/webpack/知识梳理.md": {
      "summary": "Webpack 是一个现代前端开发中的模块打包器，用于将代码和资源打包成优化后的文件，支持模块化开发，并可通过插件和加载器进行扩展。本文介绍了Webpack的基本概念、核心概念、配置文件等知识。",
      "keyPoints": [
        "Webpack 是一个模块打包器，用于打包 JavaScript、CSS、图片等资源。",
        "Webpack 支持模块化开发，并可以通过插件和加载器扩展功能。",
        "Webpack 的配置文件（webpack.config.js）定义了入口、输出和模块等配置。",
        "Webpack 构建过程中会生成依赖图，用于优化文件打包。",
        "Webpack 提供了丰富的插件和加载器，可以处理各种类型的资源文件。"
      ],
      "keywords": [
        "Webpack",
        "模块打包",
        "插件",
        "加载器",
        "配置文件"
      ],
      "techStack": [
        "Webpack",
        "JavaScript"
      ],
      "difficulty": "进阶",
      "contentType": "概念 + 实践"
    }
  }
}