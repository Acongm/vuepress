"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[2336],{8233:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-4522a2d4",path:"/mack/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html",title:"React 16+ 各版本区别 & React 核心原理",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"笔试题（6 题）",slug:"笔试题-6-题",children:[{level:3,title:"1. React 16/17/18 版本核心特性对比",slug:"_1-react-16-17-18-版本核心特性对比",children:[]},{level:3,title:"2. Fiber 架构详解",slug:"_2-fiber-架构详解",children:[]},{level:3,title:"3. React 更新流程",slug:"_3-react-更新流程",children:[]},{level:3,title:"4. 协调（Reconciliation）与 Key",slug:"_4-协调-reconciliation-与-key",children:[]},{level:3,title:"5. 并发（Concurrent）vs 并行（Parallel）",slug:"_5-并发-concurrent-vs-并行-parallel",children:[]},{level:3,title:"6. React 18 Automatic Batching",slug:"_6-react-18-automatic-batching",children:[]}]},{level:2,title:"面试题（4 题）",slug:"面试题-4-题",children:[{level:3,title:"1. Fiber 架构的可中断性",slug:"_1-fiber-架构的可中断性",children:[]},{level:3,title:"2. Render 阶段 vs Commit 阶段",slug:"_2-render-阶段-vs-commit-阶段",children:[]}]}],git:{updatedTime:1767447745e3},filePathRelative:"mack/01-React核心原理.md"}},7827:(n,s,a)=>{a.r(s),a.d(s,{default:()=>t});const p=(0,a(6252).uE)('<h1 id="react-16-各版本区别-react-核心原理" tabindex="-1"><a class="header-anchor" href="#react-16-各版本区别-react-核心原理" aria-hidden="true">#</a> React 16+ 各版本区别 &amp; React 核心原理</h1><h2 id="笔试题-6-题" tabindex="-1"><a class="header-anchor" href="#笔试题-6-题" aria-hidden="true">#</a> 笔试题（6 题）</h2><h3 id="_1-react-16-17-18-版本核心特性对比" tabindex="-1"><a class="header-anchor" href="#_1-react-16-17-18-版本核心特性对比" aria-hidden="true">#</a> 1. React 16/17/18 版本核心特性对比</h3><p>请写出 React 16、17、18 三个版本在&quot;渲染/更新&quot;层面的关键变化点，每个版本至少 3 条。</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>React 16:\n1. Fiber 架构 - 重写了核心调和算法，支持可中断的渲染\n2. 异步渲染基础 - 引入 time slicing，为后续并发特性铺路\n3. Error Boundaries - 新增错误边界机制，componentDidCatch\n4. Fragments - 支持返回数组和 Fragment，无需额外 DOM 包裹\n5. Portals - 支持渲染到父组件 DOM 层级之外\n\nReact 17:\n1. 无新特性版本 - 主要是过渡版本，为 18 做准备\n2. 事件委托改变 - 从 document 改为 root 容器，支持多版本共存\n3. 去除事件池 - 简化事件处理，提升性能\n4. 新的 JSX 转换 - 不再需要 import React，编译优化\n5. useEffect 清理时机 - 改为异步执行，提升性能\n\nReact 18:\n1. 并发渲染（Concurrent Rendering）- 支持渲染可中断和优先级调度\n2. Automatic Batching - 自动批处理扩展到所有场景（setTimeout、Promise、原生事件）\n3. Transitions API - startTransition 区分紧急和非紧急更新\n4. Suspense SSR - 支持流式 SSR 和选择性 Hydration\n5. useId/useTransition/useDeferredValue - 新增并发特性相关 Hooks\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><hr><h3 id="_2-fiber-架构详解" tabindex="-1"><a class="header-anchor" href="#_2-fiber-架构详解" aria-hidden="true">#</a> 2. Fiber 架构详解</h3><p>解释 Fiber 是什么：它解决了什么问题？核心数据结构包含哪些关键字段？Fiber 节点之间如何建立关联？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Fiber 解决的问题：\n1. React 15 及之前采用递归的 Stack Reconciler，一旦开始无法中断\n2. 大组件树更新会长时间占用主线程，导致页面卡顿、掉帧\n3. 无法区分任务优先级，用户交互得不到及时响应\n4. Fiber 通过时间切片（Time Slicing）实现可中断、可恢复的渲染\n5. 支持任务优先级调度，高优先级任务可以打断低优先级任务\n\nFiber 核心数据结构字段：\n// 实例相关\ntype: 组件类型（函数组件/类组件/原生标签）\nstateNode: 对应的真实 DOM 节点或组件实例\nkey/ref: React 元素的 key 和 ref\n\n// 树结构\nreturn: 父 Fiber 节点\nchild: 第一个子 Fiber 节点\nsibling: 下一个兄弟 Fiber 节点\n\n// 状态和副作用\npendingProps: 新的 props\nmemoizedProps: 上次渲染的 props\nmemoizedState: 上次渲染的 state\nupdateQueue: 更新队列\nflags (effectTag): 副作用标记（Placement/Update/Deletion）\n\n// 调度相关\nlanes: 优先级车道模型\nalternate: 指向 workInProgress/current 树的对应节点（双缓冲）\n\nFiber 节点关联方式：\n1. 单链表结构：child（第一个子节点）+ sibling（兄弟节点）+ return（父节点）\n2. 双缓冲机制：current 树和 workInProgress 树通过 alternate 互相指向\n3. 深度优先遍历：先 child，无 child 找 sibling，无 sibling 回到 return\n4. 这种结构支持中断后从断点继续，只需保存当前 Fiber 引用即可\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><hr><h3 id="_3-react-更新流程" tabindex="-1"><a class="header-anchor" href="#_3-react-更新流程" aria-hidden="true">#</a> 3. React 更新流程</h3><p>React 中一次 setState/状态更新，从触发到 DOM 更新完成，大致经历哪些阶段？每个阶段的主要工作是什么？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>阶段1：调度阶段（Schedule）\n- 触发更新：setState/useState/useReducer/forceUpdate\n- 创建 Update 对象，加入 updateQueue\n- 根据优先级（lanes）决定是否立即调度\n- 通过 Scheduler 调度，将任务加入任务队列\n- 主要工作：优先级计算、任务调度、时间切片\n\n阶段2：协调阶段（Render/Reconciliation）- 可中断\n- beginWork：从根节点开始，深度优先遍历 Fiber 树\n- 对比新旧 props/state，标记需要更新的节点\n- 调用组件函数/render 方法，生成新的 ReactElement\n- diff 算法：复用 Fiber 节点，标记 effectTag（Placement/Update/Deletion）\n- completeWork：完成节点处理，创建/更新 DOM 属性\n- 构建 effectList 链表（待提交的副作用列表）\n- 主要工作：Diff 计算、Fiber 树构建、副作用收集\n\n阶段3：提交阶段（Commit）- 不可中断，同步执行\n- before mutation：执行 getSnapshotBeforeUpdate\n- mutation：根据 effectList 执行真实 DOM 操作（增删改）\n- layout：执行 useLayoutEffect/componentDidMount/componentDidUpdate\n- 切换 current 指针，从 workInProgress 树变为新的 current 树\n- 主要工作：DOM 变更、生命周期执行、ref 更新\n\n阶段4：副作用执行（Effect）- 异步\n- 在浏览器完成绘制后异步执行 useEffect\n- 先执行上一次的清理函数（cleanup）\n- 再执行本次的副作用函数\n- 不阻塞浏览器渲染，提升用户体验\n- 主要工作：异步副作用执行、订阅清理\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><hr><h3 id="_4-协调-reconciliation-与-key" tabindex="-1"><a class="header-anchor" href="#_4-协调-reconciliation-与-key" aria-hidden="true">#</a> 4. 协调（Reconciliation）与 Key</h3><p>什么是协调（reconciliation）？key 的作用是什么？错误使用 key（如使用 index）会导致什么问题？请举例说明。</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>协调的定义：\n协调（Reconciliation）是 React 中用于比较新旧虚拟 DOM 树，计算出最小变更集的算法过程。\nReact 通过 Diff 算法找出两棵树之间的差异，决定哪些节点需要新增、更新或删除。\n协调是 Render 阶段的核心工作，目标是高效复用现有节点，最小化 DOM 操作。\nReact 的协调算法复杂度从 O(n³) 优化到 O(n)，基于三个假设：\n1. 不同类型的元素会产生不同的树\n2. 通过 key 属性标识哪些元素在不同渲染中保持稳定\n3. 同层级节点对比，不跨层级移动\n\nkey 的作用：\n1. 唯一标识：帮助 React 识别列表中哪些元素改变、添加或删除\n2. 性能优化：相同 key 的元素会被复用，避免不必要的销毁和重建\n3. 状态保持：有 key 的组件在列表重新排序时能保持自己的状态\n4. Diff 优化：React 通过 key 快速判断节点是移动还是新增/删除\n5. 避免渲染错误：防止组件实例混淆导致的状态错乱\n\n错误使用 key 的问题及示例：\n❌ 使用 index 作为 key 的问题：\n// 错误示例\nitems.map((item, index) =&gt; &lt;TodoItem key={index} {...item} /&gt;)\n\n问题场景：\n1. 列表重新排序时，index 变化导致组件实例错位\n2. 删除中间项时，后面所有项的 index 改变，触发不必要的重渲染\n3. 有内部状态的组件会出现状态错乱\n\n具体案例：\n初始：[{id: &#39;a&#39;, text: &#39;任务A&#39;}, {id: &#39;b&#39;, text: &#39;任务B&#39;}]\n删除第一项后：[{id: &#39;b&#39;, text: &#39;任务B&#39;}]\n\n使用 index 作为 key：\n- 删除前：key=0 对应 &#39;任务A&#39;，key=1 对应 &#39;任务B&#39;\n- 删除后：key=0 对应 &#39;任务B&#39;\n- React 认为 key=0 的组件被更新（而非删除），key=1 的组件被删除\n- 如果组件有内部状态（如输入框内容），会导致状态绑定错误\n\n✅ 正确做法：\nitems.map(item =&gt; &lt;TodoItem key={item.id} {...item} /&gt;)\n使用稳定的唯一标识（如数据库 ID、UUID）作为 key\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><hr><h3 id="_5-并发-concurrent-vs-并行-parallel" tabindex="-1"><a class="header-anchor" href="#_5-并发-concurrent-vs-并行-parallel" aria-hidden="true">#</a> 5. 并发（Concurrent）vs 并行（Parallel）</h3><p>React 18 的并发（Concurrent）与传统意义的&quot;并行&quot;有什么本质区别？React 如何实现并发渲染？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>并发 vs 并行的区别：\n【并行（Parallel）】\n- 定义：多个任务在同一时刻真正同时执行\n- 要求：需要多核 CPU，真正的多线程\n- 特点：同一时间有多个任务在进行\n- 例子：多个 CPU 核心同时计算不同的数据\n\n【并发（Concurrent）】\n- 定义：多个任务在同一时间段内交替执行，看起来像同时进行\n- 要求：单核也可以实现，通过时间切片\n- 特点：快速切换任务，每个任务执行一小段时间\n- 例子：单核 CPU 通过时间片轮转执行多个程序\n\nReact 18 的并发是：\n- 在单线程（JavaScript 主线程）中实现\n- 通过时间切片将长任务拆分成多个小任务\n- 在多个小任务之间切换，让高优先级任务插队\n- 本质是任务调度，而非真正的并行计算\n\n类比：\n- 并行 = 多个厨师同时做不同的菜（多核心）\n- 并发 = 一个厨师快速切换做多道菜（单核心）\n\nReact 如何实现并发渲染：\n1. Fiber 架构基础\n   - 将渲染工作拆分为多个 Fiber 节点的小单元\n   - 每个单元执行时间短，可以暂停和恢复\n   - 通过链表结构保存断点信息\n\n2. 时间切片（Time Slicing）\n   - 每个时间片默认 5ms（React 内部可配置）\n   - 执行一部分工作后，检查是否超时\n   - 超时则让出主线程，通过 Scheduler 调度下一帧继续\n   - 利用 MessageChannel/setTimeout 实现异步调度\n\n3. 优先级调度（Priority Scheduling）\n   - Lane 模型：31 条车道表示不同优先级\n   - 紧急更新（用户输入）&gt; 普通更新（状态变化）&gt; 低优先级更新（数据预加载）\n   - 高优先级任务可以打断低优先级任务\n   - 饥饿问题处理：低优先级任务过期后提升优先级\n\n4. 双缓冲机制\n   - current 树（当前屏幕显示）\n   - workInProgress 树（后台构建）\n   - 渲染可中断，但提交是原子性的，一次性切换\n\n5. startTransition API\n   - 标记非紧急更新，允许被打断\n   - 保持 UI 响应性，同时处理大量数据更新\n\n实现关键：\n- Scheduler 负责任务调度和时间切片\n- Reconciler（Fiber）负责可中断的协调\n- 两者配合实现并发渲染\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><hr><h3 id="_6-react-18-automatic-batching" tabindex="-1"><a class="header-anchor" href="#_6-react-18-automatic-batching" aria-hidden="true">#</a> 6. React 18 Automatic Batching</h3><p>React 18 的 automatic batching 覆盖哪些场景？举例说明与 React 17 的差异，并解释为什么能实现这种改进。</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>React 18 automatic batching 覆盖场景：\nReact 18 扩展了批处理的覆盖范围，包括：\n1. ✅ 事件处理函数（React 17 也支持）\n2. ✅ setTimeout/setInterval 回调（新增）\n3. ✅ Promise.then 回调（新增）\n4. ✅ 原生事件监听器（新增）\n5. ✅ async/await 异步函数（新增）\n6. ✅ fetch 请求回调（新增）\n\n总结：React 18 在所有场景下都自动批处理，无论更新来源\n\n与 React 17 的差异示例：\n// React 17 的行为\nfunction handleClick() {\n  setCount(c =&gt; c + 1);  // 触发一次渲染\n  setFlag(f =&gt; !f);      // 触发一次渲染\n  // ✅ React 事件中会批处理 → 只渲染 1 次\n}\n\nfunction handleClick17() {\n  setTimeout(() =&gt; {\n    setCount(c =&gt; c + 1);  // 触发一次渲染 ❌\n    setFlag(f =&gt; !f);      // 触发一次渲染 ❌\n    // ❌ 异步回调中不批处理 → 渲染 2 次\n  }, 0);\n}\n\nfetch(&#39;/api&#39;).then(() =&gt; {\n  setCount(c =&gt; c + 1);  // 触发一次渲染 ❌\n  setFlag(f =&gt; !f);      // 触发一次渲染 ❌\n  // ❌ Promise 中不批处理 → 渲染 2 次\n});\n\n// React 18 的行为\nfunction handleClick18() {\n  setTimeout(() =&gt; {\n    setCount(c =&gt; c + 1);\n    setFlag(f =&gt; !f);\n    // ✅ 自动批处理 → 只渲染 1 次\n  }, 0);\n}\n\nfetch(&#39;/api&#39;).then(() =&gt; {\n  setCount(c =&gt; c + 1);\n  setFlag(f =&gt; !f);\n  // ✅ 自动批处理 → 只渲染 1 次\n});\n\n// 如果需要强制同步更新（退出批处理）\nimport { flushSync } from &#39;react-dom&#39;;\n\nflushSync(() =&gt; {\n  setCount(c =&gt; c + 1);  // 立即渲染\n});\nsetFlag(f =&gt; !f);  // 再次渲染\n\n实现原理：\n1. React 17 的限制\n   - 批处理依赖于 React 的事件系统\n   - 通过 isBatchingUpdates 标志控制\n   - 只在 React 合成事件处理函数执行期间启用\n   - 异步回调时 React 上下文已丢失，无法批处理\n\n2. React 18 的改进\n   - 引入 createRoot API，启用并发特性\n   - 所有更新默认进入更新队列\n   - 通过微任务（microtask）延迟提交\n   - 在同一事件循环中的所有更新自动合并\n\n3. 技术实现\n   - 利用 JavaScript 事件循环机制\n   - 将多个 setState 放入更新队列\n   - 在微任务中统一处理，合并为一次渲染\n   - 无需区分更新来源，统一处理\n\n4. 性能提升\n   - 减少渲染次数，提升性能\n   - 避免中间状态展示，防止闪烁\n   - 降低浏览器重绘重排次数\n\n5. 向后兼容\n   - 使用 ReactDOM.createRoot 才启用\n   - 旧的 ReactDOM.render 保持 React 17 行为\n   - 提供 flushSync 作为逃生舱\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br></div></div><hr><h2 id="面试题-4-题" tabindex="-1"><a class="header-anchor" href="#面试题-4-题" aria-hidden="true">#</a> 面试题（4 题）</h2><h3 id="_1-fiber-架构的可中断性" tabindex="-1"><a class="header-anchor" href="#_1-fiber-架构的可中断性" aria-hidden="true">#</a> 1. Fiber 架构的可中断性</h3><p>讲清楚&quot;Fiber 架构&quot;为什么能中断/恢复渲染？底层依赖哪些机制？你会如何用类比的方式解释给技术新人听？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>为什么 Fiber 能中断/恢复渲染：\n\n1. 数据结构支持\n   - Fiber 是链表结构，每个节点独立\n   - 包含 child/sibling/return 指针，可以从任意节点继续遍历\n   - 保存了当前工作状态（pendingProps、memoizedState、updateQueue）\n   - 中断时只需保存当前 Fiber 节点引用，恢复时从该节点继续\n\n2. 工作单元拆分\n   - 将整棵树的渲染拆分为一个个小的工作单元（每个 Fiber 节点）\n   - 每完成一个工作单元就检查时间片是否用完\n   - 用完则保存进度，将控制权交还浏览器\n   - 下一帧再从断点继续\n\n3. 双缓冲机制\n   - current 树：当前屏幕显示的内容\n   - workInProgress 树：正在后台构建的新树\n   - 渲染过程可以多次中断，但只在完全构建好后才一次性提交\n   - 保证用户始终看到完整的 UI，不会看到半成品\n\n底层依赖的机制：\n\n1. Scheduler（调度器）\n   - 负责任务调度和时间切片管理\n   - 使用 MessageChannel 或 setTimeout 实现异步调度\n   - 维护任务队列，按优先级排序\n   - 提供 shouldYield() 方法判断是否需要让出主线程\n\n2. 时间切片（Time Slicing）\n   - 每个时间片约 5ms（一帧 16.6ms 的 1/3）\n   - 工作循环：while (workInProgress &amp;&amp; !shouldYield()) { performUnitOfWork() }\n   - 超时后通过 requestIdleCallback 概念在下一帧继续\n\n3. 优先级调度（Lane Model）\n   - 31 条车道（lane）表示不同优先级\n   - 高优先级任务可以打断低优先级任务\n   - 被打断的任务等待高优任务完成后重新开始\n\n4. 工作循环（Work Loop）\n   - performUnitOfWork：处理单个 Fiber 节点\n   - beginWork：向下遍历，diff 和创建子 Fiber\n   - completeWork：向上回溯，收集副作用\n   - 每个单元执行时间可控，便于中断\n\n类比解释给新人听：\n\n【类比1：盖楼房】\n- React 15（递归）= 一口气盖完楼，中途不能停\n  &quot;包工头说必须连续干，直到楼封顶，期间不能处理其他事&quot;\n  问题：盖 50 层楼时，紧急电话都没法接\n\n- Fiber（可中断）= 盖完一层就检查一下\n  &quot;每盖完一层就问：有没有紧急事？没有就继续盖下一层&quot;\n  优势：随时可以暂停去处理紧急事，之后再回来继续盖\n\n【类比2：餐厅厨师】\n- React 15 = 一道菜必须做完才能做下一道\n  炒菜必须从开火到装盘一气呵成，期间不能切换\n\n- Fiber = 可以在多道菜之间切换\n  &quot;炒菜A 30秒 → 紧急订单来了 → 先做紧急菜 → 回来继续炒菜A&quot;\n  如何做到：用小火保温（保存状态），贴便签记录进度（Fiber 节点）\n\n【类比3：看书 vs 递归算法】\n- 递归（Stack）= 没有书签的书\n  必须一次看完，中途停下就忘了看到哪里\n\n- Fiber = 有书签的书\n  每一页都是一个 Fiber 节点\n  随时可以插书签（保存当前节点）\n  下次打开从书签继续看\n  甚至可以先看后面的重要章节（高优先级），再回来看前面\n\n【关键点总结】\nFiber 就像给 React 加了&quot;书签&quot;和&quot;暂停键&quot;：\n1. 书签 = Fiber 节点的链表结构，记录位置\n2. 暂停键 = 时间切片，定期检查是否需要暂停\n3. 任务管理器 = Scheduler，决定先做什么后做什么\n4. 草稿本 = workInProgress 树，可以反复修改，不影响正式版\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br></div></div><hr><h3 id="_2-render-阶段-vs-commit-阶段" tabindex="-1"><a class="header-anchor" href="#_2-render-阶段-vs-commit-阶段" aria-hidden="true">#</a> 2. Render 阶段 vs Commit 阶段</h3><p>React 为什么要把 render 和 commit 分开？commit 阶段为什么不能被打断？如果 commit 阶段也能中断会有什么问题？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>为什么要把 Render 和 Commit 分开：\n\n1. 职责分离\n   - Render 阶段：计算&quot;要做什么&quot;（纯计算，无副作用）\n     → 对比新旧虚拟 DOM，标记需要变更的节点\n     → 可以被打断、重新开始，不影响用户界面\n\n   - Commit 阶段：执行&quot;真正的变更&quot;（副作用，修改 DOM）\n     → 根据 Render 阶段的计算结果修改真实 DOM\n     → 必须同步完成，保证 UI 一致性\n\n2. 性能优化\n   - Render 阶段可以中断，高优先级任务可以插队\n   - 被打断的低优先级渲染可以丢弃，重新计算\n   - 避免在计算阶段阻塞用户交互\n\n3. 幂等性保证\n   - Render 阶段是纯函数，多次执行结果相同\n   - 可以安全地中断、重启、重算\n   - Commit 阶段有副作用，不能重复执行\n\n4. 架构灵活性\n   - Render 阶段可跨平台复用（React Native/RN Web）\n   - Commit 阶段针对不同平台有不同实现\n   - React-dom、React-native 共享 Reconciler（Render），各自实现 Renderer（Commit）\n\nCommit 阶段为什么不能被打断：\n\n1. DOM 一致性问题\n   - DOM 操作是副作用，会直接影响用户看到的界面\n   - 如果中断，用户会看到不完整的 UI\n   - 例如：插入一半的列表、只改变了一部分样式\n\n2. 生命周期顺序保证\n   - componentDidMount/useLayoutEffect 必须在 DOM 更新后立即同步执行\n   - 如果中断，生命周期执行顺序会错乱\n   - 父组件的 didMount 必须在子组件之后执行\n\n3. ref 引用问题\n   - ref 的赋值必须与 DOM 操作同步\n   - 中断会导致 ref 指向旧的或不存在的 DOM 节点\n   - 用户在生命周期中访问 ref 会出错\n\n4. 视觉一致性\n   - 多个 DOM 变更应该在同一帧中完成\n   - 浏览器一次性重绘，避免闪烁\n   - 中断会导致多次重绘，出现视觉抖动\n\n如果 Commit 阶段也能中断会有什么问题：\n\n【问题1：UI 撕裂】\n场景：更新一个列表，插入 5 个新元素\n- 中断时机：插入了 3 个就被打断\n- 结果：用户看到不完整的列表\n- 体验：界面一会多 3 个，一会又多 2 个，闪烁抖动\n\n【问题2：状态不一致】\n场景：同时更新文本和样式\n```jsx\n&lt;div style={{color: isActive ? &#39;red&#39; : &#39;blue&#39;}}&gt;\n  {isActive ? &#39;激活&#39; : &#39;未激活&#39;}\n&lt;/div&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br></div></div><ul><li>中断时机：只更新了颜色，文本还没更新</li><li>结果：蓝色的&quot;激活&quot;或红色的&quot;未激活&quot;</li><li>问题：短暂的状态不一致，用户困惑</li></ul><p>【问题 3：生命周期混乱】 场景：组件挂载过程被打断</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 此时 DOM 可能还没真正插入</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>divRef<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 报错！</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>中断导致 didMount 执行时 DOM 还未完全更新</li><li>ref 可能指向旧节点或 null</li></ul><p>【问题 4：第三方库兼容性】 场景：使用 echarts 等需要 DOM 的库</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> chart <span class="token operator">=</span> echarts<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>chartRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span> <span class="token comment">// 此时 DOM 可能还没准备好</span>\n  chart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>如果 Commit 可中断，第三方库会在不稳定的 DOM 上操作</li><li>导致渲染错误、内存泄漏</li></ul><p>【问题 5：浏览器回流抖动】</p><ul><li>每次部分 DOM 更新都会触发浏览器回流（reflow）</li><li>如果分多次提交，会有多次回流，性能反而更差</li><li>一次性提交所有变更，浏览器可以优化为一次回流</li></ul><p>【对比总结】</p><table><thead><tr><th>阶段</th><th>能否中断</th><th>原因</th><th>副作用</th></tr></thead><tbody><tr><td>Render</td><td>✅ 可以</td><td>纯计算，不影响 UI</td><td>无</td></tr><tr><td>Commit</td><td>❌ 不可以</td><td>DOM 操作，必须原子性</td><td>有</td></tr></tbody></table><p>【类比】</p><ul><li>Render = 建筑师画图纸 → 可以画一半改主意，重新画，用户看不到</li><li>Commit = 工人按图纸施工 → 必须一次性完成，不能墙砌一半就停，否则房子会塌</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>\n---\n\n### 3. React 18 并发模式的实践问题\nReact 18 下你遇到过哪些&quot;并发带来的坑&quot;（比如副作用执行时序、状态不一致）？如何规避这些问题？Strict Mode 的双重调用是为了什么？\n\n**【作答】：**\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>并发模式带来的常见问题：</p><p>【问题 1：useEffect 重复执行】 现象：</p><ul><li>Strict Mode 下，组件挂载时 useEffect 执行 2 次</li><li>先执行 effect → cleanup → effect</li></ul><p>案例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> subscription <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 订阅了 2 次！</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> subscription<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>影响：</p><ul><li>WebSocket 重复连接</li><li>API 重复请求</li><li>事件监听器重复绑定</li></ul><p>规避方法：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 方法1：正确处理清理函数</span>\n<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> ignore <span class="token operator">=</span> <span class="token boolean">false</span>\n  <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ignore<span class="token punctuation">)</span> <span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment">// 防止过期数据</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    ignore <span class="token operator">=</span> <span class="token boolean">true</span>\n  <span class="token punctuation">}</span> <span class="token comment">// cleanup 设置标志</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n<span class="token comment">// ✅ 方法2：使用 useRef 防止重复</span>\n<span class="token keyword">const</span> subscriptionRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>\n<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>subscriptionRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    subscriptionRef<span class="token punctuation">.</span>current <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    subscriptionRef<span class="token punctuation">.</span>current<span class="token operator">?.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    subscriptionRef<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>【问题 2：中间状态可见（Tearing）】 现象：</p><ul><li>同一状态在不同组件中看到不同的值</li><li>并发渲染时，状态在渲染过程中被更新</li></ul><p>案例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// 外部 store（非 React 状态）</span>\n<span class="token keyword">let</span> externalStore <span class="token operator">=</span> <span class="token number">0</span>\n\n<span class="token keyword">function</span> <span class="token function">ComponentA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> value <span class="token operator">=</span> externalStore <span class="token comment">// 读取时是 0</span>\n  <span class="token comment">// ... 耗时渲染 ...</span>\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token comment">// 可能还是 0</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">ComponentB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> value <span class="token operator">=</span> externalStore <span class="token comment">// 读取时已经是 1</span>\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token comment">// 显示 1</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 中途 externalStore 变成 1</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  externalStore <span class="token operator">=</span> <span class="token number">1</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>结果：两个组件显示不同的值（UI 撕裂）</p><p>规避方法：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 使用 useSyncExternalStore（React 18 新增）</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> useSyncExternalStore <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span>\n\n<span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useSyncExternalStore</span><span class="token punctuation">(</span>\n  store<span class="token punctuation">.</span>subscribe<span class="token punctuation">,</span> <span class="token comment">// 订阅函数</span>\n  store<span class="token punctuation">.</span>getSnapshot<span class="token punctuation">,</span> <span class="token comment">// 获取快照</span>\n  store<span class="token punctuation">.</span>getServerSnapshot <span class="token comment">// SSR 快照（可选）</span>\n<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>【问题 3：过时的闭包问题】 现象：</p><ul><li>并发渲染时，渲染可能被放弃重来</li><li>useEffect 中捕获的值可能已过时</li></ul><p>案例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">SearchBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">[</span>query<span class="token punctuation">,</span> setQuery<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span>\n\n  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果渲染被打断重来，这个 query 可能是旧值</span>\n      <span class="token function">fetchResults</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>query<span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>规避方法：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 使用 useTransition 明确标记</span>\n<span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">handleSearch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">setQuery</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// 紧急更新，立即响应输入</span>\n  <span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token function">setResults</span><span class="token punctuation">(</span><span class="token function">searchResults</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 非紧急，可以延迟</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// ✅ 使用 useDeferredValue</span>\n<span class="token keyword">const</span> deferredQuery <span class="token operator">=</span> <span class="token function">useDeferredValue</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span>\n<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">fetchResults</span><span class="token punctuation">(</span>deferredQuery<span class="token punctuation">)</span> <span class="token comment">// 使用延迟的值</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>deferredQuery<span class="token punctuation">]</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>【问题 4：状态批处理时序变化】 现象：</p><ul><li>React 18 所有更新都自动批处理</li><li>以前同步的 setState 现在可能是异步的</li></ul><p>案例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// React 17</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 立即渲染</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">// &quot;1&quot;</span>\n  <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 再次渲染</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>\n\n<span class="token comment">// React 18</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 不立即渲染</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">// &quot;0&quot;（还没更新）</span>\n  <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 批处理，只渲染一次</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>规避方法：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 使用 flushSync 强制同步</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> flushSync <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react-dom&#39;</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 立即同步渲染</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">// &quot;1&quot;</span>\n  <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 再次渲染</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>【问题 5：Suspense 导致的多次渲染】 现象：</p><ul><li>组件可能被渲染多次后才最终提交</li><li>Render 阶段的代码可能执行多次</li></ul><p>案例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 可能触发多次</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;render&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 会打印多次</span>\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>data<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>规避方法：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ❌ 不要在 render 中执行副作用</span>\n<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  analytics<span class="token punctuation">.</span><span class="token function">track</span><span class="token punctuation">(</span><span class="token string">&#39;render&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 错误！会重复上报</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// ✅ 副作用放在 useEffect 中</span>\n<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    analytics<span class="token punctuation">.</span><span class="token function">track</span><span class="token punctuation">(</span><span class="token string">&#39;mount&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 正确，只在提交后执行一次</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Strict Mode 的双重调用是为了什么：</p><p>【目的】 帮助开发者提前发现并发模式下的问题</p><p>【具体行为（仅开发环境）】</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>第一次：render → effect → cleanup\n第二次：render → effect\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>【检测的问题】</p><ol><li><p>✅ 副作用是否正确清理</p><ul><li>如果没有 cleanup，第二次执行可能导致内存泄漏</li></ul></li><li><p>✅ 组件是否是纯函数</p><ul><li>render 执行两次，结果应该相同</li><li>检测 render 中的副作用（不应该有）</li></ul></li><li><p>✅ 并发渲染的兼容性</p><ul><li>模拟组件被卸载后重新挂载的场景</li><li>确保组件能够正确恢复状态</li></ul></li></ol><p>【典型错误示例】</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ❌ 没有清理，会导致重复订阅</span>\n<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token comment">// 缺少 return () =&gt; unsubscribe();</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n<span class="token comment">// ❌ 在 render 中修改外部状态</span>\n<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  externalCounter<span class="token operator">++</span> <span class="token comment">// 错误！执行两次会导致计数错误</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// ✅ 正确写法</span>\n<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    externalCounter<span class="token operator">++</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>【最佳实践总结】</p><ol><li>✅ 始终为 useEffect 提供正确的 cleanup 函数</li><li>✅ Render 阶段保持纯净，不执行副作用</li><li>✅ 使用 useSyncExternalStore 处理外部状态</li><li>✅ 使用 useTransition/useDeferredValue 处理非紧急更新</li><li>✅ 需要同步更新时使用 flushSync（谨慎使用）</li><li>✅ 在 Strict Mode 下充分测试</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>\n---\n\n### 4. 性能优化决策\n你如何判断一个组件该使用 memo/useMemo/useCallback？给出你的原则与反例（过度优化的场景）。如何量化优化效果？\n\n**【作答】：**\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>判断是否需要优化的原则：</p><p>【何时使用 React.memo】 ✅ 应该使用的场景：</p><ol><li>组件渲染成本高（复杂计算、大列表）</li><li>组件频繁渲染，但 props 很少变化</li><li>组件在列表中重复渲染</li><li>父组件频繁更新，但该子组件不需要同步更新</li></ol><p>示例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 适合：复杂的列表项组件</span>\n<span class="token keyword">const</span> ListItem <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> id<span class="token punctuation">,</span> title<span class="token punctuation">,</span> description <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>complex-item<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token comment">/* 复杂的渲染逻辑 */</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// ✅ 适合：纯展示组件</span>\n<span class="token keyword">const</span> UserCard <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> user <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">\n      </span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token plain-text"> - </span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>email<span class="token punctuation">}</span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>❌ 不应该使用的场景：</p><ol><li>props 每次都变化（memo 反而增加对比成本）</li><li>组件本身很简单（一个 div + 文本）</li><li>组件很少重新渲染</li><li>props 包含复杂对象且没有稳定引用</li></ol><p>反例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ❌ 过度优化：组件太简单</span>\n<span class="token keyword">const</span> Button <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> label <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>label<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>\n<span class="token comment">// 对比 props 的成本 &gt; 重新渲染的成本</span>\n\n<span class="token comment">// ❌ 过度优化：props 总是变化</span>\n<span class="token keyword">const</span> Clock <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> time <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>time<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>\n<span class="token comment">// time 每秒都变，memo 毫无意义</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>【何时使用 useMemo】 ✅ 应该使用的场景：</p><ol><li>计算成本高（循环、递归、复杂运算）</li><li>依赖项很少变化</li><li>结果被用作其他 Hook 的依赖</li><li>结果传递给使用了 React.memo 的子组件</li></ol><p>示例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 适合：昂贵计算</span>\n<span class="token keyword">const</span> expensiveValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> hugeList\n    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">complexCondition</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">expensiveTransform</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>hugeList<span class="token punctuation">,</span> condition<span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n<span class="token comment">// ✅ 适合：作为依赖项</span>\n<span class="token keyword">const</span> memoizedData <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> name <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>id<span class="token punctuation">,</span> name<span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">fetchRelatedData</span><span class="token punctuation">(</span>memoizedData<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>memoizedData<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 避免无限循环</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>❌ 不应该使用的场景：</p><ol><li>简单的计算（加减乘除、字符串拼接）</li><li>依赖项频繁变化</li><li>创建简单对象或数组</li></ol><p>反例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ❌ 过度优化：计算太简单</span>\n<span class="token keyword">const</span> fullName <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">&#39; &#39;</span> <span class="token operator">+</span> lastName\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token comment">// 直接计算更快</span>\n\n<span class="token comment">// ❌ 过度优化：依赖项总变</span>\n<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">timestamp</span><span class="token operator">:</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 每次都变，毫无意义</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>【何时使用 useCallback】 ✅ 应该使用的场景：</p><ol><li>函数传递给使用了 React.memo 的子组件</li><li>函数作为 useEffect/useMemo 的依赖项</li><li>函数包含复杂逻辑且依赖项稳定</li><li>自定义 Hook 返回的函数</li></ol><p>示例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 适合：传递给 memo 组件</span>\n<span class="token keyword">const</span> MemoChild <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> onClick <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Click</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> handleClick <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;clicked&#39;</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 稳定引用，避免 MemoChild 重渲染</span>\n\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MemoChild</span></span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// ✅ 适合：作为依赖项</span>\n<span class="token keyword">const</span> fetchData <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> api<span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>\n  <span class="token function">setData</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>fetchData<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 避免无限循环</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>❌ 不应该使用的场景：</p><ol><li>子组件没有用 memo</li><li>函数仅在当前组件内部使用</li><li>函数没有被作为依赖项传递</li></ol><p>反例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ❌ 过度优化：子组件没有 memo</span>\n<span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> handleClick <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child</span></span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span> <span class="token comment">// Child 没有 memo，无意义</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// ❌ 过度优化：仅内部使用</span>\n<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> helper <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> x <span class="token operator">*</span> <span class="token number">2</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n  <span class="token comment">// 仅在此组件内调用，不需要缓存</span>\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>【优化决策流程图】</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>是否有性能问题？\n  ↓ 否 → 不要优化\n  ↓ 是\n用 Profiler 分析慢在哪？\n  ↓\n组件重渲染过多？\n  ↓ 是\n  props 经常不变？\n    ↓ 是 → 使用 React.memo\n    ↓ 否 → 检查是否可以拆分组件\n  ↓\n有昂贵计算？\n  ↓ 是\n  依赖项稳定？\n    ↓ 是 → 使用 useMemo\n    ↓ 否 → 考虑移到组件外或 Web Worker\n  ↓\n函数引用导致子组件重渲染？\n  ↓ 是 → 使用 useCallback\n  ↓ 否 → 不需要优化\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>【过度优化的典型反例】</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ❌ 反例1：全家桶优化（没必要）</span>\n<span class="token keyword">const</span> Component <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> data <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> processedData <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> data<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>data<span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> handleClick <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>processedData<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>processedData<span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>processedData<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 如果组件本身很简单，这些优化都是浪费</span>\n\n<span class="token comment">// ❌ 反例2：过早优化</span>\n<span class="token keyword">const</span> TodoItem <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> todo <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> formattedDate <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>todo<span class="token punctuation">.</span>date<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLocaleDateString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>todo<span class="token punctuation">.</span>date<span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">\n      </span><span class="token punctuation">{</span>todo<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token plain-text"> - </span><span class="token punctuation">{</span>formattedDate<span class="token punctuation">}</span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 日期格式化很快，useMemo 反而更慢</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>【如何量化优化效果】</p><ol><li>使用 React DevTools Profiler</li></ol><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// 在组件外包裹 Profiler</span>\n<span class="token punctuation">;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Profiler</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ComponentName<span class="token punctuation">&quot;</span></span> <span class="token attr-name">onRender</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>callback<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Component</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Profiler</span></span><span class="token punctuation">&gt;</span></span>\n\n<span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span>\n  id<span class="token punctuation">,</span>\n  phase<span class="token punctuation">,</span> <span class="token comment">// &quot;mount&quot; 或 &quot;update&quot;</span>\n  actualDuration<span class="token punctuation">,</span> <span class="token comment">// 本次渲染耗时</span>\n  baseDuration<span class="token punctuation">,</span> <span class="token comment">// 理想情况下耗时</span>\n  startTime<span class="token punctuation">,</span>\n  commitTime\n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>phase<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 耗时: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>actualDuration<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">ms</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ol start="2"><li>Chrome DevTools Performance</li></ol><ul><li>录制 6fps 以下的场景</li><li>查看 Main thread 中的 React 相关任务</li><li>对比优化前后的 Scripting 时间</li></ul><ol start="3"><li>自定义性能监控</li></ol><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// 测量渲染次数</span>\n<span class="token keyword">let</span> renderCount <span class="token operator">=</span> <span class="token number">0</span>\n<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  renderCount<span class="token operator">++</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Render count:&#39;</span><span class="token punctuation">,</span> renderCount<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 测量计算耗时</span>\nconsole<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">&#39;expensive-calc&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">expensiveCalculation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">&#39;expensive-calc&#39;</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol start="4"><li>性能指标对比</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>优化前：\n- 组件平均渲染时间：15ms\n- 每秒重渲染次数：30次\n- 总耗时：450ms/秒\n\n优化后（使用 memo）：\n- 组件平均渲染时间：15ms\n- 每秒重渲染次数：5次（减少83%）\n- 总耗时：75ms/秒（减少83%）\n\n投入产出比：值得！\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>【最佳实践原则】</p><ol><li>⚡ 先测量，再优化（不要猜）</li><li>⚡ 优化瓶颈，而非全部</li><li>⚡ 简单组件不优化</li><li>⚡ memo/useMemo/useCallback 需要配合使用才有效</li><li>⚡ 关注用户体验指标（FPS、响应时间）</li><li>⚡ 避免过早优化，除非有明确证据</li></ol><p>【何时停止优化】</p><ul><li>✅ FPS 稳定在 60fps</li><li>✅ 交互响应时间 &lt; 100ms</li><li>✅ Profiler 中无明显性能瓶颈</li><li>✅ 用户无卡顿感知</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>\n---\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>',144),e={},t=(0,a(3744).Z)(e,[["render",function(n,s){return p}]])},3744:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,p]of s)a[n]=p;return a}}}]);