"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[153],{7174:(l,i,e)=>{e.r(i),e.d(i,{data:()=>s});const s={key:"v-67bfe4d8",path:"/mark/07-NestJS%E4%B8%8ESSR.html",title:"从 NestJS 全栈开发到 SSR & SSR 核心原理",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"笔试题（6 题）",slug:"笔试题-6-题",children:[{level:3,title:"1. NestJS 核心概念",slug:"_1-nestjs-核心概念",children:[]},{level:3,title:"2. NestJS vs Express/Koa",slug:"_2-nestjs-vs-express-koa",children:[]},{level:3,title:"3. SSR vs CSR vs SSG",slug:"_3-ssr-vs-csr-vs-ssg",children:[]},{level:3,title:"4. SSR 核心流程",slug:"_4-ssr-核心流程",children:[]},{level:3,title:"5. SSR 同构问题",slug:"_5-ssr-同构问题",children:[]},{level:3,title:"6. SSR 性能优化",slug:"_6-ssr-性能优化",children:[]}]},{level:2,title:"面试题（4 题）",slug:"面试题-4-题",children:[{level:3,title:"1. NestJS 全栈项目架构",slug:"_1-nestjs-全栈项目架构",children:[]},{level:3,title:"2. SSR 方案选型",slug:"_2-ssr-方案选型",children:[]},{level:3,title:"3. SSR 性能问题排查",slug:"_3-ssr-性能问题排查",children:[]},{level:3,title:"4. SSR 实践经验",slug:"_4-ssr-实践经验",children:[]}]}],git:{updatedTime:1770268685e3},filePathRelative:"mark/07-NestJS与SSR.md"}},8774:(l,i,e)=>{e.r(i),e.d(i,{default:()=>a});const s=(0,e(6252).uE)('<h1 id="从-nestjs-全栈开发到-ssr-ssr-核心原理" tabindex="-1"><a class="header-anchor" href="#从-nestjs-全栈开发到-ssr-ssr-核心原理" aria-hidden="true">#</a> 从 NestJS 全栈开发到 SSR &amp; SSR 核心原理</h1><h2 id="笔试题-6-题" tabindex="-1"><a class="header-anchor" href="#笔试题-6-题" aria-hidden="true">#</a> 笔试题（6 题）</h2><h3 id="_1-nestjs-核心概念" tabindex="-1"><a class="header-anchor" href="#_1-nestjs-核心概念" aria-hidden="true">#</a> 1. NestJS 核心概念</h3><p>NestJS 的核心概念：模块、控制器、服务、依赖注入、装饰器。它们如何协同工作？</p><p><strong>【作答】：</strong></p><p>模块 (Module):</p><ul><li>是应用的基本组织单位，使用 @Module() 装饰器定义</li><li>每个模块封装相关的功能（控制器、服务、导入、导出）</li><li>通过 imports 导入其他模块，exports 导出供其他模块使用</li><li>提供依赖注入的容器作用域</li></ul><p>控制器 (Controller):</p><ul><li>负责处理 HTTP 请求，使用 @Controller() 装饰器定义</li><li>通过路由装饰器（@Get、@Post 等）定义路由处理函数</li><li>接收请求参数，调用服务层处理业务逻辑，返回响应</li><li>不包含业务逻辑，只负责请求/响应的处理</li></ul><p>服务 (Service/Provider):</p><ul><li>封装业务逻辑，使用 @Injectable() 装饰器定义</li><li>可被注入到控制器或其他服务中</li><li>提供可复用的业务功能，保持代码解耦</li><li>可以是类、值、工厂函数等多种形式</li></ul><p>依赖注入 (DI):</p><ul><li>NestJS 的核心机制，基于 IoC（控制反转）容器</li><li>通过构造函数参数自动注入依赖</li><li>支持单例、请求作用域、瞬态等多种生命周期</li><li>提高代码可测试性和可维护性</li></ul><p>装饰器 (Decorator):</p><ul><li>TypeScript/JavaScript 的元编程特性</li><li>NestJS 大量使用装饰器进行元数据标记</li><li>如 @Module()、@Controller()、@Injectable()、@Get() 等</li><li>在编译时和运行时提供元信息，实现依赖注入和路由映射</li></ul><p>协同工作流程:</p><ol><li>应用启动时，NestJS 扫描所有模块，构建依赖图</li><li>创建 IoC 容器，实例化所有 Provider（服务）</li><li>根据装饰器元数据，将路由映射到控制器方法</li><li>请求到达时，路由系统找到对应的控制器方法</li><li>控制器通过构造函数注入所需的服务</li><li>控制器调用服务方法处理业务逻辑</li><li>返回响应给客户端 整个过程实现了关注点分离：路由 → 控制器 → 服务 → 数据层</li></ol><hr><h3 id="_2-nestjs-vs-express-koa" tabindex="-1"><a class="header-anchor" href="#_2-nestjs-vs-express-koa" aria-hidden="true">#</a> 2. NestJS vs Express/Koa</h3><p>NestJS 相比 Express/Koa 的优势是什么？适用场景有什么不同？</p><p><strong>【作答】：</strong></p><p>NestJS 优势:</p><ol><li>架构清晰：基于模块化设计，强制分层（Controller-Service-Repository）</li><li>依赖注入：内置 IoC 容器，便于测试和模块解耦</li><li>TypeScript 原生支持：完整的类型安全和 IDE 智能提示</li><li>企业级特性：内置认证、验证、日志、配置管理等</li><li>可扩展性：支持微服务、GraphQL、WebSocket 等</li><li>学习曲线：借鉴 Angular 架构，适合大型团队协作</li></ol><p>Express/Koa 优势:</p><ol><li>轻量灵活：核心功能精简，按需添加中间件</li><li>学习成本低：API 简单直观，上手快</li><li>生态丰富：中间件和插件数量庞大</li><li>性能优秀：框架开销小，适合高性能场景</li><li>自由度高：不强制架构模式，灵活组织代码</li><li>社区成熟：文档和案例丰富</li></ol><p>适用场景对比: NestJS 适合：</p><ul><li>大型企业级应用，需要严格的架构规范</li><li>团队协作项目，需要统一的代码风格</li><li>需要复杂业务逻辑和模块化设计的项目</li><li>微服务架构，需要统一的框架标准</li><li>需要 GraphQL、WebSocket 等高级特性</li></ul><p>Express/Koa 适合：</p><ul><li>中小型项目，快速开发原型</li><li>需要极致性能的场景（如 API 网关）</li><li>团队熟悉底层原理，需要高度定制</li><li>简单的 RESTful API 服务</li><li>学习和教学场景</li></ul><hr><h3 id="_3-ssr-vs-csr-vs-ssg" tabindex="-1"><a class="header-anchor" href="#_3-ssr-vs-csr-vs-ssg" aria-hidden="true">#</a> 3. SSR vs CSR vs SSG</h3><p>对比 SSR（服务端渲染）/ CSR（客户端渲染）/ SSG（静态生成）的原理、优缺点、适用场景。</p><p><strong>【作答】：</strong></p><p>SSR (Server-Side Rendering): 原理:</p><ul><li>服务器接收到请求后，在服务端执行 JavaScript 代码</li><li>渲染完整的 HTML 页面（包含数据和 DOM 结构）</li><li>将渲染好的 HTML 发送给客户端</li><li>客户端接收后显示页面，然后进行 hydration（水合）激活交互</li></ul><p>优点:</p><ul><li>SEO 友好：搜索引擎可以直接抓取完整的 HTML 内容</li><li>首屏加载快：用户立即看到内容，无需等待 JS 执行</li><li>对低性能设备友好：渲染工作在服务端完成</li><li>更好的社交分享：OG 标签等元数据完整</li></ul><p>缺点:</p><ul><li>服务器压力大：每次请求都需要渲染</li><li>TTFB（首字节时间）可能较长：需要等待服务端渲染完成</li><li>开发复杂度高：需要处理同构代码、环境差异</li><li>服务器成本高：需要 Node.js 服务器资源</li></ul><p>适用场景:</p><ul><li>内容为主的应用（博客、新闻、电商详情页）</li><li>SEO 要求高的页面</li><li>首屏性能要求高的场景</li><li>需要服务端数据预取的页面</li></ul><p>CSR (Client-Side Rendering): 原理:</p><ul><li>服务器返回空的 HTML 骨架和 JavaScript bundle</li><li>浏览器下载并执行 JavaScript</li><li>JS 代码在客户端请求数据、渲染 DOM</li><li>所有交互和路由都在客户端完成</li></ul><p>优点:</p><ul><li>服务器压力小：只提供静态文件和 API</li><li>交互体验好：页面切换无需刷新，SPA 体验</li><li>开发简单：只需关注客户端代码</li><li>可充分利用 CDN：静态资源缓存效果好</li></ul><p>缺点:</p><ul><li>SEO 不友好：搜索引擎难以抓取动态内容</li><li>首屏白屏时间长：需要等待 JS 下载和执行</li><li>对低性能设备不友好：渲染在客户端完成</li><li>初始加载体积大：需要下载完整的 JS bundle</li></ul><p>适用场景:</p><ul><li>后台管理系统、Dashboard</li><li>交互复杂的应用（如在线编辑器）</li><li>SEO 要求不高的应用</li><li>需要离线能力的 PWA 应用</li></ul><p>SSG (Static Site Generation): 原理:</p><ul><li>在构建时（build time）预渲染所有页面为静态 HTML</li><li>将生成的 HTML 文件部署到 CDN 或静态服务器</li><li>用户请求时直接返回预渲染的 HTML</li><li>可以配合 ISR（增量静态再生）实现部分页面动态更新</li></ul><p>优点:</p><ul><li>性能最优：直接返回静态 HTML，响应极快</li><li>服务器成本低：无需 Node.js 运行时</li><li>SEO 完美：完整的 HTML 内容</li><li>安全性高：无服务端代码执行</li></ul><p>缺点:</p><ul><li>构建时间长：需要预渲染所有页面</li><li>不适合频繁更新的内容：需要重新构建</li><li>无法个性化：所有用户看到相同内容</li><li>动态数据需要额外处理（如 ISR、API 调用）</li></ul><p>适用场景:</p><ul><li>博客、文档网站</li><li>营销页面、落地页</li><li>内容相对固定的网站</li><li>需要极致性能的场景</li></ul><hr><h3 id="_4-ssr-核心流程" tabindex="-1"><a class="header-anchor" href="#_4-ssr-核心流程" aria-hidden="true">#</a> 4. SSR 核心流程</h3><p>SSR 的核心流程是什么？从请求到返回 HTML 经历哪些步骤？数据预取、hydration 如何工作？</p><p><strong>【作答】：</strong></p><p>核心流程:</p><ol><li>用户请求 → 服务器接收 HTTP 请求</li><li>路由匹配 → 根据 URL 匹配对应的路由组件</li><li>数据预取 → 在服务端获取页面所需数据（API 调用、数据库查询）</li><li>服务端渲染 → 使用 React/Vue 等框架在服务端渲染组件为 HTML</li><li>HTML 返回 → 将完整的 HTML（包含初始数据）发送给客户端</li><li>客户端接收 → 浏览器接收 HTML 并立即显示</li><li>JS Bundle 加载 → 下载并执行客户端 JavaScript</li><li>Hydration → 客户端 JS 接管页面，激活交互功能</li><li>后续交互 → 用户操作触发客户端路由和数据更新</li></ol><p>数据预取 (Data Fetching):</p><ul><li>在服务端渲染前，需要获取页面所需的所有数据</li><li>方式 1：在路由组件中定义静态方法（如 getServerSideProps、load）</li><li>方式 2：在服务端路由处理函数中直接调用数据获取逻辑</li><li>方式 3：使用数据获取库（如 React Query、SWR）的服务端适配</li><li>数据获取完成后，将数据作为 props 传递给组件</li><li>数据通常序列化到 HTML 中（如 window.<strong>INITIAL_STATE</strong>），供客户端 hydration 使用</li><li>避免客户端再次请求相同数据，减少闪烁和加载状态</li></ul><p>服务端渲染:</p><ul><li>使用 ReactDOMServer.renderToString() 或 renderToStream() 等方法</li><li>在 Node.js 环境中执行组件代码，生成 HTML 字符串</li><li>组件在服务端执行时，所有生命周期和 hooks 都会执行</li><li>需要确保组件在服务端和客户端渲染结果一致（避免 hydration mismatch）</li><li>生成的 HTML 包含完整的 DOM 结构，可以直接被搜索引擎索引</li><li>可以配合流式渲染（Streaming）逐步发送 HTML，提升 TTFB</li></ul><p>Hydration:</p><ul><li>客户端 JavaScript 下载完成后，React/Vue 等框架会&quot;激活&quot;静态 HTML</li><li>框架会对比服务端渲染的 HTML 和客户端首次渲染的结果</li><li>如果一致，则&quot;水合&quot;成功，绑定事件监听器，启用交互</li><li>如果不一致，会出现 hydration mismatch 错误</li><li>Hydration 后，后续的路由切换和数据更新都在客户端完成</li><li>这是一个&quot;接管&quot;过程：从静态 HTML 转为可交互的 SPA</li><li>性能优化：可以只对关键组件进行 hydration（Partial Hydration）</li></ul><hr><h3 id="_5-ssr-同构问题" tabindex="-1"><a class="header-anchor" href="#_5-ssr-同构问题" aria-hidden="true">#</a> 5. SSR 同构问题</h3><p>SSR 同构代码需要注意哪些问题？window/document 不存在、Node.js API 差异、副作用处理？</p><p><strong>【作答】：</strong></p><p>环境差异处理:</p><ul><li>使用 typeof window !== &#39;undefined&#39; 判断客户端环境</li><li>使用 process**.env.NODE_ENV 或 process**.browser 判断服务端</li><li>创建统一的 isServer/isClient 工具函数</li><li>对于只在客户端运行的代码，使用动态导入（dynamic import）</li><li>使用条件渲染：只在客户端渲染特定组件</li><li>避免在模块顶层使用浏览器 API，延迟到运行时检查</li></ul><p>全局对象问题:</p><ul><li>window/document 不存在：使用条件判断或 polyfill if (typeof window !== &#39;undefined&#39;) { window.localStorage.setItem(&#39;key&#39;, &#39;value&#39;); }</li><li>navigator/location 等：同样需要环境判断</li><li>使用 isomorphic-fetch、node-fetch 等跨环境库</li><li>对于必须使用浏览器 API 的代码，使用 useEffect（React）或 onMounted（Vue）</li><li>服务端渲染时提供默认值或跳过相关逻辑</li></ul><p>副作用控制:</p><ul><li>避免在组件顶层执行副作用（如直接调用 API、修改 DOM）</li><li>使用 useEffect/onMounted 等生命周期钩子包裹副作用</li><li>服务端渲染时，某些副作用应该跳过（如事件监听、定时器）</li><li>确保副作用代码在服务端和客户端执行结果一致</li><li>使用 cleanup 函数清理副作用，避免内存泄漏</li><li>对于全局状态（如 Redux），确保服务端和客户端初始化一致</li></ul><p>第三方库兼容:</p><ul><li>检查库是否支持 SSR（查看文档或源码）</li><li>使用支持同构的库（如 axios、isomorphic-fetch）</li><li>对于不支持的库，使用动态导入或条件加载</li><li>使用 webpack 的 externals 或 resolve.alias 处理 Node.js 模块</li><li>对于包含浏览器 API 的库，使用 dynamic import 延迟加载</li><li>使用 babel-plugin-transform-require-ignore 忽略某些模块</li><li>常见问题库：chart.js、three.js 等需要特殊处理</li></ul><hr><h3 id="_6-ssr-性能优化" tabindex="-1"><a class="header-anchor" href="#_6-ssr-性能优化" aria-hidden="true">#</a> 6. SSR 性能优化</h3><p>SSR 性能优化策略有哪些？缓存、流式渲染、部分 Hydration、组件级缓存？</p><p><strong>【作答】：</strong></p><p>页面/组件缓存:</p><ul><li>页面级缓存：对相同 URL 的请求缓存渲染结果（Redis、内存缓存）</li><li>组件级缓存：缓存无状态或数据变化少的组件渲染结果</li><li>缓存策略：TTL（过期时间）、LRU（最近最少使用）、基于数据版本</li><li>缓存键设计：URL + 用户身份 + 数据版本号</li><li>缓存失效：数据更新时清除相关缓存</li><li>使用 React.memo、Vue 的 computed 减少不必要的重渲染</li><li>对于静态内容，使用 SSG 或长期缓存</li></ul><p>流式渲染 (Streaming):</p><ul><li>使用 ReactDOMServer.renderToStream() 替代 renderToString()</li><li>逐步发送 HTML，而不是等待全部渲染完成</li><li>提升 TTFB（首字节时间），用户更快看到内容</li><li>使用 Suspense 边界控制流式渲染的粒度</li><li>关键内容优先发送，非关键内容延迟发送</li><li>配合 HTTP/2 Server Push 推送关键资源</li><li>注意：需要确保 HTML 结构完整，避免浏览器解析错误</li></ul><p>部分 Hydration (Partial Hydration):</p><ul><li>只对需要交互的组件进行 hydration，静态内容保持静态</li><li>减少客户端 JavaScript 执行量，提升性能</li><li>使用 React 18 的 Selective Hydration 特性</li><li>将页面分为可交互区域和静态区域</li><li>静态区域不进行 hydration，减少内存占用</li><li>延迟 hydration：非关键组件延迟到用户交互时再激活</li><li>配合代码分割，按需加载和 hydration</li></ul><p>其他优化策略:</p><ol><li>代码分割：使用动态导入，按路由或组件分割代码</li><li>预加载：使用 <link rel="preload"> 预加载关键资源</li><li>预取：使用 <link rel="prefetch"> 预取可能访问的资源</li><li>压缩优化：HTML、CSS、JS 压缩，图片优化</li><li>CDN 加速：静态资源部署到 CDN</li><li>HTTP/2：使用 HTTP/2 多路复用提升加载速度</li><li>服务端性能：优化数据库查询、API 响应时间</li><li>监控指标：监控 TTFB、FCP、LCP 等性能指标</li><li>降级策略：服务端渲染失败时降级到客户端渲染</li><li>边缘计算：使用 Edge Functions（如 Vercel Edge、Cloudflare Workers）就近渲染</li></ol><hr><h2 id="面试题-4-题" tabindex="-1"><a class="header-anchor" href="#面试题-4-题" aria-hidden="true">#</a> 面试题（4 题）</h2><h3 id="_1-nestjs-全栈项目架构" tabindex="-1"><a class="header-anchor" href="#_1-nestjs-全栈项目架构" aria-hidden="true">#</a> 1. NestJS 全栈项目架构</h3><p>用 NestJS 做全栈项目，你如何设计架构？前后端如何组织？API 设计、认证鉴权、错误处理？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>\n\n\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr><h3 id="_2-ssr-方案选型" tabindex="-1"><a class="header-anchor" href="#_2-ssr-方案选型" aria-hidden="true">#</a> 2. SSR 方案选型</h3><p>给一个电商项目做 SSR，你会如何选型（Next.js/Nuxt.js/自研）？需要考虑哪些因素？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>\n\n\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr><h3 id="_3-ssr-性能问题排查" tabindex="-1"><a class="header-anchor" href="#_3-ssr-性能问题排查" aria-hidden="true">#</a> 3. SSR 性能问题排查</h3><p>SSR 项目出现性能问题（TTFB 过长），你的排查思路是什么？如何定位瓶颈？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>\n\n\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr><h3 id="_4-ssr-实践经验" tabindex="-1"><a class="header-anchor" href="#_4-ssr-实践经验" aria-hidden="true">#</a> 4. SSR 实践经验</h3><p>讲一个你做过的 SSR 项目：为什么选 SSR？遇到的核心难点？如何解决？最终效果如何？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>\n\n\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr>',115),r={},a=(0,e(3744).Z)(r,[["render",function(l,i){return s}]])}}]);