"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[4431],{2730:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-0e7c1d46",path:"/react/react17.html",title:"十五分钟读懂 React 17",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"关联面试卡（快速跳转）",slug:"关联面试卡-快速跳转",children:[]},{level:2,title:"一、全新的 JSX 转换",slug:"一、全新的-jsx-转换",children:[]},{level:2,title:"二、事件委托的变更",slug:"二、事件委托的变更",children:[]},{level:2,title:"三、事件系统相关更改",slug:"三、事件系统相关更改",children:[]},{level:2,title:"四、去除事件池",slug:"四、去除事件池",children:[]},{level:2,title:"五、副作用清理时间",slug:"五、副作用清理时间",children:[]},{level:2,title:"六、返回一致的 undefined 错误",slug:"六、返回一致的-undefined-错误",children:[]},{level:2,title:"七、原生组件栈",slug:"七、原生组件栈",children:[]},{level:2,title:"八、移除私有导出",slug:"八、移除私有导出",children:[]},{level:2,title:"九、启发式更新算法更新",slug:"九、启发式更新算法更新",children:[]}],git:{updatedTime:1770135605e3},filePathRelative:"react/react17.md"}},3023:(n,a,s)=>{s.r(a),s.d(a,{default:()=>kn});var e=s(6252);const t=(0,e._)("h1",{id:"十五分钟读懂-react-17",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#十五分钟读懂-react-17","aria-hidden":"true"},"#"),(0,e.Uk)(" 十五分钟读懂 React 17")],-1),p=(0,e._)("h2",{id:"关联面试卡-快速跳转",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#关联面试卡-快速跳转","aria-hidden":"true"},"#"),(0,e.Uk)(" 关联面试卡（快速跳转）")],-1),c=(0,e.Uk)("技术卡："),o=(0,e._)("code",null,"tech__react",-1),l=(0,e.Uk)("性能方法论："),r=(0,e._)("code",null,"tech__performance",-1),u=(0,e.uE)('<p>作为时下最火的前端框架之一，React 每次发版都会带来创新的改变，如 React 最早提出虚拟 DOM、React 16 引入 fiber 架构，再到后来 React 16.8 提出令人耳目一新的 Hooks，这些创新也是很多人推崇 React 的一个重要原因。然而，到了 React 17，rc 发布日志上竟然说这次版本最大的特点就是<strong>无新特性</strong>，从目前来说，这个日志是让很多人失望了。</p><p>这么多人对这次发版失望，那 React 17 就真的没什么好说的吗？显然不是，至少我认为不是的，从长远来看，无论是项目角度，还是源码学习角度，作为一个资深 reactress，我还是有很多东西要学习的。</p><p>首先面对用户的更改，React 官网上说的很详细了。如果你是一个 React 开发者，并且不想永远停留在老版本，想深入了解 React 17，想知道新版本对你开发的影响，那接下来我们来聊聊应该从哪些角度。</p><h2 id="一、全新的-jsx-转换" tabindex="-1"><a class="header-anchor" href="#一、全新的-jsx-转换" aria-hidden="true">#</a> 一、全新的 JSX 转换</h2><p>React 17 以前，React 中如果使用 JSX，则必须像下面这样导入 React，否则会报错，这是因为<strong>旧的 JSX 转换</strong>会把 JSX 转换为 <code>React.createElement(...)</code> 调用。</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">app </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a98398065494902956f3a1ef600a6ee~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20201110172720403"></p>',7),i=(0,e.Uk)("当然，这并不完美，除了增加了学习成本，还有无法做到的"),k={href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Freactjs%2Frfcs%2Fblob%2Fcreatelement-rfc%2Ftext%2F0000-create-element-changes.md%23motivation",target:"_blank",rel:"noopener noreferrer"},d=(0,e.Uk)("性能优化和简化"),b=(0,e.Uk)("， 如 createElement 里还要动态做 children 的拼接、依赖于 React 的导入等等。"),m=(0,e.uE)('<p>而 React 17 带来了改变，可以让我们单独使用 JSX 而无需引入 React。这是因为新的 JSX 转换<strong>不会将 JSX 转换为 React.createElement</strong>，而是自动从 React 的 package 中引入新的入口函数并调用。另外此次升级不会改变 JSX 语法，旧的 JSX 转换也将继续工作。</p><h2 id="二、事件委托的变更" tabindex="-1"><a class="header-anchor" href="#二、事件委托的变更" aria-hidden="true">#</a> 二、事件委托的变更</h2><p>在 React 16 或更早版本中，React 会由于事件委托对大多数事件执行 <code>document.addEventListener()</code>。但是一旦你想要局部使用 React，那么 React 中的事件会影响全局，如下面这个例子，当把 React 和 jQuery 一起使用，那么当点击 input 的时候，document 上和 React 不相关的事件也会被触发，这符合 React 的预期，但是并不符合用户的预期。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c339f24dedb4be5855739e85175ee95~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20201110151901137"></p><p>令人开心的是，这次的 React 17 就解决了这个问题~，这次 React 不再将事件添加在<code>document</code> 上，而是添加到渲染 React 树的根 DOM 容器中：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">const</span> rootNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;root&#39;</span><span class="token punctuation">)</span>\nReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> rootNode<span class="token punctuation">)</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这种改变不仅方便了局部使用 React 的项目，还可以用于项目的逐步升级，如一部分使用 React 18，另一部分使用 React 19，事件是分开的，这样也就不会相互影响。当然这并不是鼓励大家在一个项目中使用多个 React 版本，而只是作为一种临时处理的过渡~</p><p>好了，如果你只是励志做个普通工程师，可以跳到下个小章节看了，如果是 Reactress，继续往下看：</p>',8),g=(0,e.Uk)("下图形象描述了这次的变更，图片来自 React 官网"),h={href:"https://link.juejin.cn/?target=https%3A%2F%2Freact.docschina.org%2Fblog%2F2020%2F10%2F20%2Freact-v17.html",target:"_blank",rel:"noopener noreferrer"},f=(0,e.Uk)("react.docschina.org/blog/2020/1…"),R=(0,e._)("p",null,[(0,e._)("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1578b41a1a184b808b1607a174b1b6f1~tplv-k3u1fbpfcp-watermark.awebp",alt:"此图展示了 React 17 如何将事件连接到根节点而非 document"})],-1),v=(0,e.Uk)("自从其发布以来，React 一直自动进行事件委托。当触发 DOM 事件时，React 会找出调用的组件，然后 React 事件会在组件中向上 “冒泡”。这被称为"),_={href:"https://link.juejin.cn/?target=https%3A%2F%2Fdavidwalsh.name%2Fevent-delegate",target:"_blank",rel:"noopener noreferrer"},F=(0,e.Uk)("事件委托"),x=(0,e.Uk)("。除了在大型应用程序上具有性能优势外，它还使添加类似于 "),j={href:"https://link.juejin.cn/?target=https%3A%2F%2Ftwitter.com%2Fdan_abramov%2Fstatus%2F1200118229697486849",target:"_blank",rel:"noopener noreferrer"},w=(0,e.Uk)("replaying events"),U=(0,e.Uk)(" 这样的新特性变得更加容易。"),E=(0,e._)("p",null,"事件委托，也就是我们通常提到的事件代理机制，这种机制不会把时间处理函数直接绑定在真实的节点上，而是把所有的事件绑定到结构的最外层，使用一个统一的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射表里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升。",-1),y=(0,e._)("h2",{id:"三、事件系统相关更改",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#三、事件系统相关更改","aria-hidden":"true"},"#"),(0,e.Uk)(" 三、事件系统相关更改")],-1),S=(0,e._)("p",null,"除了事件委托这种比较大的更改，事件系统上还发生了一些小的更改，",-1),A=(0,e.Uk)("与以往不同，React 17 中"),C=(0,e._)("code",null,"onScroll",-1),W=(0,e.Uk)(" 事件不再冒泡，以防止"),J={href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fissues%2F15723",target:"_blank",rel:"noopener noreferrer"},q=(0,e.Uk)("出现常见的混淆"),X=(0,e.Uk)("。"),M=(0,e.uE)("<p>React 的 <code>onFocus</code> 和 <code>onBlur</code> 事件已在底层切换为原生的 <code>focusin</code> 和 <code>focusout</code> 事件。它们更接近 React 现有行为，有时还会提供额外的信息。</p><p>捕获事件（例如，<code>onClickCapture</code>）现在使用的是实际浏览器中的捕获监听器。</p><p>这些更改会使 React 与浏览器行为更接近，并提高了互操作性。</p>",3),B=(0,e._)("p",null,"注意：",-1),D=(0,e.Uk)("尽管 React 17 "),L=(0,e._)("strong",null,"底层",-1),N=(0,e.Uk)("已将 "),O=(0,e._)("code",null,"onFocus",-1),T=(0,e.Uk)(" 事件从 "),I=(0,e._)("code",null,"focus",-1),V=(0,e.Uk)(" 切换为 "),H=(0,e._)("code",null,"focusin",-1),z=(0,e.Uk)("，但请注意，这并未影响冒泡行为。在 React 中，"),P=(0,e._)("code",null,"onFocus",-1),Q=(0,e.Uk)(" 事件总是冒泡的，在 React 17 中会继续保持，因为通常它是一个更有用的默认值。请参阅 "),Y={href:"https://link.juejin.cn/?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fstrange-albattani-7tqr7%3Ffile%3D%2Fsrc%2FApp.js",target:"_blank",rel:"noopener noreferrer"},Z=(0,e.Uk)("sandbox"),G=(0,e.Uk)("，以了解为不同特定用例添加不同检查。"),K=(0,e.uE)('<h2 id="四、去除事件池" tabindex="-1"><a class="header-anchor" href="#四、去除事件池" aria-hidden="true">#</a> 四、去除事件池</h2><p>在 React 17 以前，如果想要用异步的方式使用事件 e，则必须先调用调用 <code>e.persist()</code> 才可以，这是因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 <code>null</code>。如下面的例子：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">FunctionComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">[</span>val<span class="token punctuation">,</span> setVal<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">const</span> <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">// setVal(e.target.value);</span>\n    <span class="token comment">// React 17以前，如果想用异步的方式使用事件e，必须要加上下面的e.persist()才可以</span>\n    <span class="token comment">// e.persist();</span>\n    <span class="token comment">// setVal(data =&gt; e.target.value);</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>border<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>val<span class="token punctuation">}</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleChange<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>但是这种使用方式有点抽象，经常会让对 React 不太熟悉的开发者懵掉，但是值得开心的是，React 17 中移除了 “event pooling（事件池）“，因为以前加入事件池的概念是为了提升旧浏览器的性能，对于现代浏览器来说，已经不需要了。因此，上面的代码中不使用 e.persist();也能达到预期效果。</p><h2 id="五、副作用清理时间" tabindex="-1"><a class="header-anchor" href="#五、副作用清理时间" aria-hidden="true">#</a> 五、副作用清理时间</h2><p>React 17 以前，当组件被卸载时，useEffect 和 useLayoutEffect 的清理函数都是同步运行，但是对于大型应用程序来说，这不是理想选择，因为同步会减缓屏幕的过渡（例如，切换标签），因此<strong>React 17 中的 useEffect 的清理函数异步执行</strong>，也就是说如果要卸载组件，则清理会在屏幕更新后运行。如果你某些情况下你仍然希望依靠同步执行，可以用 <code>useLayoutEffect</code>。</p><p>当然 React 17 中的 useEffect 的清理函数异步执行之后，有一个隐患：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  someRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">someSetupMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    someRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">someCleanupMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>问题在于 <code>someRef.current</code> 是可变的，因此在运行清除函数时，它可能已经设置为 <code>null</code>。解决方案是在副作用<strong>内部</strong>存储会发生变化的值：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> instance <span class="token operator">=</span> someRef<span class="token punctuation">.</span>current\n  instance<span class="token punctuation">.</span><span class="token function">someSetupMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    instance<span class="token punctuation">.</span><span class="token function">someCleanupMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n复制代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>',10),$=(0,e.Uk)("我们不希望此问题对大家造成影响，我们提供了 "),nn={href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Ftree%2Fmaster%2Fpackages%2Feslint-plugin-react-hooks",target:"_blank",rel:"noopener noreferrer"},an=(0,e._)("code",null,"eslint-plugin-react-hooks/exhaustive-deps",-1),sn=(0,e.Uk)(" 的 lint 规则"),en=(0,e.Uk)("（请确保在项目中使用它）会对此情况发出警告。"),tn=(0,e.uE)('<h2 id="六、返回一致的-undefined-错误" tabindex="-1"><a class="header-anchor" href="#六、返回一致的-undefined-错误" aria-hidden="true">#</a> 六、返回一致的 undefined 错误</h2><p>在 React 16 及更早版本中，返回 <code>undefined</code> 始终是一个错误，当然这是 React 的预期，但是由于编码错误 ，<code>forwardRef</code> 和 <code>memo</code> 组件的返回值是 undefined 的时候没有做为错误，React 17 中修复了这个问题。React 中要求对于不想进行任何渲染的时候返回 <code>null</code>。</p><h2 id="七、原生组件栈" tabindex="-1"><a class="header-anchor" href="#七、原生组件栈" aria-hidden="true">#</a> 七、原生组件栈</h2><p><strong>在 React 17 中，使用了不同的机制生成组件调用栈，该机制会将它们与常规的原生 JavaScript 调用栈缝合在一起。这使得你可以在生产环境中获得完全符号化的 React 组件调用栈信息。</strong></p><h2 id="八、移除私有导出" tabindex="-1"><a class="header-anchor" href="#八、移除私有导出" aria-hidden="true">#</a> 八、移除私有导出</h2>',5),pn=(0,e.Uk)("React 17 删除了一些以前暴露给其他项目的 React 内部组件。特别是，"),cn={href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnecolas%2Freact-native-web",target:"_blank",rel:"noopener noreferrer"},on=(0,e.Uk)("React Native for Web"),ln=(0,e.Uk)(" 过去常常依赖于事件系统的某些内部组件，但这种依赖关系很脆弱且经常被破坏。"),rn=(0,e.uE)('<p><strong>在 React 17 中，这些私有导出已被移除。据我们所知，React Native for Web 是唯一使用它们的项目，它们已经完成了向不依赖那些私有导出函数的其他方法迁移。</strong></p><h2 id="九、启发式更新算法更新" tabindex="-1"><a class="header-anchor" href="#九、启发式更新算法更新" aria-hidden="true">#</a> 九、启发式更新算法更新</h2><p>React 16 开始替换掉了<code>Stack Reconciler</code>，开始使用启发式算法架构的的<code>Fiber Reconciler</code>。那么为什么要发生这个改变呢？</p><p>React 的 killer feature： virtual dom</p><blockquote><ul><li>React15.x - Stack Reconciler</li><li>React16 - Fiber Reconciler</li><li>React17 - Fiber Reconciler (进阶版 - 优先级区间)</li></ul></blockquote><ol><li><p>为什么需要 fiber</p><p>对于大型项目，组件树会很大，这个时候递归遍历的成本就会很高，会造成主线程被持续占用，结果就是主线程上的布局、动画等周期性任务就无法立即得到处理，造成视觉上的卡顿，影响用户体验。</p></li><li><p>任务分解的意义</p><p>解决上面的问题</p></li><li><p>增量渲染（把渲染任务拆分成块，匀到多帧）</p></li><li><p>更新时能够暂停，终止，复用渲染任务</p></li><li><p>给不同类型的更新赋予<strong>优先级</strong></p></li><li><p>并发方面新的基础能力</p></li><li><p><strong>更流畅</strong></p></li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af337110041b4b9a82d269a0668a69e7~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20190213100742491"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c55f16195371438682f8c5b5a5b075cd~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20190213100810277"></p><p>React 17 中更新了启发式更新算法，具体表现为曾经用于标记 fiber 节点更新优先级的 expirationTime 换成了为 lanes，前者为普通数字，而后者则为 32 位的二进制，了解二进制运算的都比较熟悉了，这种二进制的 lanes 是可以指定几个优先级的，而不是像以前 expirationTime 只能标记一个。</p><p>之所以做这种改变，原因就是在于<code>expirationTimes模型</code>不能满足<code>IO操作</code>（Suspense），Suspense 用法如下：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">React.Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Loading</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Content</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">React.Suspense</span></span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>',11),un={},kn=(0,s(3744).Z)(un,[["render",function(n,a){const s=(0,e.up)("RouterLink"),un=(0,e.up)("ExternalLinkIcon");return(0,e.wg)(),(0,e.iD)(e.HY,null,[t,p,(0,e._)("ul",null,[(0,e._)("li",null,[c,(0,e.Wm)(s,{to:"/interview-prep/tech__react.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,e.w5)((()=>[o])),_:1})]),(0,e._)("li",null,[l,(0,e.Wm)(s,{to:"/interview-prep/tech__performance.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,e.w5)((()=>[r])),_:1})])]),u,(0,e._)("p",null,[i,(0,e._)("a",k,[d,(0,e.Wm)(un)]),b]),m,(0,e._)("p",null,[g,(0,e._)("a",h,[f,(0,e.Wm)(un)])]),R,(0,e._)("p",null,[v,(0,e._)("a",_,[F,(0,e.Wm)(un)]),x,(0,e._)("a",j,[w,(0,e.Wm)(un)]),U]),E,y,S,(0,e._)("p",null,[A,C,W,(0,e._)("a",J,[q,(0,e.Wm)(un)]),X]),M,(0,e._)("blockquote",null,[B,(0,e._)("p",null,[D,L,N,O,T,I,V,H,z,P,Q,(0,e._)("a",Y,[Z,(0,e.Wm)(un)]),G])]),K,(0,e._)("p",null,[$,(0,e._)("a",nn,[an,sn,(0,e.Wm)(un)]),en]),tn,(0,e._)("p",null,[pn,(0,e._)("a",cn,[on,(0,e.Wm)(un)]),ln]),rn],64)}]])}}]);