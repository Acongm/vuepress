"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[5273],{8029:(n,s,a)=>{a.r(s),a.d(s,{data:()=>t});const t={key:"v-14352b26",path:"/interview-prep/tech__react.html",title:"React（机制/性能/工程实践）",lang:"zh-CN",frontmatter:{id:"tech__react",type:"tech",title:"React（机制/性能/工程实践）",mastery:"not_started",tags:["react","hooks","concurrent","performance"],projects:["project__dji-rms","project__xdr-dashboard-report"],source_refs:[{source:"resume",file:"docs/job-description/web前端开发工程师-彭聪.md",anchor:"TODO"}],seed_refs:[{source:"outline",file:"docs/job-description/web前端开发工程师-彭聪-面试技术大纲.md",anchor:"TODO"}],updated_at:"2025-12-20T00:00:00.000Z"},excerpt:"",headers:[{level:2,title:"摘要（Auto）",slug:"摘要-auto",children:[]},{level:2,title:"建议追问（Auto）",slug:"建议追问-auto",children:[]},{level:2,title:"关联卡片",slug:"关联卡片",children:[]},{level:2,title:"在我项目中的角色与使用场景",slug:"在我项目中的角色与使用场景",children:[]},{level:2,title:"原理简述",slug:"原理简述",children:[]},{level:2,title:"对比表格",slug:"对比表格",children:[]},{level:2,title:"模拟问答",slug:"模拟问答",children:[]},{level:2,title:"手写代码区",slug:"手写代码区",children:[]},{level:2,title:"我的补充（Manual）",slug:"我的补充-manual",children:[]},{level:2,title:"复盘与反思（Learnings）",slug:"复盘与反思-learnings",children:[]},{level:2,title:"面试官追问（面试官视角）",slug:"面试官追问-面试官视角",children:[]}],git:{updatedTime:1769877604e3},filePathRelative:"interview-prep/tech__react.md"}},6854:(n,s,a)=>{a.r(s),a.d(s,{default:()=>k});var t=a(6252);const e=(0,t.uE)('<h2 id="摘要-auto" tabindex="-1"><a class="header-anchor" href="#摘要-auto" aria-hidden="true">#</a> 摘要（Auto）</h2><ul><li>生成时间：2025-12-20</li><li>简历中出现的项目标题（提取）：大疆用户中心重构 / 大疆售后 RMS 系统重构 / 跨平台公告插件系统 / 大疆 DevOps 平台维护 / XDR 系统 - 魔方大屏 + 报表</li><li>面试大纲关键词（提取 Top10）：1）大疆用户中心重构：性能优化 + HTTP 原理 + Webpack 架构 / 性能指标与方法论 / 简历可落地点（结合你的“优化四板斧”） / HTTP 常考点（从“为什么变快”倒推） / Webpack 架构（工程化面试常考） / 按优化顺序，把方案“串起来”（排查 → 定位 → 选择 → 验证） / 0. 排查与基线（先把问题“量化”） / 1. 先保“可见”——骨架屏预渲染（直接拉低 LCP） / 2. 再减“阻塞”——关键渲染路径（CRP）梳理：CSS/字体/首图优先级 / 3. 再降“下载与解析成本”——更小的包体与更少的无效代码</li></ul><h2 id="建议追问-auto" tabindex="-1"><a class="header-anchor" href="#建议追问-auto" aria-hidden="true">#</a> 建议追问（Auto）</h2><ul><li>你为什么在该项目/场景里选择这个方案？替代方案为何不选？</li><li>最大一次事故/踩坑是什么？如何定位与回滚？</li><li>如果重做：架构/边界/工程化会怎么调整？</li></ul><h2 id="关联卡片" tabindex="-1"><a class="header-anchor" href="#关联卡片" aria-hidden="true">#</a> 关联卡片</h2>',5),l=(0,t.Uk)("项目： "),p=(0,t._)("code",null,"project__dji-user-center",-1),o=(0,t._)("code",null,"project__dji-rms",-1),c=(0,t._)("code",null,"project__xdr-dashboard-report",-1),r=(0,t.Uk)("性能方法论： "),i=(0,t._)("code",null,"tech__performance",-1),u=(0,t.uE)('<h2 id="在我项目中的角色与使用场景" tabindex="-1"><a class="header-anchor" href="#在我项目中的角色与使用场景" aria-hidden="true">#</a> 在我项目中的角色与使用场景</h2><ul><li>用户中心 / 中后台复杂表单：关注“<strong>渲染性能 + 可维护性</strong>”，避免组件树失控导致的频繁重渲染与状态错乱。</li><li>大屏/报表：关注“<strong>高频更新 + 大量可视化组件</strong>”，重点治理长任务、列表/图表渲染与内存增长。</li><li>我负责的落地： <ul><li>组件分层（容器/展示/领域组件）、状态归属（本地/全局/服务端缓存）与边界约束。</li><li>性能治理：渲染链路定位、memo 策略、虚拟列表、分片渲染、事件与订阅收敛。</li><li>工程实践：错误边界、日志上报、可观测性埋点与“可回滚”的发布策略。</li></ul></li></ul><h2 id="原理简述" tabindex="-1"><a class="header-anchor" href="#原理简述" aria-hidden="true">#</a> 原理简述</h2><p>React 的关键能力可以用“<strong>声明式 UI + 可预测更新 + 可组合抽象</strong>”来概括。</p><ul><li><strong>声明式</strong>：你描述“状态 → UI”的映射，React 负责把变化映射到 DOM 更新。</li><li><strong>Diff/Reconciliation</strong>：通过对比前后两棵虚拟树，找出最小更新集（关键是“同层比较 + key 决定身份”）。</li><li><strong>Fiber</strong>（React 16+）：把渲染拆成可中断/可恢复的工作单元（work），为并发与优先级调度提供基础。</li><li><strong>并发特性（React 18）</strong>： <ul><li>自动批处理（batching）减少无意义的多次 render。</li><li><code>startTransition</code> 把“非紧急更新”降级，提升交互响应。</li><li><code>Suspense</code> 让数据/代码加载可以用一致的“等待边界”表达。</li></ul></li></ul><p>性能的核心心智：</p><ul><li>render 不是坏事，<strong>“无效 render”</strong> 才是问题（render 频率、render 成本、commit 成本）。</li><li>优化顺序：先定位（Profiler/Performance）→ 再缩小影响面（状态归属/订阅）→ 再降成本（memo/虚拟化/分片）。</li></ul><h2 id="对比表格" tabindex="-1"><a class="header-anchor" href="#对比表格" aria-hidden="true">#</a> 对比表格</h2><table><thead><tr><th>维度</th><th>React</th><th>Vue</th><th>Svelte</th></tr></thead><tbody><tr><td>核心模型</td><td>声明式 + 组件组合</td><td>模板 + 响应式</td><td>编译期消解框架运行时</td></tr><tr><td>性能手段</td><td>Fiber/并发、memo、虚拟化</td><td>响应式依赖追踪</td><td>编译输出更贴近原生</td></tr><tr><td>工程生态</td><td><strong>最丰富</strong>（状态/路由/组件库/测试）</td><td>完整、上手快</td><td>生态相对小</td></tr><tr><td>适用场景</td><td>中大型应用、团队协作复杂</td><td>中小到中大型均可</td><td>对体积/性能极致且可控场景</td></tr><tr><td>风险点</td><td>心智复杂（hooks/并发/性能）</td><td>模板约束/TS 体验差异</td><td>生态与招聘面更窄</td></tr></tbody></table><p>在我面试表达里的“决策口径”：</p><ul><li>团队与存量决定上限：已有 React 生态 + 组件资产，React 是最稳的选择。</li><li>若重点是“把性能治理体系做起来”，React 需要更强的<strong>边界与规范</strong>（状态归属、渲染订阅、memo 策略）。</li></ul><h2 id="模拟问答" tabindex="-1"><a class="header-anchor" href="#模拟问答" aria-hidden="true">#</a> 模拟问答</h2><ul><li>[ ] Q1：为什么 <code>key</code> 不能用 index？什么时候可以用？ <ul><li>结论：当列表会插入/删除/排序时，index 会让 React 误判“身份”，导致状态错位与额外 DOM 操作。</li><li>可以用的例外：静态列表（不会增删改顺序）且无局部状态依赖。</li></ul></li><li>[ ] Q2：<code>useEffect</code> 为什么会“执行两次”？怎么解释给面试官？ <ul><li>React 18 开发模式下 <code>StrictMode</code> 会对部分副作用做“额外调用”以暴露不纯副作用（生产不会）。</li><li>正确做法：把副作用写成幂等，或把“仅一次初始化”移动到更合理的抽象（例如上层状态、服务端缓存层）。</li></ul></li><li>[ ] Q3：你怎么定位并解决“无效渲染”？ <ul><li>定位：React Profiler 看 commit 次数与耗时；再用 why-did-you-render/自定义日志定位触发源。</li><li>处理顺序：状态下沉/拆分 context → 订阅收敛（selector）→ <code>memo/useMemo/useCallback</code> → 虚拟列表/分片渲染。</li></ul></li><li>[ ] Q4：<code>startTransition</code> 解决的是什么问题？怎么用？ <ul><li>把“非紧急的 UI 更新”标注为 transition，让紧急交互（输入/点击反馈）优先。</li></ul></li></ul><h2 id="手写代码区" tabindex="-1"><a class="header-anchor" href="#手写代码区" aria-hidden="true">#</a> 手写代码区</h2><p>一个“可解释”的渲染订阅收敛示例（用 <code>useSyncExternalStore</code> 表达“按需订阅”）：</p><div class="language-tsx ext-tsx line-numbers-mode"><pre class="language-tsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useSyncExternalStore <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span>\n\n<span class="token keyword">type</span> <span class="token class-name">State</span> <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> text<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span>\n<span class="token keyword">let</span> state<span class="token operator">:</span> State <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">&#39;&#39;</span> <span class="token punctuation">}</span>\n<span class="token keyword">const</span> listeners <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">setState</span><span class="token punctuation">(</span>patch<span class="token operator">:</span> Partial<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>state<span class="token punctuation">,</span> <span class="token operator">...</span>patch <span class="token punctuation">}</span>\n  listeners<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">l</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function-variable function">listener</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  listeners<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> listeners<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">getSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> state\n<span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useStoreSelector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token function-variable function">selector</span><span class="token operator">:</span> <span class="token punctuation">(</span>s<span class="token operator">:</span> State<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> snap <span class="token operator">=</span> <span class="token function">useSyncExternalStore</span><span class="token punctuation">(</span>subscribe<span class="token punctuation">,</span> getSnapshot<span class="token punctuation">,</span> getSnapshot<span class="token punctuation">)</span>\n  <span class="token keyword">return</span> <span class="token function">selector</span><span class="token punctuation">(</span>snap<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 用法：组件只订阅自己需要的字段，减少无效渲染</span>\n<span class="token comment">// const count = useStoreSelector((s) =&gt; s.count);</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h2 id="我的补充-manual" tabindex="-1"><a class="header-anchor" href="#我的补充-manual" aria-hidden="true">#</a> 我的补充（Manual）</h2><p>（不会被脚本覆盖：踩坑、细节、反例、排查路径）</p><h2 id="复盘与反思-learnings" tabindex="-1"><a class="header-anchor" href="#复盘与反思-learnings" aria-hidden="true">#</a> 复盘与反思（Learnings）</h2><ul><li>如果重做会怎么改？</li></ul><h2 id="面试官追问-面试官视角" tabindex="-1"><a class="header-anchor" href="#面试官追问-面试官视角" aria-hidden="true">#</a> 面试官追问（面试官视角）</h2><ul><li>[ ] 为什么选这个方案？替代方案为什么不选？</li><li>[!] 最大一次事故/踩坑是什么？如何定位与回滚？</li><li>[ ] 如果重做会怎么改？</li></ul>',22),d={},k=(0,a(3744).Z)(d,[["render",function(n,s){const a=(0,t.up)("RouterLink");return(0,t.wg)(),(0,t.iD)(t.HY,null,[e,(0,t._)("ul",null,[(0,t._)("li",null,[l,(0,t._)("ul",null,[(0,t._)("li",null,[(0,t.Wm)(a,{to:"/interview-prep/project__dji-user-center.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,t.w5)((()=>[p])),_:1})]),(0,t._)("li",null,[(0,t.Wm)(a,{to:"/interview-prep/project__dji-rms.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,t.w5)((()=>[o])),_:1})]),(0,t._)("li",null,[(0,t.Wm)(a,{to:"/interview-prep/project__xdr-dashboard-report.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,t.w5)((()=>[c])),_:1})])])]),(0,t._)("li",null,[r,(0,t._)("ul",null,[(0,t._)("li",null,[(0,t.Wm)(a,{to:"/interview-prep/tech__performance.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,t.w5)((()=>[i])),_:1})])])])]),u],64)}]])},3744:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,t]of s)a[n]=t;return a}}}]);