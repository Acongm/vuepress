"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[4902],{8452:(l,i,e)=>{e.r(i),e.d(i,{data:()=>r});const r={key:"v-0f117841",path:"/job-description/lib/Framework.html",title:"技术点",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"React 16+ 各版本区别 & React 核心原理",slug:"react-16-各版本区别-react-核心原理",children:[]},{level:2,title:"Webpack 架构 & 与 Rollup、Vite 对比 & 核心原理",slug:"webpack-架构-与-rollup、vite-对比-核心原理",children:[]},{level:2,title:"性能优化流程 & 从浏览器请求链路解释“为什么这么优化”",slug:"性能优化流程-从浏览器请求链路解释-为什么这么优化",children:[]},{level:2,title:"微前端对比 & 各方案实现原理",slug:"微前端对比-各方案实现原理",children:[]},{level:2,title:"低代码 & 核心原理",slug:"低代码-核心原理",children:[]},{level:2,title:"热插拔插件系统对比 & 各方案实现原理差异",slug:"热插拔插件系统对比-各方案实现原理差异",children:[]},{level:2,title:"从 NestJS 全栈开发到 SSR & SSR 核心原理",slug:"从-nestjs-全栈开发到-ssr-ssr-核心原理",children:[]},{level:2,title:"从 Vue2 到 Vue3 & 核心原理",slug:"从-vue2-到-vue3-核心原理",children:[]},{level:2,title:"代码规范 & Umi/ESLint 规范为什么这样设计 & 如何落地",slug:"代码规范-umi-eslint-规范为什么这样设计-如何落地",children:[]}],git:{updatedTime:1768924334e3},filePathRelative:"job-description/lib/Framework.md"}},3850:(l,i,e)=>{e.r(i),e.d(i,{default:()=>s});const r=(0,e(6252).uE)('<h1 id="技术点" tabindex="-1"><a class="header-anchor" href="#技术点" aria-hidden="true">#</a> 技术点</h1><blockquote><p>使用方式建议：</p><ul><li>阅读时逐条勾选 <code>- [ ]</code> → <code>- [x]</code></li><li>若“能讲清原理 + 能落地实践 + 能回答追问”，再勾选该条</li></ul></blockquote><h2 id="react-16-各版本区别-react-核心原理" tabindex="-1"><a class="header-anchor" href="#react-16-各版本区别-react-核心原理" aria-hidden="true">#</a> React 16+ 各版本区别 &amp; React 核心原理</h2><ul><li>[ ] <strong>版本演进主线（必须能说清差异与收益）</strong><ul><li>[ ] React 16：Fiber 架构引入、Error Boundaries、Portal、Fragment</li><li>[ ] React 16.8：Hooks（状态/副作用/逻辑复用方式改变）</li><li>[ ] React 17：升级过渡（无破坏性为主）、事件委托从 <code>document</code> 下移（微前端更友好）</li><li>[ ] React 18：<code>createRoot</code>、Automatic Batching、并发渲染（可中断/可恢复）、<code>startTransition</code>、Suspense 更完善</li></ul></li><li>[ ] <strong>渲染机制（要能讲清一次更新的链路）</strong><ul><li>[ ] render phase vs commit phase：可中断/可重做 vs 不可中断</li><li>[ ] Scheduler 调度：优先级、时间切片、让出主线程的意义</li><li>[ ] 更新入队与优先级：lane（18 重点，至少理解“不同更新优先级不同”）</li></ul></li><li>[ ] <strong>Diff 核心规则（要能讲清 key 的真实价值）</strong><ul><li>[ ] 同层比较、类型不同直接替换、列表 diff 基本思路</li><li>[ ] key 的稳定性：为什么不能用 index（状态错位/复用错误）</li></ul></li><li>[ ] <strong>Hooks 原理与常见坑（必须掌握）</strong><ul><li>[ ] Hooks 依赖“调用顺序一致”的原因（链表/索引）</li><li>[ ] 闭包陷阱与依赖数组：何时需要 <code>useCallback/useMemo</code></li><li>[ ] StrictMode 下 effect 重复执行的目的与应对</li></ul></li><li>[ ] <strong>工程落地（能说清取舍与边界）</strong><ul><li>[ ] 性能：memo 化边界、虚拟列表、拆分渲染、并发下使用 transition 的适用场景</li><li>[ ] 可靠性：Error Boundary 的使用边界（无法捕获哪些错误）</li><li>[ ] 调试：React Profiler 定位重渲染的套路（谁在 render、为什么、如何修）</li></ul></li></ul><h2 id="webpack-架构-与-rollup、vite-对比-核心原理" tabindex="-1"><a class="header-anchor" href="#webpack-架构-与-rollup、vite-对比-核心原理" aria-hidden="true">#</a> Webpack 架构 &amp; 与 Rollup、Vite 对比 &amp; 核心原理</h2><ul><li>[ ] <strong>Webpack 总体架构（必须掌握）</strong><ul><li>[ ] Entry → Module Graph → Chunk Graph → Runtime → Emit 的构建链路</li><li>[ ] Loader vs Plugin：职责边界与典型使用场景</li><li>[ ] HMR：热更新边界（状态保持、回退策略）</li></ul></li><li>[ ] <strong>核心原理（能讲清“为什么这样设计”）</strong><ul><li>[ ] 依赖分析：如何解析 import/require 形成模块图</li><li>[ ] Code Splitting：动态 import 如何拆包、runtime 如何加载 chunk</li><li>[ ] Tree-shaking 条件：ESM 静态结构、<code>sideEffects</code>、为什么 CJS 难</li><li>[ ] 缓存与长期缓存：contenthash、runtime/manifest、filesystem cache</li></ul></li><li>[ ] <strong>与 Rollup 对比（库 vs 应用）</strong><ul><li>[ ] Rollup：库打包更强、输出更干净、tree-shaking 更激进的原因</li><li>[ ] Webpack：工程能力更全面（多资源类型、复杂应用场景）</li></ul></li><li>[ ] <strong>与 Vite 对比（开发态 vs 生产态）</strong><ul><li>[ ] Vite dev：原生 ESM + 依赖预构建（esbuild）实现秒启</li><li>[ ] Vite build：多用 Rollup，生产分包/共享依赖的策略如何选</li></ul></li><li>[ ] <strong>自测题（建议你写成可复用的答题模板）</strong><ul><li>[ ] 你能解释“为什么拆 runtime/commons 能提升缓存命中”吗？</li><li>[ ] 你能设计一个 chunk 划分方案并说明取舍吗？</li></ul></li></ul><h2 id="性能优化流程-从浏览器请求链路解释-为什么这么优化" tabindex="-1"><a class="header-anchor" href="#性能优化流程-从浏览器请求链路解释-为什么这么优化" aria-hidden="true">#</a> 性能优化流程 &amp; 从浏览器请求链路解释“为什么这么优化”</h2><ul><li>[ ] <strong>方法论（先量化后优化）</strong><ul><li>[ ] 指标体系：FCP/LCP/INP/CLS/TTFB 的含义与典型场景</li><li>[ ] 定位套路：网络 → 解析/编译 → 渲染 → JS 执行 → 框架渲染</li><li>[ ] 对照实验：基线、对比、回归（避免“优化错方向”）</li></ul></li><li>[ ] <strong>从请求链路讲清楚（高频面试点）</strong><ul><li>[ ] DNS/TCP/TLS/TTFB：CDN、keep-alive、HTTP/2/3 对性能的影响</li><li>[ ] 缓存：强缓存/协商缓存、<code>cache-control</code>、<code>etag</code>、静态资源 hash</li><li>[ ] 资源优先级：preload/prefetch、关键 CSS、字体加载策略</li><li>[ ] 压缩与传输：gzip/brotli、图片格式（webp/avif）与压缩策略</li></ul></li><li>[ ] <strong>工程落地清单</strong><ul><li>[ ] 构建：拆包、按路由/组件懒加载、产物体积分析、sourcemap 策略</li><li>[ ] 运行时：减少长任务、Web Worker、虚拟列表、事件节流与批处理</li><li>[ ] 监控：性能埋点、异常聚合、告警阈值、灰度与回滚策略</li></ul></li><li>[ ] <strong>自测题</strong><ul><li>[ ] 给你 Performance 面板：你能定位长任务并验证修复效果吗？</li><li>[ ] 你能解释“TTFB 不变但 LCP 变差”的可能原因吗？</li></ul></li></ul><h2 id="微前端对比-各方案实现原理" tabindex="-1"><a class="header-anchor" href="#微前端对比-各方案实现原理" aria-hidden="true">#</a> 微前端对比 &amp; 各方案实现原理</h2><ul><li>[ ] <strong>目标与边界（必须掌握）</strong><ul><li>[ ] 独立开发/部署、渐进迁移、技术栈隔离、统一基座治理</li><li>[ ] 典型治理项：路由、权限、埋点、错误隔离、资源加载、版本灰度</li></ul></li><li>[ ] <strong>方案对比（至少掌握 2~3 个）</strong><ul><li>[ ] qiankun / single-spa：基于生命周期 + 路由切换的核心思路</li><li>[ ] iframe：隔离强但性能/体验/通信成本的取舍</li><li>[ ] Module Federation：运行时加载远程模块、依赖共享（适合组件/模块共享）</li></ul></li><li>[ ] <strong>实现原理（要能讲清关键机制）</strong><ul><li>[ ] JS 沙箱：Proxy/快照/作用域隔离，如何防止全局污染</li><li>[ ] CSS 隔离：scoped、shadow dom、运行时前缀化的优缺点</li><li>[ ] 通信：事件总线、postMessage、共享状态（以及权限/版本治理）</li><li>[ ] 资源加载：HTML entry/脚本注入/预加载策略与性能取舍</li></ul></li><li>[ ] <strong>自测题</strong><ul><li>[ ] React 17 事件委托变化为什么更利于微前端共存？</li><li>[ ] 子应用崩溃如何做到降级、隔离、不影响主应用？</li></ul></li></ul><h2 id="低代码-核心原理" tabindex="-1"><a class="header-anchor" href="#低代码-核心原理" aria-hidden="true">#</a> 低代码 &amp; 核心原理</h2><ul><li>[ ] <strong>核心分层（必须掌握）</strong><ul><li>[ ] Schema/DSL：组件树、布局、属性、数据源、事件、动作（Action）</li><li>[ ] 渲染器：Schema → 运行时组件渲染（可插拔组件库）</li><li>[ ] 编辑器：拖拽/选中/对齐/画布缩放/撤销重做/多选</li><li>[ ] 运行时：表达式、条件渲染、动态绑定、权限与灰度</li></ul></li><li>[ ] <strong>原理点（面试常问）</strong><ul><li>[ ] DSL 如何演进：版本兼容、迁移策略、变更影响面</li><li>[ ] 数据流：依赖图/计算属性、避免循环依赖、性能优化</li><li>[ ] 扩展机制：自定义组件/动作/面板扩展与协议设计</li><li>[ ] 安全：表达式执行沙箱、白名单能力、资源限制</li></ul></li><li>[ ] <strong>自测题</strong><ul><li>[ ] 你能抽象一个“CRUD 表单 + 列表 + 弹窗”的最小 Schema 吗？</li><li>[ ] 新加一个自定义组件：编辑态与运行态分别要做什么？</li></ul></li></ul><h2 id="热插拔插件系统对比-各方案实现原理差异" tabindex="-1"><a class="header-anchor" href="#热插拔插件系统对比-各方案实现原理差异" aria-hidden="true">#</a> 热插拔插件系统对比 &amp; 各方案实现原理差异</h2><ul><li>[ ] <strong>插件系统四件套（必须掌握）</strong><ul><li>[ ] 生命周期：register/activate/deactivate/dispose</li><li>[ ] 扩展点：菜单、路由、命令、UI Slot、数据源、Hook</li><li>[ ] 依赖与版本：依赖声明、冲突检测、semver、灰度与回滚</li><li>[ ] 隔离与安全：权限、沙箱、资源限制、错误边界</li></ul></li><li>[ ] <strong>横向对比维度（答题口径统一）</strong><ul><li>[ ] 加载形态：编译期（静态）vs 运行时（动态）vs 远程模块</li><li>[ ] 隔离能力：同进程（快）vs iframe/worker（隔离强）</li><li>[ ] API 设计：面向能力（命令/服务）vs 面向组件（slot/容器）</li><li>[ ] 可观测性：错误、耗时、资源占用、降级策略、审计</li></ul></li><li>[ ] <strong>自测题</strong><ul><li>[ ] 设计“菜单 + 路由 + 页面卡片”插件：你能定义扩展点契约吗？</li><li>[ ] 插件升级导致崩溃：如何快速回滚并保证兼容？</li></ul></li></ul><h2 id="从-nestjs-全栈开发到-ssr-ssr-核心原理" tabindex="-1"><a class="header-anchor" href="#从-nestjs-全栈开发到-ssr-ssr-核心原理" aria-hidden="true">#</a> 从 NestJS 全栈开发到 SSR &amp; SSR 核心原理</h2><ul><li>[ ] <strong>SSR 链路（必须掌握）</strong><ul><li>[ ] 请求进来 → 路由匹配 → 数据预取 → renderToString/stream → 返回 HTML → hydrate 接管</li><li>[ ] BFF 思维：接口聚合、减少瀑布流、契合页面数据形态</li></ul></li><li>[ ] <strong>关键原理（要能讲清“为何会快/为何会慢”）</strong><ul><li>[ ] Hydration：一致性要求，为什么 mismatch 会出问题</li><li>[ ] Streaming SSR：边生成边输出，与 Suspense 的关系与收益</li><li>[ ] 缓存：页面缓存/片段缓存/CDN/边缘渲染，如何设计失效策略</li></ul></li><li>[ ] <strong>常见坑</strong><ul><li>[ ] Node 与浏览器环境差异（window/document）、副作用处理</li><li>[ ] 双端数据一致性：时区、随机数、时间戳导致 mismatch</li><li>[ ] SSR 不等于“绝对更快”：TTFB 与 hydration 成本如何平衡</li></ul></li><li>[ ] <strong>自测题</strong><ul><li>[ ] 你能解释“SSR 改善首屏但可能拖慢交互就绪”的原因吗？</li><li>[ ] 你能设计 SSR 的缓存分层与回源策略吗？</li></ul></li></ul><h2 id="从-vue2-到-vue3-核心原理" tabindex="-1"><a class="header-anchor" href="#从-vue2-到-vue3-核心原理" aria-hidden="true">#</a> 从 Vue2 到 Vue3 &amp; 核心原理</h2><ul><li>[ ] <strong>变化主线（必须掌握）</strong><ul><li>[ ] 响应式：Vue2 <code>defineProperty</code> → Vue3 <code>Proxy</code>（能力与性能差异）</li><li>[ ] 编译优化：patch flag、静态提升、tree-shaking（为什么更快更小）</li><li>[ ] 组合式 API：逻辑复用方式与工程收益（对比 mixin）</li></ul></li><li>[ ] <strong>原理点（能讲清响应式基本模型）</strong><ul><li>[ ] 依赖收集与触发更新：effect/track/trigger 的核心思路</li><li>[ ] patch 算法：编译标记如何减少运行时 diff 成本</li></ul></li><li>[ ] <strong>自测题</strong><ul><li>[ ] 为什么 Proxy 让“新增属性也可响应”？</li><li>[ ] 组合式 API 相比 mixin 的收益与坑分别是什么？</li></ul></li></ul><h2 id="代码规范-umi-eslint-规范为什么这样设计-如何落地" tabindex="-1"><a class="header-anchor" href="#代码规范-umi-eslint-规范为什么这样设计-如何落地" aria-hidden="true">#</a> 代码规范 &amp; Umi/ESLint 规范为什么这样设计 &amp; 如何落地</h2><ul><li>[ ] <strong>规范的目标（必须掌握）</strong><ul><li>[ ] 一致性：减少风格争议，提升协作效率</li><li>[ ] 可维护性：限制高风险写法，降低 bug 密度</li><li>[ ] 工程化：把质量门禁前置到工具链与 CI</li></ul></li><li>[ ] <strong>规则背后的“为什么”（能讲清工程风险）</strong><ul><li>[ ] ESLint：防 bug（未使用变量、Promise 误用、隐式 any 等）</li><li>[ ] Prettier：只管格式，降低团队摩擦</li><li>[ ] Umi 约定：目录/路由/工程约束带来的协作收益与边界</li></ul></li><li>[ ] <strong>落地方案（建议写成团队规范 SOP）</strong><ul><li>[ ] 本地：editorconfig + prettier + eslint（必要时加 stylelint）</li><li>[ ] 提交：lint-staged + husky（只检查增量，保证体验）</li><li>[ ] CI：全量 lint + typecheck + 单测；失败即阻断</li><li>[ ] 例外机制：禁用规则的规范、技术债登记、规则分级（error/warn）</li></ul></li><li>[ ] <strong>自测题</strong><ul><li>[ ] 你能把“为什么要禁用某些 any/未处理 Promise”讲成可量化风险吗？</li><li>[ ] 老项目迁移新规范：你能设计渐进策略避免一次性爆炸吗？</li></ul></li></ul>',20),t={},s=(0,e(3744).Z)(t,[["render",function(l,i){return r}]])},3744:(l,i)=>{i.Z=(l,i)=>{const e=l.__vccOpts||l;for(const[l,r]of i)e[l]=r;return e}}}]);