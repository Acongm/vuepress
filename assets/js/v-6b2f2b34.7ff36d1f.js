"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[1540],{4977:(e,l,t)=>{t.r(l),t.d(l,{data:()=>i});const i={key:"v-6b2f2b34",path:"/interview-prep/matrix__monorepo-lerna-nx.html",title:"Monorepo 选型：Lerna vs Nx",lang:"zh-CN",frontmatter:{id:"matrix__monorepo-lerna-nx",type:"matrix",title:"Monorepo 选型：Lerna vs Nx",mastery:"not_started",tags:["monorepo","lerna","nx"],projects:["project__dji-rms"],source_refs:[{source:"resume",file:"docs/job-description/web前端开发工程师-彭聪.md",anchor:"TODO"}],seed_refs:[{source:"outline",file:"docs/job-description/web前端开发工程师-彭聪-面试技术大纲.md",anchor:"TODO"}],updated_at:"2025-12-20T00:00:00.000Z"},excerpt:"",headers:[{level:2,title:"摘要（Auto）",slug:"摘要-auto",children:[]},{level:2,title:"建议追问（Auto）",slug:"建议追问-auto",children:[]},{level:2,title:"关联卡片",slug:"关联卡片",children:[]},{level:2,title:"在我项目中的角色与使用场景",slug:"在我项目中的角色与使用场景",children:[]},{level:2,title:"原理简述",slug:"原理简述",children:[]},{level:2,title:"对比表格",slug:"对比表格",children:[]},{level:2,title:"模拟问答",slug:"模拟问答",children:[]},{level:2,title:"手写代码区",slug:"手写代码区",children:[]},{level:2,title:"我的补充（Manual）",slug:"我的补充-manual",children:[]},{level:2,title:"复盘与反思（Learnings）",slug:"复盘与反思-learnings",children:[]},{level:2,title:"面试官追问（面试官视角）",slug:"面试官追问-面试官视角",children:[]}],git:{updatedTime:1770275296e3},filePathRelative:"interview-prep/matrix__monorepo-lerna-nx.md"}},7612:(e,l,t)=>{t.r(l),t.d(l,{default:()=>h});var i=t(6252);const r=(0,i.uE)('<h2 id="摘要-auto" tabindex="-1"><a class="header-anchor" href="#摘要-auto" aria-hidden="true">#</a> 摘要（Auto）</h2><ul><li>生成时间：2025-12-20</li><li>简历中出现的项目标题（提取）：大疆用户中心重构 / 大疆售后 RMS 系统重构 / 跨平台公告插件系统 / 大疆 DevOps 平台维护 / XDR 系统 - 魔方大屏 + 报表</li><li>面试大纲关键词（提取 Top10）：1）大疆用户中心重构：性能优化 + HTTP 原理 + Webpack 架构 / 性能指标与方法论 / 简历可落地点（结合你的“优化四板斧”） / HTTP 常考点（从“为什么变快”倒推） / Webpack 架构（工程化面试常考） / 按优化顺序，把方案“串起来”（排查 → 定位 → 选择 → 验证） / 0. 排查与基线（先把问题“量化”） / 1. 先保“可见”——骨架屏预渲染（直接拉低 LCP） / 2. 再减“阻塞”——关键渲染路径（CRP）梳理：CSS/字体/首图优先级 / 3. 再降“下载与解析成本”——更小的包体与更少的无效代码</li></ul><h2 id="建议追问-auto" tabindex="-1"><a class="header-anchor" href="#建议追问-auto" aria-hidden="true">#</a> 建议追问（Auto）</h2><ul><li>你为什么在该项目/场景里选择这个方案？替代方案为何不选？</li><li>最大一次事故/踩坑是什么？如何定位与回滚？</li><li>如果重做：架构/边界/工程化会怎么调整？</li></ul><h2 id="关联卡片" tabindex="-1"><a class="header-anchor" href="#关联卡片" aria-hidden="true">#</a> 关联卡片</h2>',5),a=(0,i.Uk)("项目（工程治理/多团队协作）： "),n=(0,i._)("code",null,"project__dji-rms",-1),d=(0,i._)("code",null,"project__dji-devops",-1),u=(0,i.Uk)("技术： "),s=(0,i._)("code",null,"tech__typescript",-1),o=(0,i.uE)('<h2 id="在我项目中的角色与使用场景" tabindex="-1"><a class="header-anchor" href="#在我项目中的角色与使用场景" aria-hidden="true">#</a> 在我项目中的角色与使用场景</h2><ul><li>适用约束：团队/模块变多后，需要解决“依赖治理 + CI 太慢 + 发布协作”的综合问题。</li><li>我关心的决策维度： <ul><li><strong>依赖图与边界</strong>：能否表达并约束“谁可以依赖谁”。</li><li><strong>缓存与增量</strong>：能否做到 affected 构建与缓存复用（本地/CI）。</li><li><strong>发布策略</strong>：版本管理、变更记录、回滚与可追溯。</li></ul></li></ul><h2 id="原理简述" tabindex="-1"><a class="header-anchor" href="#原理简述" aria-hidden="true">#</a> 原理简述</h2><p>核心机制（讲本质）：</p><ul><li>Lerna：历史定位偏“多包管理 + 发布”，通常要搭配 workspaces（yarn/pnpm）使用；工程能力需要你拼装（例如缓存/affected）。</li><li>Nx：定位是“工程系统”，内置任务编排、依赖图、affected 计算与缓存（对大型仓库 CI 收益明显）。</li></ul><p>适用边界：</p><ul><li>小仓库/包不多/CI 不慢：用 workspaces + changesets（或轻量 Lerna）即可。</li><li>大仓库/多团队/CI 成本高：更适合 Nx（用规则换性能与治理）。</li></ul><h2 id="对比表格" tabindex="-1"><a class="header-anchor" href="#对比表格" aria-hidden="true">#</a> 对比表格</h2><table><thead><tr><th>维度</th><th>Lerna</th><th>Nx</th><th>备注</th></tr></thead><tbody><tr><td>目标定位</td><td>发布/版本管理偏强</td><td><strong>工程系统</strong>（编排/缓存/affected）</td><td>先明确你缺的能力</td></tr><tr><td>依赖图能力</td><td>弱/需外部工具</td><td><strong>强</strong>（内置 graph/约束）</td><td>边界治理是长期收益</td></tr><tr><td>缓存/增量</td><td>依赖外部（turbo 等）</td><td><strong>强</strong>（本地+远端缓存）</td><td>CI 性能关键</td></tr><tr><td>CI 集成</td><td>需要自己拼装</td><td><strong>体系化</strong>（任务图）</td><td>大仓库更省心</td></tr><tr><td>迁移成本</td><td>低</td><td>中</td><td>Nx 引入规则与心智</td></tr><tr><td>风险与回滚</td><td>能力薄但简单</td><td>能力强但要治理</td><td>规则与规范要配套</td></tr></tbody></table><h2 id="模拟问答" tabindex="-1"><a class="header-anchor" href="#模拟问答" aria-hidden="true">#</a> 模拟问答</h2><ul><li>[ ] Q1：为什么最终选这个？反例是什么？ <ul><li>推荐回答结构：Context → Problem → Solution → Outcome → Learnings</li></ul></li></ul><h1 id="current-your-changes-current-your-changes" tabindex="-1"><a class="header-anchor" href="#current-your-changes-current-your-changes" aria-hidden="true">#</a> &lt;&lt;&lt;&lt;&lt;&lt;&lt; Current (Your changes) &lt;&lt;&lt;&lt;&lt;&lt;&lt; Current (Your changes)</h1><ul><li><p>[ ] Q2：affected 是怎么判断“受影响范围”的？为什么它能显著加速 CI？</p><ul><li>原理口径：基于依赖图 + git diff，计算改动会影响哪些项目（packages/apps），只对这些跑 build/test。</li><li>价值：避免“改一个小包，全仓全量跑一遍”的浪费。</li><li>风险：依赖图不准（跨包乱引用/动态依赖）会漏跑 → 必须配合边界规则与审计。</li></ul></li><li><p>[ ] Q3：缓存（本地/远端）怎么设计才可信？你如何避免“缓存污染”？</p><ul><li>关键：缓存键要包含输入（源码+配置+依赖版本+环境），否则命中不等于正确。</li><li>可信口径：对关键任务（build/test）做“可重放验证”（随机抽样禁用缓存跑一次对比）。</li><li>组织策略：远端缓存权限与隔离（避免不同分支/环境互相污染）。</li></ul></li><li><p>[ ] Q4：边界治理怎么落地到“团队真的执行”？</p><ul><li>工具：eslint-plugin-boundaries / dep-cruiser / Nx module boundaries。</li><li>流程：新代码强制（对变更文件/目录强约束），存量分阶段收敛（豁免清单+期限）。</li><li>产出：依赖图可视化 + 违规告警趋势，让治理有抓手。</li></ul></li><li><p>[ ] Q5：什么时候不建议上 Nx？你会给什么替代方案？</p><ul><li>反例：仓库小、包少、CI 不慢，Nx 规则与心智成本不划算。</li><li>替代：workspaces + changesets（版本发布）+ turbo（任务缓存）也能覆盖大部分需求。</li></ul></li></ul><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><h1 id="incoming-background-agent-changes" tabindex="-1"><a class="header-anchor" href="#incoming-background-agent-changes" aria-hidden="true">#</a> Incoming (Background Agent changes)</h1><p>Incoming (Background Agent changes) 可直接复述的回答要点（示例：选 Nx）：</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><ul><li>Context：包多、团队多、CI 慢，且跨包影响难以评估。</li><li>Problem：每次改动全量 build/test，耗时高且容易误伤。</li><li>Solution：Nx 的 affected + cache，把“只构建受影响的包”体系化；同时用依赖图做边界治理。</li><li>Outcome：CI 时间可控、回归范围更清晰、协作摩擦降低（用指标口径描述即可）。</li><li>反例：仓库很小、团队很少，Nx 的规则成本可能不划算。</li></ul><h2 id="手写代码区" tabindex="-1"><a class="header-anchor" href="#手写代码区" aria-hidden="true">#</a> 手写代码区</h2><p>（如适用：给出“最小概念验证”代码片段）</p><p>一个“边界治理”的最小策略（用文本说明即可）：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>规则：features/* 只能依赖 shared/* 与自身；禁止 features/a 直接依赖 features/b\n落地：\n  - eslint-plugin-boundaries / dep-cruiser 配规则\n  - CI 阶段跑依赖分析，失败则阻断\n收益：\n  - 降耦合、少循环依赖、更可维护\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="我的补充-manual" tabindex="-1"><a class="header-anchor" href="#我的补充-manual" aria-hidden="true">#</a> 我的补充（Manual）</h2><p>（不会被脚本覆盖：真实约束、组织因素、踩坑）</p><h2 id="复盘与反思-learnings" tabindex="-1"><a class="header-anchor" href="#复盘与反思-learnings" aria-hidden="true">#</a> 复盘与反思（Learnings）</h2><ul><li>如果重做会怎么改？</li></ul><h2 id="面试官追问-面试官视角" tabindex="-1"><a class="header-anchor" href="#面试官追问-面试官视角" aria-hidden="true">#</a> 面试官追问（面试官视角）</h2><ul><li>[ ] 为什么选这个方案？替代方案为什么不选？</li><li>[!] 最大一次事故/踩坑是什么？如何定位与回滚？</li><li>[ ] 如果重做会怎么改？</li></ul>',25),c={},h=(0,t(3744).Z)(c,[["render",function(e,l){const t=(0,i.up)("RouterLink");return(0,i.wg)(),(0,i.iD)(i.HY,null,[r,(0,i._)("ul",null,[(0,i._)("li",null,[a,(0,i._)("ul",null,[(0,i._)("li",null,[(0,i.Wm)(t,{to:"/interview-prep/project__dji-rms.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,i.w5)((()=>[n])),_:1})]),(0,i._)("li",null,[(0,i.Wm)(t,{to:"/interview-prep/project__dji-devops.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,i.w5)((()=>[d])),_:1})])])]),(0,i._)("li",null,[u,(0,i._)("ul",null,[(0,i._)("li",null,[(0,i.Wm)(t,{to:"/interview-prep/tech__typescript.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,i.w5)((()=>[s])),_:1})])])])]),o],64)}]])}}]);