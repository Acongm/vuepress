"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[3293],{8320:(n,l,s)=>{s.r(l),s.d(l,{data:()=>a});const a={key:"v-8c36b02e",path:"/mack/03-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",title:'性能优化流程 & 从浏览器请求链路解释"为什么这么优化"',lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"笔试题（6 题）",slug:"笔试题-6-题",children:[{level:3,title:"1. URL 到页面可交互全链路",slug:"_1-url-到页面可交互全链路",children:[]},{level:3,title:"2. 关键渲染路径（CRP）",slug:"_2-关键渲染路径-crp",children:[]},{level:3,title:"3. 资源提示（Resource Hints）",slug:"_3-资源提示-resource-hints",children:[]},{level:3,title:"4. Long Task 定位",slug:"_4-long-task-定位",children:[]},{level:3,title:"5. 图片优化策略",slug:"_5-图片优化策略",children:[]},{level:3,title:"6. 代码分割（Code Splitting）",slug:"_6-代码分割-code-splitting",children:[]}]},{level:2,title:"面试题（4 题）",slug:"面试题-4-题",children:[{level:3,title:"1. 首屏慢问题排查",slug:"_1-首屏慢问题排查",children:[]},{level:3,title:"3. RUM 闭环优化",slug:"_3-rum-闭环优化",children:[]},{level:3,title:"4. 性能优化 Case",slug:"_4-性能优化-case",children:[]}]}],git:{updatedTime:1767449185e3},filePathRelative:"mack/03-性能优化.md"}},3523:(n,l,s)=>{s.r(l),s.d(l,{default:()=>c});var a=s(6252);const p=(0,a.uE)('<h1 id="性能优化流程-从浏览器请求链路解释-为什么这么优化" tabindex="-1"><a class="header-anchor" href="#性能优化流程-从浏览器请求链路解释-为什么这么优化" aria-hidden="true">#</a> 性能优化流程 &amp; 从浏览器请求链路解释&quot;为什么这么优化&quot;</h1><h2 id="笔试题-6-题" tabindex="-1"><a class="header-anchor" href="#笔试题-6-题" aria-hidden="true">#</a> 笔试题（6 题）</h2><h3 id="_1-url-到页面可交互全链路" tabindex="-1"><a class="header-anchor" href="#_1-url-到页面可交互全链路" aria-hidden="true">#</a> 1. URL 到页面可交互全链路</h3><p>写出从输入 URL 到页面可交互（TTI）的大致链路，并在每个环节标出可优化点。</p><p><strong>【作答】：</strong></p><p>完整链路：</p><ol><li>DNS 解析：URL → IP 地址 <ul><li>浏览器查询 DNS 缓存 → 本地 hosts → 递归查询 DNS 服务器</li></ul></li><li>TCP 连接：三次握手建立连接 <ul><li>SYN → SYN-ACK → ACK</li></ul></li><li>TLS 握手（HTTPS）：协商加密参数 <ul><li>ClientHello → ServerHello → 证书验证 → 密钥交换</li></ul></li><li>HTTP 请求：发送请求头和请求体</li><li>服务器处理：解析请求、查询数据库、生成响应</li><li>HTTP 响应：接收响应头和响应体</li><li>解析 HTML：构建 DOM 树</li><li>解析 CSS：构建 CSSOM 树</li><li>执行 JS：解析、编译、执行</li><li>构建渲染树：DOM + CSSOM → Render Tree</li><li>布局（Layout/Reflow）：计算元素位置和大小</li><li>绘制（Paint）：填充像素信息</li><li>合成（Composite）：图层合成，输出到屏幕</li><li>可交互（TTI）：JS 主线程空闲，可响应用户交互</li></ol><p>各环节优化点：</p><p>【网络层优化】</p><ul><li>DNS 解析：使用 dns-prefetch、HTTP/2 Server Push、DNS 缓存</li><li>TCP 连接：使用 HTTP/2 多路复用、keep-alive、preconnect</li><li>TLS 握手：TLS 1.3、会话复用、OCSP Stapling</li><li>请求优化：压缩（gzip/brotli）、HTTP/2、CDN 加速、减少请求数</li></ul><p>【资源加载优化】</p><ul><li>HTML：内联关键 CSS、延迟非关键 JS、服务端渲染（SSR）</li><li>CSS：关键 CSS 内联、非关键 CSS 异步加载、移除未使用样式</li><li>JS：代码分割、Tree Shaking、压缩混淆、async/defer、动态导入</li><li>图片：WebP/AVIF、懒加载、响应式图片、CDN</li></ul><p>【渲染优化】</p><ul><li>解析：减少 DOM 层级、避免深层嵌套、使用语义化标签</li><li>布局：避免强制同步布局、使用 transform/opacity 触发合成层</li><li>绘制：减少重绘区域、使用 will-change、GPU 加速</li><li>合成：合理使用图层、避免过度合成</li></ul><p>【运行时优化】</p><ul><li>JS 执行：避免 Long Task、使用 Web Workers、代码分割</li><li>事件处理：防抖节流、事件委托、passive 监听器</li><li>内存管理：及时清理引用、避免内存泄漏、使用 WeakMap/WeakSet</li></ul><hr><h3 id="_2-关键渲染路径-crp" tabindex="-1"><a class="header-anchor" href="#_2-关键渲染路径-crp" aria-hidden="true">#</a> 2. 关键渲染路径（CRP）</h3><p>解释&quot;关键渲染路径（Critical Rendering Path）&quot;：CSS/JS 对渲染的阻塞关系是什么？async 和 defer 的区别？</p><p><strong>【作答】：</strong></p><p>CRP 定义： 关键渲染路径（Critical Rendering Path）是浏览器将 HTML、CSS、JS 转换为屏幕上像素的过程。 优化 CRP 的目标是：最小化渲染阻塞资源、减少往返次数、降低关键路径长度。</p><p>CSS 阻塞：</p>',22),i=(0,a._)("ul",null,[(0,a._)("li",null,"CSS 是渲染阻塞资源：浏览器必须等待 CSSOM 构建完成才能构建渲染树"),(0,a._)("li",null,"原因：避免 FOUC（Flash of Unstyled Content），确保样式一致性"),(0,a._)("li",null,[(0,a.Uk)("阻塞机制： "),(0,a._)("ul",null,[(0,a._)("li",null,[(0,a._)("link",{rel:"stylesheet"}),(0,a.Uk)(" 会阻塞渲染，直到 CSS 下载并解析完成 ")]),(0,a._)("li",null,"内联关键 CSS 可减少网络往返，但需控制内联体积（<14KB）"),(0,a._)("li",null,[(0,a.Uk)("非关键 CSS 应异步加载："),(0,a._)("link",{rel:"preload",as:"style",onload:"this.rel='stylesheet'"})])])]),(0,a._)("li",null,'优化：提取关键 CSS、延迟非关键 CSS、使用媒体查询（media="print"）异步加载')],-1),e=(0,a.uE)('<p>JS 阻塞：</p><ul><li>JS 是解析阻塞资源：遇到 &lt;script&gt; 会暂停 HTML 解析</li><li>原因：JS 可能修改 DOM/CSSOM，必须按顺序执行</li><li>阻塞机制： <ul><li>同步 &lt;script&gt;：阻塞 HTML 解析 → 下载 JS → 执行 JS → 继续解析</li><li>执行 JS 时，如果 CSSOM 未就绪，会等待 CSSOM 构建完成</li></ul></li><li>优化：使用 async/defer、动态 import()、将 JS 放在 <code>&lt;/body&gt;</code> 前</li></ul><p>async vs defer:</p><ul><li>async（异步执行）： <ul><li>下载与 HTML 解析并行，下载完成后立即执行（会阻塞解析）</li><li>执行顺序不确定，适合独立脚本（如统计代码、广告）</li><li>使用场景：不依赖 DOM、不依赖其他脚本的第三方库</li></ul></li><li>defer（延迟执行）： <ul><li>下载与 HTML 解析并行，但等到 DOM 解析完成后才执行</li><li>执行顺序按声明顺序，保证依赖关系</li><li>使用场景：需要访问 DOM、有执行顺序要求的脚本</li></ul></li><li>对比： <ul><li>async：下载完就执行，可能打断 HTML 解析</li><li>defer：等 DOM 解析完再执行，不打断解析</li><li>两者都支持并行下载，但执行时机不同</li></ul></li></ul><hr><h3 id="_3-资源提示-resource-hints" tabindex="-1"><a class="header-anchor" href="#_3-资源提示-resource-hints" aria-hidden="true">#</a> 3. 资源提示（Resource Hints）</h3><p>解释 preconnect/dns-prefetch/preload/prefetch 的差异与适用场景，以及它们在请求链路中的作用时机。</p><p><strong>【作答】：</strong></p><p>preconnect:</p><ul><li>作用：提前建立与目标服务器的连接（DNS + TCP + TLS）</li><li>时机：在 HTML 解析阶段就开始建立连接</li><li>适用：已知会请求的第三方域名（CDN、API、字体服务）</li><li>示例：<link rel="preconnect" href="https://fonts.googleapis.com"></li><li>优势：减少后续请求的延迟（节省 100-500ms）</li><li>注意：每个 preconnect 消耗资源，建议限制在 2-4 个</li></ul><p>dns-prefetch:</p><ul><li>作用：仅提前进行 DNS 解析</li><li>时机：在 HTML 解析阶段进行 DNS 查询</li><li>适用：不确定是否立即连接的第三方域名</li><li>示例：<link rel="dns-prefetch" href="https://analytics.example.com"></li><li>优势：比 preconnect 更轻量，只做 DNS 查询</li><li>注意：现代浏览器会自动 DNS prefetch，手动添加用于关键域名</li></ul><p>preload:</p>',13),t=(0,a._)("ul",null,[(0,a._)("li",null,"作用：提前加载当前页面必需的关键资源"),(0,a._)("li",null,"时机：在浏览器发现资源引用之前就开始下载"),(0,a._)("li",null,"适用：关键字体、关键 CSS、关键 JS、首屏图片"),(0,a._)("li",null,[(0,a.Uk)("示例："),(0,a._)("link",{rel:"preload",as:"font",href:"font.woff2",crossorigin:""})]),(0,a._)("li",null,"优势：提高资源优先级，减少 CRP 阻塞时间"),(0,a._)("li",null,"注意：必须指定 as 属性，避免重复下载（浏览器会缓存）")],-1),o=(0,a.uE)('<p>prefetch:</p><ul><li>作用：预取未来可能用到的资源（低优先级）</li><li>时机：浏览器空闲时下载</li><li>适用：下一页面的资源、用户可能点击的链接资源</li><li>示例：<link rel="prefetch" href="/next-page.js"></li><li>优势：提前缓存，提升后续页面加载速度</li><li>注意：优先级低，不会阻塞当前页面渲染</li></ul><p>使用场景对比：</p><p>【preconnect vs dns-prefetch】</p><ul><li>preconnect：确定会立即请求的第三方服务（CDN、API）</li><li>dns-prefetch：不确定是否立即请求，但可能用到（分析脚本、广告）</li></ul><p>【preload vs prefetch】</p><ul><li>preload：当前页面必需的关键资源，高优先级</li><li>prefetch：未来页面可能用到的资源，低优先级</li></ul><p>【请求链路中的作用时机】</p><ol><li>DNS 解析阶段：dns-prefetch、preconnect（DNS 部分）</li><li>TCP/TLS 阶段：preconnect（建立连接）</li><li>资源发现前：preload（提前下载关键资源）</li><li>浏览器空闲时：prefetch（预取未来资源）</li></ol><p>【最佳实践】</p><ul><li>关键字体：preload + preconnect（字体服务）</li><li>关键 CSS：内联或 preload</li><li>第三方 CDN：preconnect（减少连接建立时间）</li><li>下一页资源：prefetch（提升导航体验）</li></ul><hr><h3 id="_4-long-task-定位" tabindex="-1"><a class="header-anchor" href="#_4-long-task-定位" aria-hidden="true">#</a> 4. Long Task 定位</h3><p>什么是 Long Task？如何用 Performance API 或 Chrome DevTools 定位？如何拆分 Long Task？</p><p><strong>【作答】：</strong></p><p>Long Task 定义及影响：</p><ul><li>定义：执行时间超过 50ms 的任务（阻塞主线程）</li><li>影响： <ul><li>阻塞用户交互（点击、滚动无响应）</li><li>导致页面卡顿、掉帧（FPS 下降）</li><li>影响 TTI（Time to Interactive）指标</li><li>触发 Layout Shift（CLS）和输入延迟（FID/INP）</li></ul></li><li>原因：大量 JS 执行、复杂 DOM 操作、同步 I/O、强制同步布局</li></ul><p>定位方法：</p><p>【Performance API】</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 使用 PerformanceObserver 监听 Long Task</span>\n<span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> entry <span class="token keyword">of</span> list<span class="token punctuation">.</span><span class="token function">getEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>duration <span class="token operator">&gt;</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Long Task:&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n        <span class="token literal-property property">duration</span><span class="token operator">:</span> entry<span class="token punctuation">.</span>duration<span class="token punctuation">,</span>\n        <span class="token literal-property property">startTime</span><span class="token operator">:</span> entry<span class="token punctuation">.</span>startTime<span class="token punctuation">,</span>\n        <span class="token literal-property property">name</span><span class="token operator">:</span> entry<span class="token punctuation">.</span>name\n        <span class="token comment">// 可通过 entry.attribution 查看任务来源</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\nobserver<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">entryTypes</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;longtask&#39;</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>【Chrome DevTools】</p><ol><li><p>Performance 面板：</p><ul><li>录制页面加载/交互</li><li>查看 Main 线程时间线</li><li>红色标记表示 Long Task（&gt;50ms）</li><li>点击任务查看调用栈（Call Stack）</li></ul></li><li><p>分析步骤：</p><ul><li>找到红色长条（Long Task）</li><li>展开查看具体函数调用</li><li>定位耗时函数（Self Time 高）</li><li>查看函数所在文件和行号</li></ul></li><li><p>关键指标：</p><ul><li>Task Duration：任务总时长</li><li>Self Time：函数自身执行时间（不含子函数）</li><li>Aggregated Time：包含子函数的总时间</li></ul></li></ol><p>拆分策略：</p><p>【1. 任务切片（Time Slicing）】</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 使用 requestIdleCallback 或 setTimeout 拆分任务</span>\n<span class="token keyword">function</span> <span class="token function">processLargeArray</span><span class="token punctuation">(</span><span class="token parameter">items</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span>\n  <span class="token keyword">function</span> <span class="token function">processChunk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> chunkEnd <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">,</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chunkEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">processItem</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    index <span class="token operator">=</span> chunkEnd\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 让出主线程，允许浏览器处理其他任务</span>\n      <span class="token function">setTimeout</span><span class="token punctuation">(</span>processChunk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>\n      <span class="token comment">// 或使用 requestIdleCallback</span>\n      <span class="token comment">// requestIdleCallback(processChunk);</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">processChunk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>【2. Web Workers】</p><ul><li>将计算密集型任务移到 Worker</li><li>避免阻塞主线程</li><li>适用：数据处理、图像处理、复杂计算</li></ul><p>【3. 异步处理】</p><ul><li>使用 Promise、async/await 避免同步阻塞</li><li>批量处理改为流式处理</li><li>使用 requestAnimationFrame 优化 DOM 更新</li></ul><p>【4. 延迟非关键任务】</p><ul><li>使用 requestIdleCallback 执行低优先级任务</li><li>交互后延迟执行（如埋点、日志）</li></ul><p>【5. 优化算法和数据结构】</p><ul><li>减少循环嵌套、优化查找算法</li><li>使用 Map/Set 替代数组查找</li><li>避免不必要的计算和遍历</li></ul><hr><h3 id="_5-图片优化策略" tabindex="-1"><a class="header-anchor" href="#_5-图片优化策略" aria-hidden="true">#</a> 5. 图片优化策略</h3><p>列举图片优化策略，分别说明它们影响请求链路的哪一段（网络传输/解码/绘制）。</p><p><strong>【作答】：</strong></p><p>策略 1：图片格式优化（WebP/AVIF）</p><ul><li>原理：使用现代压缩算法，在相同质量下体积更小</li><li>影响阶段：网络传输（减少传输时间）</li><li>优化效果：体积减少 25-50%，传输时间减少相应比例</li><li>实现：<code>&lt;picture&gt;</code> 标签提供降级方案</li><li>示例：<div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code>`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>picture</span>\n  <span class="token punctuation">&gt;</span></span>`\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image.avif<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image/avif<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image.webp<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image/webp<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image.jpg<span class="token punctuation">&quot;</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>fallback<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>picture</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ul><p>策略 2：响应式图片（srcset + sizes）</p><ul><li>原理：根据设备像素比和视口大小加载合适尺寸</li><li>影响阶段：网络传输（避免下载过大图片）</li><li>优化效果：移动端减少 50-70% 传输量</li><li>实现：<div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span>\n  <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>small.jpg 400w, medium.jpg 800w, large.jpg 1200w<span class="token punctuation">&quot;</span></span>\n  <span class="token attr-name">sizes</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(max-width: 600px) 400px, 800px<span class="token punctuation">&quot;</span></span>\n  <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>medium.jpg<span class="token punctuation">&quot;</span></span>\n<span class="token punctuation">/&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li>注意：浏览器根据设备像素比和 sizes 自动选择</li></ul><p>策略 3：图片懒加载（Lazy Loading）</p><ul><li>原理：只加载可视区域内的图片，滚动时再加载</li><li>影响阶段：网络传输（减少初始请求数）</li><li>优化效果：首屏请求减少 60-80%，FCP/LCP 提升</li><li>实现： <ul><li>原生：</li></ul><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">loading</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>lazy<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image.jpg<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul><li>JS：Intersection Observer API</li></ul></li><li>注意：首屏关键图片不应懒加载</li></ul><p>策略 4：图片压缩与 CDN</p><ul><li>原理：压缩减少体积，CDN 减少传输距离</li><li>影响阶段：网络传输（减少体积和延迟）</li><li>优化效果：体积减少 30-60%，延迟减少 50-200ms</li><li>实现： <ul><li>工具压缩：TinyPNG、ImageOptim、sharp</li><li>CDN：使用就近节点，HTTP/2 多路复用</li><li>自适应质量：根据网络条件动态调整</li></ul></li></ul><p>策略 5：图片解码优化（decoding=&quot;async&quot;）</p><ul><li><p>原理：异步解码图片，不阻塞主线程</p></li><li><p>影响阶段：解码阶段（不阻塞渲染）</p></li><li><p>优化效果：减少主线程阻塞时间，提升 FCP</p></li><li><p>实现：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">decoding</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>async<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image.jpg<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>注意：关键图片可用 decoding=&quot;sync&quot; 确保及时显示</p></li></ul><p>策略 6：使用 CSS Sprites / SVG</p><ul><li>原理：合并小图标减少请求数，SVG 矢量可缩放</li><li>影响阶段：网络传输（减少请求数）</li><li>优化效果：减少 HTTP 请求，降低延迟</li><li>适用：图标、小图片、简单图形</li></ul><p>【各阶段影响总结】</p><ul><li>网络传输：格式优化、响应式、压缩、CDN、懒加载</li><li>解码阶段：decoding=&quot;async&quot;、避免过大图片</li><li>绘制阶段：使用 transform/opacity 触发 GPU 加速、避免频繁重绘</li></ul><hr><h3 id="_6-代码分割-code-splitting" tabindex="-1"><a class="header-anchor" href="#_6-代码分割-code-splitting" aria-hidden="true">#</a> 6. 代码分割（Code Splitting）</h3><p>解释代码分割（split chunk）对 FCP/LCP/TTI 的影响机制。如何合理设计分割策略？</p><p><strong>【作答】：</strong></p><p>对 FCP 的影响：</p><ul><li>机制：代码分割减少初始 JS 体积，加快首屏 JS 执行完成</li><li>正面影响： <ul><li>减少初始 bundle 体积（如从 500KB → 200KB）</li><li>减少 JS 解析和编译时间</li><li>更早完成关键渲染路径，提升 FCP</li></ul></li><li>负面影响（不当分割）： <ul><li>过多小 chunk 增加 HTTP 请求数（HTTP/1.1 下明显）</li><li>需要等待关键 chunk 加载才能渲染</li></ul></li><li>优化：提取关键 JS 内联，非关键 JS 异步加载</li></ul><p>对 LCP 的影响：</p><ul><li>机制：LCP 元素（通常是图片或文本）的渲染依赖 JS 执行</li><li>正面影响： <ul><li>如果 LCP 元素由 JS 渲染，减少 JS 体积可加快渲染</li><li>延迟非关键 JS，优先加载渲染 LCP 所需的代码</li></ul></li><li>负面影响： <ul><li>如果 LCP 元素需要等待某个 chunk 加载，反而延迟 LCP</li><li>关键资源应避免分割，或使用 preload 提前加载</li></ul></li><li>优化：识别 LCP 元素依赖的代码，确保优先加载</li></ul><p>对 TTI 的影响：</p><ul><li>机制：TTI 要求主线程空闲且可交互，依赖所有关键 JS 执行完成</li><li>正面影响： <ul><li>减少初始 JS 执行时间，更快达到 TTI</li><li>延迟非关键功能代码，不阻塞 TTI</li></ul></li><li>负面影响： <ul><li>如果交互功能被分割，需要等待 chunk 加载才能交互</li><li>路由级别的分割可能导致导航时延迟</li></ul></li><li>优化： <ul><li>关键交互代码应包含在初始 bundle</li><li>使用路由懒加载，但预加载可能访问的路由</li></ul></li></ul><p>分割策略：</p><p>【1. 路由级别分割（Route-based）】</p><ul><li>适用：SPA 应用，按路由分割</li><li>实现：React.lazy() + Suspense</li><li>优势：每个路由独立加载，减少初始体积</li><li>注意：预加载可能访问的路由，避免导航延迟</li></ul><p>【2. 组件级别分割（Component-based）】</p><ul><li>适用：大型组件、弹窗、折叠内容</li><li>实现：动态 import() 加载组件</li><li>优势：按需加载，减少初始 bundle</li><li>注意：避免过度分割，增加请求开销</li></ul><p>【3. 第三方库分割（Vendor splitting）】</p><ul><li>适用：大型第三方库（如 moment.js、lodash）</li><li>实现：webpack splitChunks 配置</li><li>优势：利用浏览器缓存，库更新不影响业务代码</li><li>配置示例：<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">splitChunks</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">chunks</span><span class="token operator">:</span> <span class="token string">&#39;all&#39;</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">cacheGroups</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">vendor</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\\\\/]node_modules[\\\\/]</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>\n      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;vendors&#39;</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">priority</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li></ul><p>【4. 公共代码提取（Common chunks）】</p><ul><li>适用：多个入口共享的代码</li><li>实现：webpack CommonsChunkPlugin / splitChunks</li><li>优势：避免重复打包，利用缓存</li></ul><p>【5. 按需加载（On-demand）】</p><ul><li>适用：非首屏功能（如分析脚本、广告）</li><li>实现：用户交互或条件触发时加载</li><li>优势：不阻塞首屏渲染</li></ul><p>【最佳实践】</p><ol><li>初始 bundle &lt; 200KB（gzip 后）</li><li>关键路径代码不分割或预加载</li><li>路由分割 + 预加载策略</li><li>第三方库单独打包，利用长期缓存</li><li>使用 HTTP/2 时，可适当增加 chunk 数量</li><li>监控 chunk 加载时间，避免过度分割</li></ol><hr><h2 id="面试题-4-题" tabindex="-1"><a class="header-anchor" href="#面试题-4-题" aria-hidden="true">#</a> 面试题（4 题）</h2><h3 id="_1-首屏慢问题排查" tabindex="-1"><a class="header-anchor" href="#_1-首屏慢问题排查" aria-hidden="true">#</a> 1. 首屏慢问题排查</h3><p>给你一个&quot;首屏慢&quot;的页面，你的完整排查路径是什么（先证据后结论）？需要收集哪些数据？</p><p><strong>【作答】：</strong></p><p>【排查路径：先证据后结论】</p><p>第一步：收集性能数据（证据）</p><ol><li>Core Web Vitals 指标：FCP、LCP、FID/INP、CLS、TTI</li><li>网络性能数据：DNS/TCP/TLS 时间、TTFB、资源加载瀑布图、请求数量和传输量</li><li>渲染性能数据：主线程时间线、Long Task、布局/重排次数、重绘次数、合成层数量</li><li>资源分析：JS/CSS/图片体积、未使用代码比例、关键资源加载时间、阻塞资源识别</li></ol><p>第二步：定位瓶颈（分析证据）</p><ol><li>网络瓶颈：TTFB &gt; 600ms → 服务器响应慢或网络延迟；资源加载时间长 → CDN 或压缩问题</li><li>渲染瓶颈：FCP 慢但 TTFB 正常 → CSS/JS 阻塞；LCP 慢 → 图片问题；TTI 慢 → JS 执行时间长</li><li>资源瓶颈：JS 体积大 → 代码分割；未使用代码多 → Tree Shaking；图片未优化 → 格式/压缩/懒加载</li></ol><p>第三步：验证假设（实验）</p><ul><li>使用 Chrome DevTools：Performance、Network、Lighthouse、Coverage</li><li>对比测试：禁用资源、模拟慢网络、对比优化前后指标</li></ul><p>第四步：制定优化方案（结论）</p><ul><li>网络问题 → CDN、压缩、HTTP/2</li><li>渲染阻塞 → 关键 CSS 内联、JS 异步</li><li>资源体积 → 代码分割、Tree Shaking</li><li>图片问题 → 格式优化、懒加载</li></ul><p>【需要收集的数据清单】</p><ul><li>性能指标：Navigation Timing、Resource Timing、Paint Timing、Performance Observer</li><li>网络数据：请求瀑布图、资源大小/加载时间/优先级、阻塞资源列表、慢请求识别</li><li>渲染数据：主线程时间线、Long Task 列表、布局/重排触发点、合成层信息</li><li>资源分析：Bundle 分析、未使用代码覆盖率、关键资源依赖图、第三方库体积占比</li><li>环境数据：设备类型、网络类型、浏览器版本、地理位置</li><li>工具推荐：Chrome DevTools、WebPageTest、RUM 工具、Bundle 分析工具</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>\n---\n\n### 2. JS 体积与性能\n为什么&quot;减少 JS 体积&quot;不等于&quot;性能一定更好&quot;？举例说明可能的反例和权衡点。\n\n**【作答】：**\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>【核心原因】 JS 体积只是性能的一个维度，性能 = 网络传输 + 解析编译 + 执行时间。 减少体积主要优化&quot;网络传输&quot;，但可能影响&quot;解析编译&quot;和&quot;执行时间&quot;。</p><p>【反例 1：过度代码分割】 场景：将 500KB 代码分割成 50 个 10KB 的 chunk 问题：HTTP/1.1 下 50 个请求的延迟 &gt; 1 个大请求；每个 chunk 需要单独解析和编译；可能导致&quot;请求瀑布&quot; 结果：体积减少，但总加载时间反而增加 权衡：在 HTTP/2 下可适当增加 chunk 数，但需控制合理范围</p><p>【反例 2：压缩过度导致执行变慢】 场景：使用极致压缩（如 closure compiler advanced mode） 问题：变量名缩短可能阻止 V8 优化（内联缓存失效）；代码可读性差，调试困难 结果：体积减少 20%，但执行时间增加 10% 权衡：使用标准压缩（terser default），平衡体积和执行性能</p><p>【反例 3：移除&quot;未使用&quot;代码但影响缓存】 场景：Tree Shaking 移除大量代码，但破坏了 vendor chunk 的稳定性 问题：业务代码和 vendor 代码混在一起；业务代码更新导致整个 bundle 失效；缓存命中率下降 结果：体积减少，但重复访问性能变差 权衡：合理分割 vendor 和业务代码，利用长期缓存</p><p>【反例 4：内联关键代码但增加 HTML 体积】 场景：将关键 JS 内联到 HTML 以减少请求 问题：HTML 体积增大，TTFB 可能增加；HTML 无法单独缓存；内联代码无法利用浏览器预解析 结果：请求数减少，但 HTML 传输时间增加 权衡：只内联极小关键代码（&lt;14KB），其余使用 preload</p><p>【反例 5：使用更小的库但功能缺失】 场景：用轻量库替代功能库（如 day.js 替代 moment.js） 问题：功能缺失需要额外代码实现；可能引入 bug 或性能问题；开发效率下降 结果：库体积减少，但总代码量或执行时间可能增加 权衡：评估实际使用功能，选择合适方案</p><p>【反例 6：延迟加载但影响交互】 场景：将交互相关代码延迟加载 问题：用户点击时需等待 chunk 加载；交互延迟增加（FID/INP 变差）；用户体验下降 结果：初始加载快，但交互响应慢 权衡：关键交互代码应在初始 bundle，非关键功能可延迟</p><p>【性能权衡框架】</p><ul><li>网络传输：体积小传输快，但请求数多延迟增加</li><li>解析编译：体积小解析快，但代码分割多次解析</li><li>执行阶段：体积小执行代码少，但压缩过度执行变慢</li><li>缓存阶段：体积小下载快，但分割不当缓存失效</li></ul><p>【最佳实践】</p><ol><li>关注总加载时间，而非单纯体积</li><li>使用 HTTP/2 时，可适当增加 chunk 数</li><li>关键路径代码不分割或预加载</li><li>平衡压缩率和执行性能</li><li>利用缓存策略，而非一味减少体积</li><li>监控真实性能指标（FCP、LCP、TTI），而非只看体积</li></ol><hr><h3 id="_3-rum-闭环优化" tabindex="-1"><a class="header-anchor" href="#_3-rum-闭环优化" aria-hidden="true">#</a> 3. RUM 闭环优化</h3><p>你如何用 RUM（真实用户监控）闭环性能优化：指标选择、归因分析、A/B 实验、回滚策略？</p><p><strong>【作答】：</strong></p><p>【RUM 闭环流程】 数据收集 → 指标分析 → 问题归因 → 优化实施 → A/B 验证 → 效果评估 → 回滚/推广</p><p>【1. 指标选择】</p><p>【核心指标（Core Web Vitals）】</p><ul><li>LCP（Largest Contentful Paint）：加载性能，&lt; 2.5s 良好</li><li>FID/INP（First Input Delay / Interaction to Next Paint）：交互性，&lt; 100ms 良好</li><li>CLS（Cumulative Layout Shift）：视觉稳定性，&lt; 0.1 良好</li></ul><p>【辅助指标】</p><ul><li>FCP（First Contentful Paint）：首次内容绘制</li><li>TTI（Time to Interactive）：可交互时间</li><li>TBT（Total Blocking Time）：总阻塞时间</li><li>FCP to LCP：内容绘制间隔</li></ul><p>【业务指标】</p><ul><li>页面 PV/UV、跳出率、转化率（与性能关联分析）、用户停留时间</li></ul><p>【自定义指标】</p><ul><li>关键功能加载时间（如搜索、支付）</li><li>第三方脚本加载时间、错误率</li></ul><p>【2. 归因分析】</p><p>【维度划分】</p><ol><li>设备维度：移动端 vs 桌面端、iOS vs Android、低端设备 vs 高端设备</li><li>网络维度：3G / 4G / 5G / WiFi、不同运营商、不同地区（CDN 覆盖）</li><li>页面维度：不同路由/页面、首屏 vs 内页、新用户 vs 回访用户</li><li>时间维度：不同时段（高峰/低峰）、工作日 vs 周末、版本发布前后对比</li></ol><p>【归因方法】</p><ol><li>相关性分析：性能指标与业务指标的相关性，识别影响最大的性能问题</li><li>分位数分析：P50（中位数）、P75、P95、P99，关注长尾用户（P95+）体验</li><li>异常检测：识别性能突降时间点，关联代码发布、配置变更</li><li>用户分群：按设备/网络/地区分群，识别特定用户群体的性能问题</li></ol><p>【3. A/B 实验】</p><p>【实验设计】</p><ol><li>假设提出：基于归因分析，提出优化假设（例：&quot;减少首屏 JS 体积可提升 LCP 20%&quot;）</li><li>实验分组：对照组（A）当前版本，实验组（B）优化版本，随机分配用户</li><li>样本量计算：根据预期提升幅度和统计显著性要求，通常需要数千到数万样本</li><li>实验时长：至少 1-2 周，覆盖不同时段和用户类型，避免节假日等异常时段</li></ol><p>【监控指标】</p><ul><li>性能指标：LCP、FID、CLS、TTI</li><li>业务指标：转化率、跳出率、停留时间</li><li>技术指标：错误率、崩溃率</li></ul><p>【统计验证】</p><ul><li>使用 t-test 或 Mann-Whitney U 检验</li><li>确保统计显著性（p &lt; 0.05）</li><li>检查置信区间</li></ul><p>【4. 回滚策略】</p><p>【回滚触发条件】</p><ol><li>性能回退：核心指标下降 &gt; 10%，P95 用户性能明显变差</li><li>业务影响：转化率下降 &gt; 5%，错误率增加 &gt; 20%，用户投诉增加</li><li>技术问题：崩溃率增加、关键功能异常、第三方服务异常</li></ol><p>【回滚流程】</p><ol><li>立即回滚：自动化回滚机制（如 feature flag），保留优化代码，通过配置控制</li><li>数据分析：分析回滚原因，区分是优化方案问题还是其他因素</li><li>问题修复：修复问题后重新实验，或调整优化方案</li></ol><p>【灰度发布策略】</p><ul><li>小流量（5%）→ 中流量（20%）→ 全量（100%）</li><li>每阶段观察 1-2 天，发现问题立即回滚</li></ul><p>【5. 完整闭环示例】</p><p>【阶段 1：数据收集】</p><ul><li>部署 RUM SDK，收集 1 周基线数据</li><li>发现：移动端 LCP P95 = 4.2s（目标 &lt; 2.5s）</li></ul><p>【阶段 2：归因分析】</p><ul><li>分析发现：首屏 JS 体积 800KB，加载时间 2.1s</li><li>相关性：JS 体积与 LCP 相关系数 0.75</li></ul><p>【阶段 3：优化实施】</p><ul><li>方案：代码分割 + 延迟非关键 JS</li><li>预期：JS 体积减少 60%，LCP 提升 30%</li></ul><p>【阶段 4：A/B 实验】</p><ul><li>实验组：优化版本（50% 流量）</li><li>对照组：原版本（50% 流量）</li><li>时长：2 周</li></ul><p>【阶段 5：效果评估】</p><ul><li>结果：LCP P95 从 4.2s → 2.8s（提升 33%）</li><li>业务指标：转化率提升 5%（统计显著）</li><li>决策：全量发布</li></ul><p>【阶段 6：持续监控】</p><ul><li>全量后持续监控 1 周</li><li>确认无回退，优化完成</li></ul><p>【工具推荐】</p><ul><li>RUM：Google Analytics、New Relic、Datadog、Sentry</li><li>A/B 测试：Google Optimize、Optimizely、自建</li><li>分析：BigQuery、Tableau、Grafana</li></ul><hr><h3 id="_4-性能优化-case" tabindex="-1"><a class="header-anchor" href="#_4-性能优化-case" aria-hidden="true">#</a> 4. 性能优化 Case</h3><p>讲一个你做过的性能优化 case：初始指标、关键决策、实施过程、最终效果、踩坑经验。</p><p><strong>【作答】：</strong></p><p>【案例：电商首页性能优化】</p><p>【背景】 某电商平台首页首屏加载缓慢，用户反馈卡顿，移动端体验尤其差。 需要系统性优化，提升 Core Web Vitals 指标。</p><p>【初始指标（优化前）】</p><ul><li>LCP：移动端 P95 = 4.8s（目标 &lt; 2.5s）</li><li>FID：P95 = 280ms（目标 &lt; 100ms）</li><li>CLS：0.25（目标 &lt; 0.1）</li><li>TTI：8.2s</li><li>首屏 JS 体积：850KB（gzip 后）</li><li>首屏请求数：45 个</li><li>跳出率：42%</li></ul><p>【问题分析】</p><ol><li><p>性能分析工具（Lighthouse + Performance）：</p><ul><li>发现 3 个 Long Task（总计 320ms）</li><li>首屏图片未优化（总大小 2.1MB）</li><li>关键 CSS 阻塞渲染（280KB）</li><li>第三方脚本阻塞（广告、分析）</li></ul></li><li><p>网络分析：</p><ul><li>TTFB：1.2s（服务器响应慢）</li><li>资源加载串行（HTTP/1.1）</li><li>未使用 CDN</li></ul></li><li><p>代码分析：</p><ul><li>Bundle 分析发现大量未使用代码（30%）</li><li>第三方库体积大（moment.js 70KB）</li><li>未做代码分割</li></ul></li></ol><p>【关键决策】</p><p>【决策 1：代码分割策略】</p><ul><li>路由级别分割：首页、列表页、详情页独立 chunk</li><li>组件级别分割：弹窗、折叠内容延迟加载</li><li>Vendor 分割：第三方库单独打包，利用长期缓存</li><li>关键决策：保留首屏必需代码在初始 bundle（&lt; 200KB）</li></ul><p>【决策 2：资源优化优先级】</p><ol><li>图片优化（影响 LCP）→ 最高优先级</li><li>JS 体积优化（影响 TTI）→ 高优先级</li><li>CSS 优化（影响 FCP）→ 中优先级</li><li>第三方脚本优化（影响 FID）→ 中优先级</li></ol><p>【决策 3：技术选型】</p><ul><li>图片格式：WebP + AVIF（降级 JPEG）</li><li>构建工具：Webpack 5（Tree Shaking + Code Splitting）</li><li>CDN：阿里云 CDN（国内加速）</li><li>监控：自建 RUM + Google Analytics</li></ul><p>【实施过程】</p><p>【阶段 1：图片优化（第 1 周）】</p><ol><li>格式转换：使用 sharp 批量转换为 WebP，关键图片提供 AVIF 格式</li><li>响应式图片：生成多尺寸版本（400w, 800w, 1200w），使用 srcset + sizes</li><li>懒加载：首屏外图片使用 loading=&quot;lazy&quot;，使用 Intersection Observer 优化</li><li>CDN 配置：图片上传到 CDN，配置自动压缩和格式转换 结果：图片总大小从 2.1MB → 680KB（减少 68%）</li></ol><p>【阶段 2：JS 优化（第 2 周）】</p><ol><li>代码分割：路由分割（React.lazy() + Suspense），webpack splitChunks 配置</li><li>Tree Shaking：移除未使用的 moment.js，改用 day.js，按需导入 lodash</li><li>压缩优化：使用 terser 压缩，移除 console、注释</li><li>动态导入：非关键功能（如分享、评论）延迟加载 结果：首屏 JS 从 850KB → 280KB（减少 67%）</li></ol><p>【阶段 3：CSS 优化（第 3 周）】</p><ol><li>关键 CSS 内联：提取首屏关键 CSS（&lt; 14KB），内联到 <code>&lt;head &gt;</code></li><li>非关键 CSS 异步加载：使用 preload + onload 切换 rel</li><li>移除未使用样式：使用 PurgeCSS 移除未使用样式，减少 CSS 体积 40%</li></ol><p>【阶段 4：第三方脚本优化（第 4 周）】</p><ol><li>延迟加载：分析脚本延迟到 onload 后，广告脚本使用 async</li><li>使用 preconnect：提前建立第三方服务连接</li><li>条件加载：移动端不加载桌面端专用脚本</li></ol><p>【阶段 5：服务器优化（第 5 周）】</p><ol><li>启用 HTTP/2、Brotli 压缩</li><li>配置缓存策略：静态资源 1 年，HTML 无缓存，API 5 分钟</li><li>优化 TTFB：服务器端缓存，数据库查询优化</li></ol><p>【最终效果（优化后）】</p><ul><li>LCP：移动端 P95 = 2.1s（提升 56%，达到良好标准）</li><li>FID：P95 = 85ms（提升 70%，达到良好标准）</li><li>CLS：0.08（提升 68%，达到良好标准）</li><li>TTI：4.5s（提升 45%）</li><li>首屏 JS 体积：280KB（减少 67%）</li><li>首屏请求数：28 个（减少 38%）</li><li>跳出率：32%（下降 10 个百分点）</li><li>转化率：提升 8%（统计显著）</li></ul><p>【踩坑经验】</p><p>【坑 1：过度代码分割】 问题：将代码分割成 30+ 个 chunk，HTTP/1.1 下加载变慢 解决：合并小 chunk，控制在 10 个以内，或升级 HTTP/2 教训：分割需平衡体积和请求数</p><p>【坑 2：关键资源延迟加载】 问题：将首屏渲染必需的组件延迟加载，导致 LCP 变慢 解决：识别关键路径资源，确保优先加载 教训：不是所有代码都适合延迟加载</p><p>【坑 3：图片格式兼容性】 问题：部分老旧浏览器不支持 WebP，显示异常 解决：使用 <code>&lt;picture&gt;</code> 提供降级方案，充分测试 教训：新技术需考虑兼容性和降级方案</p><p>【坑 4：第三方脚本阻塞】 问题：广告脚本同步加载，阻塞主线程 解决：使用 async 或延迟加载，但需注意功能依赖 教训：第三方脚本需谨慎处理，避免阻塞关键路径</p><p>【坑 5：缓存策略不当】 问题：HTML 设置了长期缓存，更新后用户看不到新版本 解决：HTML 不缓存，静态资源使用版本号或 hash 教训：不同资源类型需不同缓存策略</p><p>【经验总结】</p><ol><li>性能优化是系统性工程，需多维度配合</li><li>数据驱动：先测量再优化，用数据验证效果</li><li>平衡取舍：体积、请求数、缓存、兼容性需权衡</li><li>持续监控：优化后持续监控，避免回退</li><li>用户体验优先：关注真实用户指标，而非实验室指标</li></ol><hr>',189),u={},c=(0,s(3744).Z)(u,[["render",function(n,l){return(0,a.wg)(),(0,a.iD)(a.HY,null,[p,i,e,t,o],64)}]])},3744:(n,l)=>{l.Z=(n,l)=>{const s=n.__vccOpts||n;for(const[n,a]of l)s[n]=a;return s}}}]);