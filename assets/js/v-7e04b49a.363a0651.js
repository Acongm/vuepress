"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[4747],{3841:(e,l,r)=>{r.r(l),r.d(l,{data:()=>i});const i={key:"v-7e04b49a",path:"/theory/job-description-lib/01-%E5%A4%A7%E7%96%86%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E9%87%8D%E6%9E%84-%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%BA%B2.html",title:"大疆用户中心重构（2022.02-2022.09）- 面试技术大纲",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"性能优化：指标体系与定位方法",slug:"性能优化-指标体系与定位方法",children:[]},{level:2,title:"简历可落地点（结合“优化四板斧”）",slug:"简历可落地点-结合-优化四板斧",children:[]},{level:2,title:"HTTP 常考点（从“为什么变快”倒推）",slug:"http-常考点-从-为什么变快-倒推",children:[]},{level:2,title:"Webpack 架构（工程化面试常考，可用于“构建工具理解”话题）",slug:"webpack-架构-工程化面试常考-可用于-构建工具理解-话题",children:[]},{level:2,title:"按优化顺序，把方案“串起来”（排查 → 定位 → 选择 → 验证）",slug:"按优化顺序-把方案-串起来-排查-→-定位-→-选择-→-验证",children:[{level:3,title:"0. 排查与基线（先把问题“量化”）",slug:"_0-排查与基线-先把问题-量化",children:[]},{level:3,title:"1. 先保“可见”——骨架屏预渲染（直接拉低 LCP）",slug:"_1-先保-可见-——骨架屏预渲染-直接拉低-lcp",children:[]},{level:3,title:"2. 再减“阻塞”——关键渲染路径（CRP）梳理：CSS/字体/首图优先级",slug:"_2-再减-阻塞-——关键渲染路径-crp-梳理-css-字体-首图优先级",children:[]},{level:3,title:"3. 再降“下载与解析成本”——更小的包体与更少的无效代码",slug:"_3-再降-下载与解析成本-——更小的包体与更少的无效代码",children:[]},{level:3,title:"4. 再优化“传输层”——gzip + TLS 1.3（让关键资源更快到达）",slug:"_4-再优化-传输层-——gzip-tls-1-3-让关键资源更快到达",children:[]},{level:3,title:"5. 最后补“图片格式”——WebP（兼顾体积与视觉）",slug:"_5-最后补-图片格式-——webp-兼顾体积与视觉",children:[]},{level:3,title:"6. 回归与守护（防止“优化回退”）",slug:"_6-回归与守护-防止-优化回退",children:[]}]}],git:{updatedTime:1767447745e3},filePathRelative:"theory/job-description-lib/01-大疆用户中心重构-面试技术大纲.md"}},4550:(e,l,r)=>{r.r(l),r.d(l,{default:()=>s});const i=(0,r(6252).uE)('<h1 id="大疆用户中心重构-2022-02-2022-09-面试技术大纲" tabindex="-1"><a class="header-anchor" href="#大疆用户中心重构-2022-02-2022-09-面试技术大纲" aria-hidden="true">#</a> 大疆用户中心重构（2022.02-2022.09）- 面试技术大纲</h1><blockquote><p>技术栈：Vue3 + TypeScript + Vite + Pinia（简历）<br> 目标：性能优化 + HTTP 原理 +（工程化可类比到 Webpack 架构）</p></blockquote><hr><h2 id="性能优化-指标体系与定位方法" tabindex="-1"><a class="header-anchor" href="#性能优化-指标体系与定位方法" aria-hidden="true">#</a> 性能优化：指标体系与定位方法</h2><ul><li><strong>指标体系</strong>：LCP / FCP / TTI / CLS / INP、首屏/白屏时间、资源体积、接口耗时、缓存命中率</li><li><strong>定位手段</strong>：Performance / Network 面板、Lighthouse、Web Vitals 上报、Long Task 分析</li><li><strong>优化策略</strong>：关键渲染路径优化、渐进式渲染（骨架屏 / 占位 / 分片渲染）</li></ul><h2 id="简历可落地点-结合-优化四板斧" tabindex="-1"><a class="header-anchor" href="#简历可落地点-结合-优化四板斧" aria-hidden="true">#</a> 简历可落地点（结合“优化四板斧”）</h2><ul><li><strong>骨架屏预渲染</strong>：怎么做（预生成/服务端直出/静态骨架）、一致性（闪烁/布局偏移）、对 LCP 的影响评估</li><li><strong>更小的代码体积</strong>：<code>core-js</code> 精简、字体子集化/压缩、CSS 打包策略（提取/合并/按需）</li><li><strong>更快的加载与渲染</strong>：资源优先级（preload/prefetch）、合理加载顺序、gzip/br、首屏关键资源最小化</li><li><strong>传输层优化</strong>：TLS 1.3 的收益点（握手/复用/延迟），以及真实线上观测方法</li><li><strong>图片优化</strong>：WebP/AVIF 接入、兼容兜底策略、图片尺寸与懒加载、占位与解码开销</li></ul><h2 id="http-常考点-从-为什么变快-倒推" tabindex="-1"><a class="header-anchor" href="#http-常考点-从-为什么变快-倒推" aria-hidden="true">#</a> HTTP 常考点（从“为什么变快”倒推）</h2><ul><li><strong>HTTP/1.1 vs HTTP/2 vs HTTP/3</strong>：队头阻塞、并发模型、HPACK/QPACK、0-RTT</li><li><strong>TLS</strong>：握手流程、证书链、会话复用、OCSP Stapling、连接复用与域名拆分的取舍</li><li><strong>缓存体系</strong>：强缓存/协商缓存、CDN 缓存、版本号/哈希策略、Service Worker 缓存与更新</li></ul><h2 id="webpack-架构-工程化面试常考-可用于-构建工具理解-话题" tabindex="-1"><a class="header-anchor" href="#webpack-架构-工程化面试常考-可用于-构建工具理解-话题" aria-hidden="true">#</a> Webpack 架构（工程化面试常考，可用于“构建工具理解”话题）</h2><ul><li><strong>构建流程</strong>：entry → module graph → loader → plugin → chunks → assets</li><li><strong>产物与优化</strong>：splitChunks、runtimeChunk、tree-shaking（sideEffects）、scope hoisting</li><li><strong>构建性能</strong>：持久化缓存、并行压缩、sourceMap 策略、bundle 分析与预算（budgets）</li><li><strong>现代替代</strong>：Webpack vs Vite（依赖预构建/ESM dev server）什么时候选谁、迁移风险点</li></ul><h2 id="按优化顺序-把方案-串起来-排查-→-定位-→-选择-→-验证" tabindex="-1"><a class="header-anchor" href="#按优化顺序-把方案-串起来-排查-→-定位-→-选择-→-验证" aria-hidden="true">#</a> 按优化顺序，把方案“串起来”（排查 → 定位 → 选择 → 验证）</h2><blockquote><p>面试复述主线：我先把目标收敛到 <strong>LCP/首屏</strong>（简历：LCP 2.3s → 1.4s，首屏 &lt; 1.5s），然后沿着浏览器关键链路 <strong>网络 → 解析 → 渲染 → 资源加载</strong> 分段拆解瓶颈，做到“每一刀都有证据、每一刀都有回归验证”。</p></blockquote><h3 id="_0-排查与基线-先把问题-量化" tabindex="-1"><a class="header-anchor" href="#_0-排查与基线-先把问题-量化" aria-hidden="true">#</a> 0. 排查与基线（先把问题“量化”）</h3><ul><li><strong>先定指标</strong>：以 LCP/首屏为主，辅以 FCP/CLS/INP 与关键接口耗时、缓存命中率，建立对比基线（同机型/同网络/同账号/同页面路径）。</li><li><strong>再抓证据</strong>： <ul><li>Network：看首屏关键资源（HTML/CSS/JS/字体/首图）耗时、阻塞关系、是否命中缓存、压缩比、协议版本。</li><li>Performance：看长任务（Long Task）、主线程忙点、是否存在明显的解析/执行阻塞。</li><li>Lighthouse/Web Vitals：把“体感慢”对齐到可度量指标（LCP/TTFB/资源体积/阻塞时长）。</li></ul></li></ul><h3 id="_1-先保-可见-——骨架屏预渲染-直接拉低-lcp" tabindex="-1"><a class="header-anchor" href="#_1-先保-可见-——骨架屏预渲染-直接拉低-lcp" aria-hidden="true">#</a> 1. 先保“可见”——骨架屏预渲染（直接拉低 LCP）</h3><ul><li><strong>为什么先做这个</strong>：首屏慢最影响转化；骨架屏让“关键内容更早可见”，对 LCP 的改善最直接。</li><li><strong>怎么做（可讲实现）</strong>：骨架结构尽量接近最终布局，避免布局抖动；必要时对骨架做预生成/内联关键 CSS，减少等待 JS 执行才出内容。</li><li><strong>提升对比</strong>：LCP <strong>2.3s → 1.4s</strong>；同时重点解释如何控制 CLS（骨架与真实内容尺寸一致、占位策略）。</li></ul><h3 id="_2-再减-阻塞-——关键渲染路径-crp-梳理-css-字体-首图优先级" tabindex="-1"><a class="header-anchor" href="#_2-再减-阻塞-——关键渲染路径-crp-梳理-css-字体-首图优先级" aria-hidden="true">#</a> 2. 再减“阻塞”——关键渲染路径（CRP）梳理：CSS/字体/首图优先级</h3><ul><li><strong>浏览器原理串联</strong>：HTML 解析生成 DOM；CSS 会影响 render tree，<strong>关键 CSS 阻塞首屏渲染</strong>；字体可能触发 FOIT/FOUT；首图通常成为 LCP 候选。</li><li><strong>为什么这么做</strong>：如果首屏被 CSS/字体/首图阻塞，再快的接口也救不了 LCP。</li><li><strong>典型落地动作</strong>： <ul><li>关键 CSS 优先（提取/内联/拆分），非关键样式延后加载。</li><li>字体压缩/子集化，配合合理的 <code>font-display</code>，减少阻塞与重排。</li><li>首图优先级提升（preload/合理格式），非首屏图片懒加载。</li></ul></li><li><strong>验证方式</strong>：对比首屏关键资源 waterfall：阻塞链缩短、首屏 render 更早发生；CLS 保持可控。</li></ul><h3 id="_3-再降-下载与解析成本-——更小的包体与更少的无效代码" tabindex="-1"><a class="header-anchor" href="#_3-再降-下载与解析成本-——更小的包体与更少的无效代码" aria-hidden="true">#</a> 3. 再降“下载与解析成本”——更小的包体与更少的无效代码</h3><ul><li><strong>为什么选择精简体积</strong>：JS 体积不仅影响下载，还会影响 <strong>parse/compile/execute</strong>（主线程占用），在中低端机更明显。</li><li><strong>对应动作</strong>：精简 <code>core-js</code>、优化打包 CSS、字体压缩，做到“只给首屏必须的”。</li><li><strong>验证方式</strong>：对比 bundle 体积、首屏 chunk 数量、主线程长任务占比是否下降。</li></ul><h3 id="_4-再优化-传输层-——gzip-tls-1-3-让关键资源更快到达" tabindex="-1"><a class="header-anchor" href="#_4-再优化-传输层-——gzip-tls-1-3-让关键资源更快到达" aria-hidden="true">#</a> 4. 再优化“传输层”——gzip + TLS 1.3（让关键资源更快到达）</h3><ul><li><strong>浏览器原理串联</strong>：首屏每个关键请求都要经历连接建立/握手/传输；在弱网下握手与 RTT 很敏感。</li><li><strong>为什么选 TLS 1.3</strong>：减少握手开销、提升连接建立效率（配合 HTTP/2 复用更明显）；属于“全站收益”的优化点。</li><li><strong>为什么选 gzip</strong>：对文本资源（HTML/CSS/JS/JSON）压缩收益明显，直接减少传输字节数。</li><li><strong>验证方式</strong>：看响应头 <code>content-encoding</code>、压缩比、TTFB/下载耗时变化；对比首屏关键资源总下载字节与耗时。</li></ul><h3 id="_5-最后补-图片格式-——webp-兼顾体积与视觉" tabindex="-1"><a class="header-anchor" href="#_5-最后补-图片格式-——webp-兼顾体积与视觉" aria-hidden="true">#</a> 5. 最后补“图片格式”——WebP（兼顾体积与视觉）</h3><ul><li><strong>为什么放在后面</strong>：它主要改善的是“图片传输体积”，通常要在关键链路梳理完后做收尾提速；同时需要考虑兼容兜底。</li><li><strong>怎么做（可讲兜底）</strong>：按 UA/能力探测选择 WebP，旧环境回退 png/jpg；结合响应式图片与尺寸裁剪避免“传大图缩小显示”。</li><li><strong>验证方式</strong>：对比同一首图资源体积与下载耗时，确认 LCP 候选资源更快完成。</li></ul><h3 id="_6-回归与守护-防止-优化回退" tabindex="-1"><a class="header-anchor" href="#_6-回归与守护-防止-优化回退" aria-hidden="true">#</a> 6. 回归与守护（防止“优化回退”）</h3><ul><li><strong>回归矩阵</strong>：不同端（PC/移动）、不同网络（4G/弱网）、不同页面路径对比；重点盯 LCP/CLS/错误率。</li><li><strong>长期治理</strong>：性能预算（bundle/首屏资源上限）、上线前 Lighthouse/关键指标门禁、线上 Web Vitals 监控告警。</li></ul>',27),t={},s=(0,r(3744).Z)(t,[["render",function(e,l){return i}]])},3744:(e,l)=>{l.Z=(e,l)=>{const r=e.__vccOpts||e;for(const[e,i]of l)r[e]=i;return r}}}]);