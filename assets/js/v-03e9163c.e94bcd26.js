"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[5615],{2636:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-03e9163c",path:"/interview-prep/tech__vite.html",title:"Vite（ESM Dev Server 与构建取舍）",lang:"zh-CN",frontmatter:{id:"tech__vite",type:"tech",title:"Vite（ESM Dev Server 与构建取舍）",mastery:"not_started",tags:["vite","bundler","esm"],projects:["project__dji-user-center"],source_refs:[{source:"resume",file:"docs/job-description/web前端开发工程师-彭聪.md",anchor:"TODO"}],seed_refs:[{source:"outline",file:"docs/job-description/web前端开发工程师-彭聪-面试技术大纲.md",anchor:"TODO"}],updated_at:"2025-12-20T00:00:00.000Z"},excerpt:"",headers:[{level:2,title:"摘要（Auto）",slug:"摘要-auto",children:[]},{level:2,title:"建议追问（Auto）",slug:"建议追问-auto",children:[]},{level:2,title:"关联卡片",slug:"关联卡片",children:[]},{level:2,title:"在我项目中的角色与使用场景",slug:"在我项目中的角色与使用场景",children:[]},{level:2,title:"原理简述",slug:"原理简述",children:[]},{level:2,title:"对比表格",slug:"对比表格",children:[]},{level:2,title:"模拟问答",slug:"模拟问答",children:[]},{level:2,title:"手写代码区",slug:"手写代码区",children:[]},{level:2,title:"我的补充（Manual）",slug:"我的补充-manual",children:[]},{level:2,title:"复盘与反思（Learnings）",slug:"复盘与反思-learnings",children:[]},{level:2,title:"面试官追问（面试官视角）",slug:"面试官追问-面试官视角",children:[]}],git:{updatedTime:1766330718e3},filePathRelative:"interview-prep/tech__vite.md"}},3192:(n,a,s)=>{s.r(a),s.d(a,{default:()=>d});var e=s(6252);const t=(0,e.uE)('<h2 id="摘要-auto" tabindex="-1"><a class="header-anchor" href="#摘要-auto" aria-hidden="true">#</a> 摘要（Auto）</h2><ul><li>生成时间：2025-12-20</li><li>简历中出现的项目标题（提取）：大疆用户中心重构 / 大疆售后 RMS 系统重构 / 跨平台公告插件系统 / 大疆 DevOps 平台维护 / XDR 系统 - 魔方大屏 + 报表</li><li>面试大纲关键词（提取 Top10）：1）大疆用户中心重构：性能优化 + HTTP 原理 + Webpack 架构 / 性能指标与方法论 / 简历可落地点（结合你的“优化四板斧”） / HTTP 常考点（从“为什么变快”倒推） / Webpack 架构（工程化面试常考） / 按优化顺序，把方案“串起来”（排查 → 定位 → 选择 → 验证） / 0. 排查与基线（先把问题“量化”） / 1. 先保“可见”——骨架屏预渲染（直接拉低 LCP） / 2. 再减“阻塞”——关键渲染路径（CRP）梳理：CSS/字体/首图优先级 / 3. 再降“下载与解析成本”——更小的包体与更少的无效代码</li></ul><h2 id="建议追问-auto" tabindex="-1"><a class="header-anchor" href="#建议追问-auto" aria-hidden="true">#</a> 建议追问（Auto）</h2><ul><li>你为什么在该项目/场景里选择这个方案？替代方案为何不选？</li><li>最大一次事故/踩坑是什么？如何定位与回滚？</li><li>如果重做：架构/边界/工程化会怎么调整？</li></ul><h2 id="关联卡片" tabindex="-1"><a class="header-anchor" href="#关联卡片" aria-hidden="true">#</a> 关联卡片</h2>',5),l=(0,e.Uk)("项目： "),p=(0,e._)("code",null,"project__dji-user-center",-1),i=(0,e.Uk)("对比： "),o=(0,e._)("code",null,"matrix__bundler-webpack-vite-rollup",-1),r=(0,e._)("code",null,"tech__webpack",-1),c=(0,e.uE)('<h2 id="在我项目中的角色与使用场景" tabindex="-1"><a class="header-anchor" href="#在我项目中的角色与使用场景" aria-hidden="true">#</a> 在我项目中的角色与使用场景</h2><ul><li>使用场景：当项目“冷启动慢、HMR 慢、开发体验差”时，用 Vite 的 ESM Dev Server 提升迭代效率。</li><li>我在项目里的落地重点： <ul><li>评估迁移成本：插件生态、历史 Webpack loader 能否替代、老旧依赖是否支持 ESM。</li><li>统一 <code>env</code>、代理、别名、静态资源处理与 sourcemap 策略，避免“开发好用，上线翻车”。</li><li>对大依赖做 <code>optimizeDeps</code>/拆分，避免 dev 期频繁预构建导致的抖动。</li></ul></li></ul><h2 id="原理简述" tabindex="-1"><a class="header-anchor" href="#原理简述" aria-hidden="true">#</a> 原理简述</h2><p>一句话：Vite 开发期走“<strong>原生 ESM</strong>”，构建期走“<strong>Rollup</strong>”。</p><ul><li><strong>Dev Server（快的原因）</strong>： <ul><li>不再把全量依赖打包成一个 bundle 才启动；浏览器按需请求模块（ESM import）。</li><li>对第三方依赖做一次性预构建（esbuild）：把 commonjs/大量小文件依赖变成更适合浏览器的形式，提升启动与 HMR 稳定性。</li><li>HMR 基于模块依赖图精确失效，常见场景下比“全量重打包”更快。</li></ul></li><li><strong>Build（Rollup）</strong>： <ul><li>产物优化（tree-shaking、code-splitting、chunk 命名、manifest）主要由 Rollup 完成。</li><li>插件体系大体沿用 Rollup 插件生态（同时提供 Vite 专属 hook）。</li></ul></li></ul><p>权衡点（面试表达）：</p><ul><li>Vite 的优势在“开发期”，但<strong>生产构建链路</strong>也需要完整评估（legacy 浏览器、依赖 ESM 兼容、CSS 处理差异）。</li><li>复杂存量系统迁移要分阶段：先保证“构建产物一致性”，再追求“开发期极致速度”。</li></ul><h2 id="对比表格" tabindex="-1"><a class="header-anchor" href="#对比表格" aria-hidden="true">#</a> 对比表格</h2><table><thead><tr><th>维度</th><th>Vite</th><th>Webpack</th></tr></thead><tbody><tr><td>Dev 启动</td><td><strong>快</strong>（ESM 按需）</td><td>依赖 bundling，冷启动更慢</td></tr><tr><td>HMR</td><td>通常更快</td><td>成熟但大项目易慢</td></tr><tr><td>生态</td><td>快速增长（复用 Rollup）</td><td><strong>最成熟</strong></td></tr><tr><td>迁移成本</td><td>中（需核对插件/loader/兼容）</td><td>低（存量）</td></tr><tr><td>适合场景</td><td>新项目/中等存量、追求 DX</td><td>大存量/强定制/生态依赖深</td></tr><tr><td>回滚策略</td><td>旁路构建、按子模块迁移</td><td>原地演进</td></tr></tbody></table><h2 id="模拟问答" tabindex="-1"><a class="header-anchor" href="#模拟问答" aria-hidden="true">#</a> 模拟问答</h2><ul><li>[ ] Q1：Vite 为什么快？快在哪一段？ <ul><li>关键点：开发期不做全量 bundle，利用浏览器 ESM；依赖预构建用 esbuild；HMR 失效范围更小。</li></ul></li><li>[ ] Q2：<code>optimizeDeps</code> 是什么？什么时候要调？ <ul><li>本质：把依赖“预打包/扁平化”，减少 dev 期模块请求与 CJS 转换成本。</li><li>需要调的信号：启动抖动、某些依赖反复被预构建、依赖解析失败或 HMR 不稳定。</li></ul></li><li>[ ] Q3：迁移 Webpack → Vite 最大坑是什么？ <ul><li>loader 生态差异（尤其是非常定制的 loader）、某些依赖的 CJS/UMD 兼容、生产环境 polyfill/legacy。</li></ul></li></ul><h2 id="手写代码区" tabindex="-1"><a class="header-anchor" href="#手写代码区" aria-hidden="true">#</a> 手写代码区</h2><p>一个最小 Vite 插件（构建期注入版本信息）：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> Plugin <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vite&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">injectBuildMeta</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Plugin <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> buildId <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toISOString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">&#39;inject-build-meta&#39;</span><span class="token punctuation">,</span>\n    <span class="token function">transform</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>id<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&#39;.ts&#39;</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>id<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&#39;.tsx&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>code<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">&#39;__BUILD_ID__&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>\n      <span class="token keyword">return</span> code<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">&#39;__BUILD_ID__&#39;</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>buildId<span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="我的补充-manual" tabindex="-1"><a class="header-anchor" href="#我的补充-manual" aria-hidden="true">#</a> 我的补充（Manual）</h2><p>（不会被脚本覆盖：踩坑、细节、反例、排查路径）</p><h2 id="复盘与反思-learnings" tabindex="-1"><a class="header-anchor" href="#复盘与反思-learnings" aria-hidden="true">#</a> 复盘与反思（Learnings）</h2><ul><li>如果重做会怎么改？</li></ul><h2 id="面试官追问-面试官视角" tabindex="-1"><a class="header-anchor" href="#面试官追问-面试官视角" aria-hidden="true">#</a> 面试官追问（面试官视角）</h2><ul><li>[ ] 为什么选这个方案？替代方案为什么不选？</li><li>[!] 最大一次事故/踩坑是什么？如何定位与回滚？</li><li>[ ] 如果重做会怎么改？</li></ul>',20),u={},d=(0,s(3744).Z)(u,[["render",function(n,a){const s=(0,e.up)("RouterLink");return(0,e.wg)(),(0,e.iD)(e.HY,null,[t,(0,e._)("ul",null,[(0,e._)("li",null,[l,(0,e._)("ul",null,[(0,e._)("li",null,[(0,e.Wm)(s,{to:"/interview-prep/project__dji-user-center.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,e.w5)((()=>[p])),_:1})])])]),(0,e._)("li",null,[i,(0,e._)("ul",null,[(0,e._)("li",null,[(0,e.Wm)(s,{to:"/interview-prep/matrix__bundler-webpack-vite-rollup.html#%E5%AF%B9%E6%AF%94%E8%A1%A8%E6%A0%BC"},{default:(0,e.w5)((()=>[o])),_:1})]),(0,e._)("li",null,[(0,e.Wm)(s,{to:"/interview-prep/tech__webpack.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,e.w5)((()=>[r])),_:1})])])])]),c],64)}]])},3744:(n,a)=>{a.Z=(n,a)=>{const s=n.__vccOpts||n;for(const[n,e]of a)s[n]=e;return s}}}]);