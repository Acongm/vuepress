"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[3207],{417:(n,s,a)=>{a.r(s),a.d(s,{data:()=>t});const t={key:"v-46b85454",path:"/webpack/vite-%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86.html",title:"vite - 架构及原理",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"一、背景：为什么需要 Vite？",slug:"一、背景-为什么需要-vite",children:[]},{level:2,title:"二、Vite 的整体架构",slug:"二、vite-的整体架构",children:[]},{level:2,title:"三、开发模式原理详解",slug:"三、开发模式原理详解",children:[{level:3,title:"1. 启动流程",slug:"_1-启动流程",children:[]},{level:3,title:"2. 按需加载（On-Demand Loading）",slug:"_2-按需加载-on-demand-loading",children:[]},{level:3,title:"3. 热模块替换（HMR）",slug:"_3-热模块替换-hmr",children:[]}]},{level:2,title:"四、生产构建原理",slug:"四、生产构建原理",children:[]},{level:2,title:"五、插件系统（Plugin Architecture）",slug:"五、插件系统-plugin-architecture",children:[{level:3,title:"1. 通用 Hook（Dev + Build 都执行）",slug:"_1-通用-hook-dev-build-都执行",children:[]},{level:3,title:"2. Rollup Hook（Build 阶段为主）",slug:"_2-rollup-hook-build-阶段为主",children:[]},{level:3,title:"示例：自定义插件结构",slug:"示例-自定义插件结构",children:[]}]},{level:2,title:"六、关键设计优势总结",slug:"六、关键设计优势总结",children:[]},{level:2,title:"七、与 Webpack 的根本区别",slug:"七、与-webpack-的根本区别",children:[]},{level:2,title:"八、延伸思考：Vite 的局限性",slug:"八、延伸思考-vite-的局限性",children:[]},{level:2,title:"九、推荐深入资源",slug:"九、推荐深入资源",children:[]}],git:{updatedTime:1770275296e3},filePathRelative:"webpack/vite-架构及原理.md"}},7907:(n,s,a)=>{a.r(s),a.d(s,{default:()=>h});var t=a(6252);const e=(0,t.uE)('<h1 id="vite-架构及原理" tabindex="-1"><a class="header-anchor" href="#vite-架构及原理" aria-hidden="true">#</a> vite - 架构及原理</h1><p>要深入理解 <strong>Vite 的架构与原理</strong>，我们需要从它解决的问题出发，剖析其<strong>核心设计思想、模块系统、构建流程、插件机制</strong>以及<strong>开发/生产双模式的实现差异</strong>。以下是面向前端开发者（尤其是熟悉 Webpack 的你）的系统性剖析。</p><hr><h2 id="一、背景-为什么需要-vite" tabindex="-1"><a class="header-anchor" href="#一、背景-为什么需要-vite" aria-hidden="true">#</a> 一、背景：为什么需要 Vite？</h2><p>传统构建工具（如 Webpack）在开发阶段需要：</p><ol><li><strong>打包整个应用</strong>（包括 node_modules）；</li><li><strong>启动慢</strong>（大型项目可能数十秒）；</li><li><strong>HMR（热更新）需重建依赖图</strong>，效率低。</li></ol><p>而现代浏览器（Chrome 61+、Safari 10.1+ 等）早已支持 <strong>原生 ES 模块（ESM）</strong>：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/src/main.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Vite 正是基于这一事实，提出 <strong>“开发时不打包，生产时再打包”</strong> 的理念。</p><hr><h2 id="二、vite-的整体架构" tabindex="-1"><a class="header-anchor" href="#二、vite-的整体架构" aria-hidden="true">#</a> 二、Vite 的整体架构</h2><p>Vite 由两大核心部分组成：</p><table><thead><tr><th>模式</th><th>核心技术</th><th>职责</th></tr></thead><tbody><tr><td><strong>开发服务器（Dev Server）</strong></td><td>Koa + ESM + esbuild</td><td>提供按需加载、HMR、模块转换</td></tr><tr><td><strong>生产构建器（Builder）</strong></td><td>Rollup</td><td>打包、Tree-shaking、代码分割、压缩</td></tr></tbody></table><p>它们共享同一套配置（<code>vite.config.ts</code>）和插件系统。</p><blockquote><p>💡 架构图简化为：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>源码（TS/JSX/CSS等）\n    ↓\n[开发模式] → Koa Dev Server → 浏览器（原生 ESM）\n    ↓\n[生产模式] → Rollup → 静态资源（JS/CSS/HTML）\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></blockquote><hr><h2 id="三、开发模式原理详解" tabindex="-1"><a class="header-anchor" href="#三、开发模式原理详解" aria-hidden="true">#</a> 三、开发模式原理详解</h2><h3 id="_1-启动流程" tabindex="-1"><a class="header-anchor" href="#_1-启动流程" aria-hidden="true">#</a> 1. 启动流程</h3><ol><li><strong>启动 Koa 服务器</strong>（默认端口 5173）；</li><li><strong>预构建依赖（Dep Pre-bundling）</strong>： <ul><li>扫描 <code>import</code> 语句，提取依赖（如 <code>react</code>, <code>antd</code>）；</li><li>使用 <strong>esbuild</strong>（Rust 编写，速度比 Webpack 快 10–100 倍）将 CJS/UMD 依赖转换为 ESM；</li><li>缓存到 <code>node_modules/.vite/</code>，避免重复构建；</li></ul></li><li><strong>等待浏览器请求</strong>（如 <code>http://localhost:5173/src/main.tsx</code>）。</li></ol><h3 id="_2-按需加载-on-demand-loading" tabindex="-1"><a class="header-anchor" href="#_2-按需加载-on-demand-loading" aria-hidden="true">#</a> 2. 按需加载（On-Demand Loading）</h3><ul><li><p>浏览器请求 <code>main.tsx</code> → Vite 拦截请求；</p></li><li><p>Vite <strong>实时编译</strong>该文件（TS → JS、JSX → JS、CSS Modules 处理等）；</p></li><li><p>返回合法 ESM 代码，其中 <code>import</code> 路径被重写为可访问的 URL：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 源码</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;antd&#39;</span>\n<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">&#39;./App&#39;</span>\n\n<span class="token comment">// Vite 返回给浏览器</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;/node_modules/.vite/deps/antd.js?v=abc123&#39;</span>\n<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">&#39;/src/App.tsx?t=1700000000000&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><p>浏览器递归加载这些模块，形成依赖树。</p></li></ul><blockquote><p>✅ 关键：<strong>不打包，只转换单个文件</strong>，启动速度 ≈ 0。</p></blockquote><h3 id="_3-热模块替换-hmr" tabindex="-1"><a class="header-anchor" href="#_3-热模块替换-hmr" aria-hidden="true">#</a> 3. 热模块替换（HMR）</h3><ul><li>通过 WebSocket 建立浏览器与服务器通信；</li><li>当文件变化时： <ul><li>Vite 分析<strong>最小受影响模块集</strong>；</li><li>向浏览器发送 <code>update</code> 消息（含模块 ID 和新代码）；</li><li>框架插件（如 <code>@vitejs/plugin-react</code>）调用 <code>import.meta.hot.accept()</code> 执行替换；</li></ul></li><li>React 组件可实现<strong>状态保留的热更新</strong>（Fast Refresh）。</li></ul><blockquote><p>🌟 对比 Webpack HMR：Vite 无需重建整个 chunk，只更新变更模块，速度极快。</p></blockquote><hr><h2 id="四、生产构建原理" tabindex="-1"><a class="header-anchor" href="#四、生产构建原理" aria-hidden="true">#</a> 四、生产构建原理</h2><p>开发时不打包，但生产环境仍需打包优化。Vite 使用 <strong>Rollup</strong> 完成：</p><ol><li><strong>入口分析</strong>：从 HTML 文件（如 <code>index.html</code>）提取 <code>&lt;script type=&quot;module&quot;&gt;</code> 入口；</li><li><strong>依赖解析</strong>：构建完整模块图；</li><li><strong>代码优化</strong>： <ul><li>Tree-shaking（移除未引用代码）；</li><li>代码分割（动态 import 自动分块）；</li><li>资源哈希（<code>[name].[hash].js</code>）；</li><li>压缩（Terser 或 esbuild）；</li></ul></li><li><strong>输出静态目录</strong>（默认 <code>dist/</code>）。</li></ol><blockquote><p>⚠️ 注意：Vite 的生产构建<strong>不使用 esbuild 打包</strong>（因 esbuild 缺少 Tree-shaking 等高级功能），但可配置 <code>build.minify: &#39;esbuild&#39;</code> 仅用于压缩。</p></blockquote><hr><h2 id="五、插件系统-plugin-architecture" tabindex="-1"><a class="header-anchor" href="#五、插件系统-plugin-architecture" aria-hidden="true">#</a> 五、插件系统（Plugin Architecture）</h2><p>Vite 插件基于 <strong>Rollup 插件接口</strong>扩展，支持两种模式：</p><h3 id="_1-通用-hook-dev-build-都执行" tabindex="-1"><a class="header-anchor" href="#_1-通用-hook-dev-build-都执行" aria-hidden="true">#</a> 1. 通用 Hook（Dev + Build 都执行）</h3><ul><li><code>config</code>：修改最终配置；</li><li><code>configureServer</code>：扩展 Dev Server（如添加中间件）；</li><li><code>transformIndexHtml</code>：修改 HTML 内容。</li></ul><h3 id="_2-rollup-hook-build-阶段为主" tabindex="-1"><a class="header-anchor" href="#_2-rollup-hook-build-阶段为主" aria-hidden="true">#</a> 2. Rollup Hook（Build 阶段为主）</h3><ul><li><code>resolveId</code>：自定义模块解析（如虚拟模块 <code>virtual:my-plugin</code>）；</li><li><code>load</code>：提供模块内容；</li><li><code>transform</code>：转换单个模块（如处理 <code>.md</code> 文件）；</li><li><code>generateBundle</code>：修改最终输出。</li></ul><h3 id="示例-自定义插件结构" tabindex="-1"><a class="header-anchor" href="#示例-自定义插件结构" aria-hidden="true">#</a> 示例：自定义插件结构</h3><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// my-vite-plugin.ts</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">myPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">&#39;my-plugin&#39;</span><span class="token punctuation">,</span>\n    enforce<span class="token operator">:</span> <span class="token string">&#39;pre&#39;</span><span class="token punctuation">,</span> <span class="token comment">// 执行顺序：pre &lt; normal &lt; post</span>\n    <span class="token function">config</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> <span class="token punctuation">{</span> command <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// command: &#39;serve&#39; 或 &#39;build&#39;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">configureServer</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      server<span class="token punctuation">.</span>middlewares<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 自定义中间件</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">transform</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&#39;.foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token punctuation">{</span> code<span class="token operator">:</span> <span class="token function">compileFoo</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><blockquote><p>✅ 对你而言：可复用大量 Rollup 插件，也可编写针对 Backstage 插件加载的自定义插件。</p></blockquote><hr><h2 id="六、关键设计优势总结" tabindex="-1"><a class="header-anchor" href="#六、关键设计优势总结" aria-hidden="true">#</a> 六、关键设计优势总结</h2><table><thead><tr><th>特性</th><th>实现机制</th><th>带来的优势</th></tr></thead><tbody><tr><td><strong>极速启动</strong></td><td>ESM + 按需加载</td><td>无视项目大小，启动 &lt; 500ms</td></tr><tr><td><strong>瞬时 HMR</strong></td><td>精准模块更新</td><td>修改即生效，状态不丢失</td></tr><tr><td><strong>零配置</strong></td><td>内置转换器（TS/JSX/CSS 等）</td><td>无需 loader 配置</td></tr><tr><td><strong>生产可靠</strong></td><td>Rollup 构建</td><td>成熟的 Tree-shaking 和优化</td></tr><tr><td><strong>生态兼容</strong></td><td>Rollup 插件系统</td><td>无缝集成现有工具链</td></tr></tbody></table><hr><h2 id="七、与-webpack-的根本区别" tabindex="-1"><a class="header-anchor" href="#七、与-webpack-的根本区别" aria-hidden="true">#</a> 七、与 Webpack 的根本区别</h2><table><thead><tr><th>维度</th><th>Webpack</th><th>Vite</th></tr></thead><tbody><tr><td><strong>开发哲学</strong></td><td>“一切皆模块，必须打包”</td><td>“浏览器已支持 ESM，无需开发时打包”</td></tr><tr><td><strong>依赖处理</strong></td><td>全量解析打包</td><td>仅预构建 + 按需加载</td></tr><tr><td><strong>HMR 粒度</strong></td><td>Chunk 级</td><td>Module 级</td></tr><tr><td><strong>配置复杂度</strong></td><td>高（loader/plugin 分离）</td><td>低（统一插件接口）</td></tr><tr><td><strong>适用场景</strong></td><td>旧浏览器、复杂定制</td><td>现代浏览器、追求 DX</td></tr></tbody></table><hr><h2 id="八、延伸思考-vite-的局限性" tabindex="-1"><a class="header-anchor" href="#八、延伸思考-vite-的局限性" aria-hidden="true">#</a> 八、延伸思考：Vite 的局限性</h2><ol><li><strong>不支持 IE11</strong>（因依赖 ESM）；</li><li><strong>大型 monorepo</strong> 中依赖预构建可能变慢（但可缓存）；</li><li><strong>自定义构建逻辑</strong> 比 Webpack 少（但 Rollup 已足够强大）。</li></ol><blockquote><p>但对你当前技术栈（React + AntD + TS + 现代浏览器），Vite 是<strong>更优解</strong>。</p></blockquote><hr><h2 id="九、推荐深入资源" tabindex="-1"><a class="header-anchor" href="#九、推荐深入资源" aria-hidden="true">#</a> 九、推荐深入资源</h2>',52),l=(0,t._)("li",null,"Vite 源码仓库：https://github.com/vitejs/vite",-1),o=(0,t._)("li",null,[(0,t.Uk)("核心模块： "),(0,t._)("ul",null,[(0,t._)("li",null,[(0,t._)("code",null,"packages/vite/src/node/server/"),(0,t.Uk)("：Dev Server 逻辑")]),(0,t._)("li",null,[(0,t._)("code",null,"packages/vite/src/node/build.ts"),(0,t.Uk)("：生产构建入口")])])],-1),p=(0,t.Uk)("尤雨溪演讲："),r={href:"https://www.youtube.com/watch?v=AdNJ3fydeao",target:"_blank",rel:"noopener noreferrer"},i=(0,t.Uk)("Rethinking Reactivity & Tooling"),c=(0,t._)("hr",null,null,-1),d=(0,t._)("p",null,[(0,t.Uk)("如果你希望我结合你的实际项目（如 "),(0,t._)("code",null,"my-ticket-agent"),(0,t.Uk)(" 或 Backstage 插件）给出 Vite 迁移方案或配置示例，也可以告诉我！")],-1),u={},h=(0,a(3744).Z)(u,[["render",function(n,s){const a=(0,t.up)("ExternalLinkIcon");return(0,t.wg)(),(0,t.iD)(t.HY,null,[e,(0,t._)("ul",null,[l,o,(0,t._)("li",null,[p,(0,t._)("a",r,[i,(0,t.Wm)(a)])])]),c,d],64)}]])}}]);