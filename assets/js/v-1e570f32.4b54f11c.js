"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[3856],{6413:(e,r,a)=>{a.r(r),a.d(r,{data:()=>i});const i={key:"v-1e570f32",path:"/job-description/ASK_RECORD_BOOK_AI.html",title:"模拟面试回答稿（书面版 + 口语版）",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"A. 书面版（结构化答题稿）",slug:"a-书面版-结构化答题稿",children:[{level:3,title:"0）固定结构（背诵用）",slug:"_0-固定结构-背诵用",children:[]},{level:3,title:"1）自我介绍（60-90 秒）",slug:"_1-自我介绍-60-90-秒",children:[]},{level:3,title:"2）项目一：大疆用户中心重构（2022.02-2022.09）",slug:"_2-项目一-大疆用户中心重构-2022-02-2022-09",children:[]},{level:3,title:"3）项目二：大疆售后 RMS 系统重构（2022.10-2024.04）",slug:"_3-项目二-大疆售后-rms-系统重构-2022-10-2024-04",children:[]},{level:3,title:"4）项目三：跨平台公告插件系统（2023.02-2023.03）",slug:"_4-项目三-跨平台公告插件系统-2023-02-2023-03",children:[]},{level:3,title:"技术点 1：多模式植入方案怎么设计的？（问题三段式）",slug:"技术点-1-多模式植入方案怎么设计的-问题三段式",children:[]},{level:3,title:"技术点 2：为什么选择 Preact？（问题三段式）",slug:"技术点-2-为什么选择-preact-问题三段式",children:[]},{level:3,title:"技术点 3：为什么选择 Rollup 打包？（问题三段式）",slug:"技术点-3-为什么选择-rollup-打包-问题三段式",children:[]},{level:3,title:"5）项目四：大疆 DevOps 平台维护（2024.03-2025.04）",slug:"_5-项目四-大疆-devops-平台维护-2024-03-2025-04",children:[]},{level:3,title:"6）项目五：XDR 系统 - 魔方大屏 + 报表（2025.05-2025.12）",slug:"_6-项目五-xdr-系统-魔方大屏-报表-2025-05-2025-12",children:[]},{level:3,title:"7）常见缩写（面试时可随口解释）",slug:"_7-常见缩写-面试时可随口解释",children:[]}]}],git:{updatedTime:1768839369e3},filePathRelative:"job-description/ASK_RECORD_BOOK_AI.md"}},4984:(e,r,a)=>{a.r(r),a.d(r,{default:()=>k});var i=a(6252);const t=(0,i._)("h1",{id:"模拟面试回答稿-书面版-口语版",tabindex:"-1"},[(0,i._)("a",{class:"header-anchor",href:"#模拟面试回答稿-书面版-口语版","aria-hidden":"true"},"#"),(0,i.Uk)(" 模拟面试回答稿（书面版 + 口语版）")],-1),n=(0,i._)("p",null,"使用方法：",-1),o=(0,i._)("li",null,"书面版用于“投递材料/复盘整理/背诵结构”。",-1),s=(0,i._)("li",null,"口语版用于“现场表达/语气自然/信息密度适中”。",-1),d=(0,i.Uk)("代码相关内容单独放在 "),p=(0,i.Uk)("docs/job-description/ASK_CODE_EXAMPLES.md"),h=(0,i.Uk)("。"),l=(0,i.uE)('<hr><h2 id="a-书面版-结构化答题稿" tabindex="-1"><a class="header-anchor" href="#a-书面版-结构化答题稿" aria-hidden="true">#</a> A. 书面版（结构化答题稿）</h2><h3 id="_0-固定结构-背诵用" tabindex="-1"><a class="header-anchor" href="#_0-固定结构-背诵用" aria-hidden="true">#</a> 0）固定结构（背诵用）</h3><p><strong>项目（3 段）</strong> 1）项目角色（背景） 2）做了什么事（关键动作/方法/协作） 3）价值（指标/成本/质量/稳定性）</p><p><strong>问题（3 段）</strong> 1）先把问题说清楚（影响是什么） 2）结合项目背景（为什么在你这个场景更难） 3）解决方案（定位 → 策略 → 落地 → 验证闭环）</p><hr><h3 id="_1-自我介绍-60-90-秒" tabindex="-1"><a class="header-anchor" href="#_1-自我介绍-60-90-秒" aria-hidden="true">#</a> 1）自我介绍（60-90 秒）</h3><p><strong>面试官：请做一个自我介绍。</strong></p><p>你好，我叫彭聪，江西财经大学计算机应用技术专业，2016 年开始做前端，2019 年开始承担前端负责人工作。</p><p>我这几年主要做三类事情： 1）复杂系统重构与长期治理（用户中心入口、售后工单 RMS）； 2）工程化与质量体系（TypeScript/ESLint/CI、组件沉淀与物料化、低代码提效）； 3）跨系统能力与全栈交付（公告插件 SDK、DevOps 平台、NestJS 报表与定时任务）。</p><p>我可以先从“用户中心重构：如何在高风险入口做增量演进 + 性能链路治理”开始讲。</p><hr><h3 id="_2-项目一-大疆用户中心重构-2022-02-2022-09" tabindex="-1"><a class="header-anchor" href="#_2-项目一-大疆用户中心重构-2022-02-2022-09" aria-hidden="true">#</a> 2）项目一：大疆用户中心重构（2022.02-2022.09）</h3><h4 id="用户中心-项目三段式" tabindex="-1"><a class="header-anchor" href="#用户中心-项目三段式" aria-hidden="true">#</a> 用户中心：项目三段式</h4><p><strong>面试官：介绍一下用户中心重构。</strong></p><p><strong>1）项目角色（背景）</strong></p><ul><li>角色：项目前端负责人。</li><li>背景：核心登录入口，1000W+ 注册用户，日均登录 120W+。</li><li>难点：PC/移动两套代码长期分裂；老工程依赖/构建链路历史包袱重；登录链路“首屏即转化”，必须可灰度、可回滚。</li><li>选型原则：稳定优先、增量演进、可度量；保留 Vue2 + webpack 主体，引入 TypeScript 与工程约束。</li></ul><p><strong>2）做了什么事（关键动作）</strong></p><p>1）多端统一：用响应式融合把 PC/移动两套实现收敛为一套代码（布局、组件、资源策略统一）。 2）性能链路治理：围绕“资源体积、关键资源优先级、主线程任务、弱网兜底”做专项；建立从定位到验证的闭环（产物 diff + 线上 RUM/埋点看板）。 3）工程治理：拆包与长缓存、构建产物分析、字体/图片/第三方脚本治理，保证“可回滚 + 风险可控”。</p><p><strong>3）价值（结果）</strong></p><ul><li>维护成本：PC/移动统一后维护成本下降约 50%。</li><li>业务指标：登录转化率提升 18%，客诉率下降 12%。</li><li>性能体验：首屏关键指标显著改善（口径：线上 RUM 采样；如需可展开具体指标与采样方式）。</li></ul><hr><h4 id="技术点-1-打包优化怎么实现的-问题三段式" tabindex="-1"><a class="header-anchor" href="#技术点-1-打包优化怎么实现的-问题三段式" aria-hidden="true">#</a> 技术点 1：打包优化怎么实现的？（问题三段式）</h4><p><strong>面试官：你提到打包优化，具体怎么做的？</strong></p><p><strong>1）突出问题</strong></p><p>老项目容易出现“包体积膨胀 + 缓存命中差 + 解析执行慢”，直接拖慢首屏下载与主线程执行；登录页对转化敏感，这类问题必须优先治理。</p><p><strong>2）结合项目背景</strong></p><p>用户中心是入口页，历史包袱集中在 polyfill/重复依赖/字体图片/首屏不需要模块。我的做法是先把“体积从哪来、改动会影响什么”做可视化（bundle analyzer + 产物 diff），再按风险与收益排序。</p><p><strong>3）解决方案（定位 → 策略 → 落地 → 验证）</strong></p><p>1）polyfill：用 browserslist 固定兼容矩阵，Babel 按需注入（避免“过度兼容”）；定期复查 core-js/polyfill 引入来源。 2）拆包与缓存：<code>splitChunks</code> 拆稳定依赖与公共业务；<code>runtimeChunk: &#39;single&#39;</code> 稳定 runtime；路由/功能动态 <code>import()</code> 降低首屏负担；JS/CSS 用 <code>contenthash</code> 保证长缓存可用。 3）CSS 与副作用：CSS 提取与压缩，明确 <code>sideEffects</code> 保留样式类副作用文件，避免 Tree Shaking 误删样式。 4）静态资源：字体 woff2 + 子集化；图片压缩/格式升级；图标 SVG sprite；统一 CDN 缓存策略。 5）验证闭环：每次改动都做“产物体积 diff + 线上 RUM 对比”，确保优化体积能真实转化为体验收益。</p>',30),c=(0,i.Uk)("（代码示例在 "),g=(0,i.Uk)("docs/job-description/ASK_CODE_EXAMPLES.md"),u=(0,i.Uk)(" 的 Webpack/产物分析小节。）"),_=(0,i.uE)('<hr><h4 id="技术点-2-更快的加载怎么实现的-问题三段式" tabindex="-1"><a class="header-anchor" href="#技术点-2-更快的加载怎么实现的-问题三段式" aria-hidden="true">#</a> 技术点 2：更快的加载怎么实现的？（问题三段式）</h4><p><strong>面试官：你说“更快的加载”，具体做了哪些？</strong></p><p><strong>1）突出问题</strong></p><p>首屏慢通常是“连接/握手耗时 + 关键资源优先级不合理 + 渲染阻塞/主线程繁忙”的叠加；入口页一慢就影响转化，必须把关键链路做到可控。</p><p><strong>2）结合项目背景</strong></p><p>我先用 Network/Performance 把瓶颈分型：TTFB/连接耗时/关键资源阻塞/主线程 Long Task；再把第三方脚本单独隔离对比（“有/无三方脚本”两条链路）。</p><p><strong>3）解决方案</strong></p><p>1）网络侧协同（解决：握手 RTT、连接数、并发效率）</p><ul><li><p>HTTP/2：多路复用减少“为并发开多连接”的开销，资源多的页面并发更稳；降低应用层 HOL（队头阻塞）对首屏的影响。</p></li><li><p>TLS 1.3：握手轮次更少（1-RTT，恢复可到 0-RTT），主要解决“TLS 握手慢导致的等待”。</p></li><li><p>连接复用/会话恢复：复用已建连与会话，减少重复握手与慢启动（收益与 RTT/命中有关）。 2）资源优先级（解决：关键资源排队、关键路径被低价值资源抢带宽）</p></li><li><p><code>dns-prefetch</code>/<code>preconnect</code>：提前完成 DNS/TCP/TLS，减少关键域名首次请求等待。</p></li><li><p><code>preload</code>/<code>modulepreload</code>：对确定影响首屏的 CSS/字体/关键 chunk 提前高优先级拉取。</p></li><li><p><code>prefetch</code>：只用于“下一跳可能用到”的低优先级资源，避免抢首屏带宽。 3）关键渲染路径（解决：解析阻塞、渲染阻塞、主线程 Long Task）</p></li><li><p>CSS：关键 CSS 靠前（必要时关键 CSS 提取）；字体配合 <code>font-display</code>，降低 FOIT 风险。</p></li><li><p>JS：业务脚本默认 <code>defer</code>（保证顺序且不阻塞解析）；非关键逻辑延后/拆分，降低 Long Task。 4）压缩与缓存（解决：传输体积与重复下载）</p></li><li><p>gzip/brotli + CDN 强缓存；配合 <code>cache-control/etag</code> 控制更新与回滚。 5）三方脚本（解决：不确定性拖垮首屏与交互）</p></li><li><p>延后加载 + 超时/失败降级 + 错误隔离，上线后重点看失败率、错误率与 LCP 波动。</p></li></ul>',10),f=(0,i.Uk)("（代码示例在 "),S=(0,i.Uk)("docs/job-description/ASK_CODE_EXAMPLES.md"),b=(0,i.Uk)(" 的 Resource Hints/RUM 上报小节。）"),m=(0,i.uE)('<hr><h4 id="技术点-3-js-加载顺序怎么实现的-问题三段式" tabindex="-1"><a class="header-anchor" href="#技术点-3-js-加载顺序怎么实现的-问题三段式" aria-hidden="true">#</a> 技术点 3：JS 加载顺序怎么实现的？（问题三段式）</h4><p><strong>面试官：JS 加载顺序/优先级你是怎么做的？</strong></p><p><strong>1）突出问题</strong></p><p>脚本一多就容易“阻塞解析 + 执行顺序不可控 + Long Task 卡交互”。登录页还常带埋点/风控/三方 SDK，抢主线程会让用户感觉“点了没反应”。</p><p><strong>2）结合项目背景</strong></p><p>入口页既要保证业务脚本稳定顺序，又要降低三方脚本对首屏与交互的干扰。</p><p><strong>3）解决方案</strong></p><p>1）加载分层（解决：阻塞解析、顺序不可控）</p><ul><li><p>业务关键脚本：<code>defer</code>，不阻塞解析且顺序可控。</p></li><li><p>三方脚本：能延后就延后；必须并行加载的用 <code>async</code>（不保证顺序），并加超时、失败降级与错误隔离。 2）模块拆分（解决：首屏下载/解析负担过重）</p></li><li><p>路由/功能维度动态 <code>import()</code>，首屏不加载“登录后才用”的代码。 3）执行控制（解决：等待不可控、串行太慢、失败难兜底）</p></li><li><p>用 <code>async/await</code> 把初始化流程显式化：关键依赖 <code>await</code> 保证顺序；可并行的用 <code>Promise.all/Promise.allSettled</code> 并发；三方初始化加 timeout + fallback。 4）主线程治理（解决：Long Task 卡交互）</p></li><li><p>非关键计算放到 idle/延时；重计算用 Worker；渲染侧避免一次性渲染过多（分页/虚拟化）。 5）可回收（解决：越用越卡/内存泄漏）</p></li><li><p>统一管理三方 SDK 的事件监听/定时器/observer 的注册与销毁。</p></li></ul><hr><h4 id="技术点-4-webp-怎么做兜底处理-问题三段式" tabindex="-1"><a class="header-anchor" href="#技术点-4-webp-怎么做兜底处理-问题三段式" aria-hidden="true">#</a> 技术点 4：WebP 怎么做兜底处理？（问题三段式）</h4><p><strong>面试官：WebP 升级怎么做兼容？</strong></p><p><strong>1）突出问题</strong></p><p>图片是首屏体积大户，WebP 能显著降体积；但 WebView/老浏览器支持不一致，没兜底会出现“关键图片缺失”，属于可用性事故。</p><p><strong>2）结合项目背景</strong></p><p>用户中心覆盖面广，设备与 WebView 碎片化严重，必须把“收益/风险/回滚”一起设计。</p><p><strong>3）解决方案</strong></p><p>1）前端兜底：<code>&lt;picture&gt;</code>/<code>srcset</code> 优先 WebP，自动 fallback 到 jpg/png。 2）构建双份：同一资源产出 webp + 原格式，保证缓存 key/路径策略稳定。 3）能力选择：必要时做能力探测并缓存结果；服务端可基于 <code>Accept</code> 内容协商（CDN 同样可配）。 4）监控回滚：关注图片失败率、LCP 波动与错误率，出现异常能快速回退。</p><hr><h3 id="_3-项目二-大疆售后-rms-系统重构-2022-10-2024-04" tabindex="-1"><a class="header-anchor" href="#_3-项目二-大疆售后-rms-系统重构-2022-10-2024-04" aria-hidden="true">#</a> 3）项目二：大疆售后 RMS 系统重构（2022.10-2024.04）</h3><h4 id="rms-项目三段式" tabindex="-1"><a class="header-anchor" href="#rms-项目三段式" aria-hidden="true">#</a> RMS：项目三段式</h4><p><strong>面试官：说说 RMS 系统重构。</strong></p><h5 id="_1-项目角色-背景" tabindex="-1"><a class="header-anchor" href="#_1-项目角色-背景" aria-hidden="true">#</a> 1）项目角色（背景）</h5><ul><li>角色：项目前端负责人。</li><li>背景：全球售后工单系统，日均处理工单 1W+，页面 100+，权限链路复杂。</li><li>难点：历史代码风格与质量不统一，类型与边界不清，复杂度上升后“人肉 Review 守不住”。</li><li>选型：统一 React 18 + TypeScript + Umi + UI 体系，目标是把工程基础打牢，保证可协作与可持续。</li></ul><h5 id="_2-做了什么事" tabindex="-1"><a class="header-anchor" href="#_2-做了什么事" aria-hidden="true">#</a> 2）做了什么事</h5><p>1）工程基础 0-1：ESLint/TypeScript 规则体系、目录分层与模块边界、提交前与 CI 卡点。 2）复用体系：沉淀高可用业务组件（权限/空态/错误/加载/失败重试一致），逐步物料化。 3）低代码提效：贡献/接入可复用物料，在表单/配置类页面规模化落地；同步补齐 schema 版本化与迁移策略。</p><h5 id="_3-价值" tabindex="-1"><a class="header-anchor" href="#_3-价值" aria-hidden="true">#</a> 3）价值</h5><ul><li>协作效率：整体开发效率提升约 30%。</li><li>质量稳定：团队 Bug 率下降约 25%，UI/交互一致性明显提升。</li></ul><hr><h4 id="技术点-1-eslint-规范制定怎么实现的-问题三段式" tabindex="-1"><a class="header-anchor" href="#技术点-1-eslint-规范制定怎么实现的-问题三段式" aria-hidden="true">#</a> 技术点 1：ESLint 规范制定怎么实现的？（问题三段式）</h4><p><strong>面试官：你说制定 ESLint 规范，怎么落地的？</strong></p><p><strong>1）突出问题</strong></p><p>多人协作里“风格不统一 + 缺少质量约束”会直接带来隐性 bug（未处理 Promise/any 扩散/变量遮蔽）、import 混乱与边界失守；系统越大，靠人肉 Review 越守不住。</p><p><strong>2）结合项目背景</strong></p><p>RMS 页面与权限链路复杂，我先把历史问题分类（变量/类型/import/异步/模块边界），并把规则分级（必须 error / 建议 warn / 暂缓），保证团队接受度与落地速度。</p><p><strong>3）解决方案</strong></p><p>1）规则体系 0-1：TypeScript parser + typescript-eslint/import/promise/react-hooks 等组合；重点规则先卡“会出错/会劣化”的点（禁止隐式 any、Promise 必须处理、hooks、import 分组排序）。 2）模块边界：用规则/约定限制跨层引用，让架构边界靠工具守住。 3）自动修复：Prettier 只管格式；ESLint 管质量；import 排序尽量可 autofix，减少 Review 争议。 4）落地策略：先卡新增/修改（CI 必过），存量分目录逐步收紧，避免“一刀切炸掉存量”。 5）工程集成：lint-staged + CI + MR 规则，确保规范成为流水线能力。</p><hr><h4 id="技术点-2-业务组件高可用怎么实现的-并为低代码物料做铺垫-问题三段式" tabindex="-1"><a class="header-anchor" href="#技术点-2-业务组件高可用怎么实现的-并为低代码物料做铺垫-问题三段式" aria-hidden="true">#</a> 技术点 2：业务组件高可用怎么实现的？（并为低代码物料做铺垫｜问题三段式）</h4><p><strong>面试官：业务组件高可用你具体做了什么？</strong></p><p><strong>1）突出问题</strong></p><p>复杂系统复用组件会遇到“边界条件爆炸”（权限/空数据/慢接口/失败重试/多语言）。只为单页写会变成大量 copy；直接复用又怕改崩别处，所以组件必须边界自洽、可观测、可扩展。</p><p><strong>2）结合项目背景</strong></p><p>RMS 模块多、权限多，组件要能在无权限/空数据/失败/慢接口等场景下保持一致体验与可控行为。</p><p><strong>3）解决方案</strong></p><p>1）边界三件套：loading/empty/error 统一；关键区域 Error Boundary 隔离，避免单点崩溃扩散。 2）契约化：Props 分层（必选/可选/默认值）；类型定义收口，避免 any 扩散；对外 API 稳定，扩展点用 render props/slot。 3）可观测与降级：关键失败上报 + 开关降级，做到“能发现、能止损”。 4）物料化：整理组件的配置项/默认值/校验/事件为物料描述，为后续 schema 驱动铺路。</p><hr><h4 id="技术点-3-低代码平台接入落地怎么实现的-贡献组件-→-深度使用-→-提效-问题三段式" tabindex="-1"><a class="header-anchor" href="#技术点-3-低代码平台接入落地怎么实现的-贡献组件-→-深度使用-→-提效-问题三段式" aria-hidden="true">#</a> 技术点 3：低代码平台接入落地怎么实现的？（贡献组件 → 深度使用 → 提效｜问题三段式）</h4><p><strong>面试官：低代码平台你是怎么落地的？</strong></p><p><strong>1）突出问题</strong></p><p>表单/配置页是“高重复 + 高变更”：字段/规则一改就要重新开发与回归，长期吞噬产能。要提效必须标准化组件 + schema 驱动，否则低代码会变成新的维护负担。</p><p><strong>2）结合项目背景</strong></p><p>RMS 大量页面是“字段差异 + 规则差异”，非常适合 schema；但也存在复杂交互页面，需要明确边界：哪些适合低代码，哪些必须手写。</p><p><strong>3）解决方案</strong></p><p>1）路径设计：先试点“结构稳定、收益可控”的页面；沉淀模板与规范后再规模化扩面。 2）物料- schema 对齐：每个物料组件都有配置面板 schema、默认值、校验规则、事件定义；schema 描述组件树 + props + 事件 + 校验 + 数据源绑定。 3）运行态渲染：递归渲染 + 表达式解析 + 事件分发；联动用依赖图/事件总线收敛复杂度。 4）版本与迁移：schema 版本化，结构演进提供 migration，确保历史页面可打开。 5）安全与权限：表达式能力白名单化（避免任意执行），运行态按权限裁剪组件/配置。 6）性能：虚拟滚动/按需渲染/批量更新；编辑器与运行态拆包，避免把编辑器代码带到线上运行包。</p><hr><h3 id="_4-项目三-跨平台公告插件系统-2023-02-2023-03" tabindex="-1"><a class="header-anchor" href="#_4-项目三-跨平台公告插件系统-2023-02-2023-03" aria-hidden="true">#</a> 4）项目三：跨平台公告插件系统（2023.02-2023.03）</h3><h4 id="公告插件-项目三段式" tabindex="-1"><a class="header-anchor" href="#公告插件-项目三段式" aria-hidden="true">#</a> 公告插件：项目三段式</h4><p><strong>面试官：跨平台公告插件你怎么做的？</strong></p><p><strong>1）项目角色（背景）</strong></p><ul><li>角色：独立开发者（方案设计 + SDK 交付）。</li><li>背景：多个内部系统都需要“紧急公告/发版公告”，如果各做一套会重复建设；而系统技术栈不一致，必须做到跨框架、低侵入、可快速接入。</li></ul><p><strong>2）做了什么事</strong></p><p>1）统一接入协议与配置：SDK 侧只负责渲染与生命周期，策略由服务端配置（token/appId/投放策略）。 2）热插拔与隔离：提供 init/destroy；错误隔离、样式/资源隔离；保证“不影响宿主”。 3）多形态接入：CDN/UMD、ESM/NPM、Web Component；极端冲突场景预留 iframe 兜底。 4）体积与性能：Rollup Tree Shaking；Preact 轻内核 + 细粒度更新，控制 SDK 体积。</p><p><strong>3）价值</strong></p><ul><li>产物体积 &lt; 15KB。</li><li>单系统接入成本 &lt; 0.5 人日。</li><li>跨 5 个系统标准化接入，紧急公告触达率 100%。</li></ul><hr><h3 id="技术点-1-多模式植入方案怎么设计的-问题三段式" tabindex="-1"><a class="header-anchor" href="#技术点-1-多模式植入方案怎么设计的-问题三段式" aria-hidden="true">#</a> 技术点 1：多模式植入方案怎么设计的？（问题三段式）</h3><p><strong>面试官：多模式植入你怎么设计？</strong></p><p><strong>1）突出问题</strong></p><p>系统技术栈与构建方式不同，如果只提供一种接入形态，会导致接入成本高、改造风险大。</p><p><strong>2）结合项目背景</strong></p><p>需要同时覆盖“老系统不改构建链路”“现代系统走 npm”“紧急场景快速接入（CDN）”。</p><p><strong>3）解决方案</strong></p><p>1）<strong>CDN/UMD</strong>：最简单，适合快速接入与老系统。 2）<strong>ESM/NPM</strong>：适合现代工程体系，按需引入、可 Tree Shaking。 3）<strong>Web Component</strong>：框架无关，作为通用形态。 4）<strong>iframe 兜底（可选）</strong>：在强隔离场景（样式冲突严重/安全要求高）用 iframe，代价是通信与性能。</p><hr><h3 id="技术点-2-为什么选择-preact-问题三段式" tabindex="-1"><a class="header-anchor" href="#技术点-2-为什么选择-preact-问题三段式" aria-hidden="true">#</a> 技术点 2：为什么选择 Preact？（问题三段式）</h3><p><strong>面试官：为什么不用 React，而用 Preact？</strong></p><p><strong>1）突出问题</strong></p><p>SDK 的核心约束是“体积极小、无感接入、低冲突风险”。React 对 SDK 来说偏重，且宿主可能已有 React 版本，存在冲突风险。</p><p><strong>2）结合项目背景</strong></p><p>公告本质是轻量 UI + 拉取数据，不需要重型生态；更关键的是不能影响宿主性能与稳定性。</p><p><strong>3）解决方案</strong></p><p>1）<strong>体积</strong>：Preact 内核小，配合压缩与 Tree Shaking 更容易把 SDK 控制在 &lt; 15KB。 2）<strong>性能与渲染</strong>：小组件渲染链路更短；必要时用 signal/细粒度更新减少重渲染。 3）<strong>兼容策略</strong>：输出多格式，避免强绑定宿主框架。</p><hr><h3 id="技术点-3-为什么选择-rollup-打包-问题三段式" tabindex="-1"><a class="header-anchor" href="#技术点-3-为什么选择-rollup-打包-问题三段式" aria-hidden="true">#</a> 技术点 3：为什么选择 Rollup 打包？（问题三段式）</h3><p><strong>面试官：为什么选择 Rollup，而不是 Webpack？</strong></p><p><strong>1）突出问题</strong></p><p>SDK 场景优先级是“产物体积与 Tree Shaking 效果”，而不是大型应用的复杂构建能力。</p><p><strong>2）结合项目背景</strong></p><p>公告 SDK 以 ESM 为主，依赖要极简，同时需要输出 UMD/ESM 以适配多种接入方式。</p><p><strong>3）解决方案</strong></p><p>1）Rollup 对库模式与 Tree Shaking 更友好，配置更聚焦。 2）多格式输出（UMD/ESM）更顺手，适配多接入方式。 3）配合 terser/压缩策略，更容易把体积压到目标范围。</p><hr><h3 id="_5-项目四-大疆-devops-平台维护-2024-03-2025-04" tabindex="-1"><a class="header-anchor" href="#_5-项目四-大疆-devops-平台维护-2024-03-2025-04" aria-hidden="true">#</a> 5）项目四：大疆 DevOps 平台维护（2024.03-2025.04）</h3><h4 id="devops-项目三段式" tabindex="-1"><a class="header-anchor" href="#devops-项目三段式" aria-hidden="true">#</a> DevOps：项目三段式</h4><p><strong>面试官：DevOps 平台你做了什么？</strong></p><h5 id="_1-项目角色-背景-1" tabindex="-1"><a class="header-anchor" href="#_1-项目角色-背景-1" aria-hidden="true">#</a> 1）项目角色（背景）</h5><ul><li>角色：核心开发者。</li><li>背景：内部 DevOps 平台支撑研发流程（权限/需求/自动化测试/文档等），需要持续迭代且稳定。</li></ul><h5 id="_2-做了什么事-1" tabindex="-1"><a class="header-anchor" href="#_2-做了什么事-1" aria-hidden="true">#</a> 2）做了什么事</h5><p>1）功能迭代：Jira 插件对接、Workspace 审批流、自定义流程等。 2）交付治理：把高风险重复劳动（部署）尽量流水线化，提升可追溯与可回滚能力。</p><h5 id="_3-价值-1" tabindex="-1"><a class="header-anchor" href="#_3-价值-1" aria-hidden="true">#</a> 3）价值</h5><ul><li>提升流程审批与部署效率，降低人工操作与出错概率，保障流水线稳定。</li></ul><hr><h4 id="技术点-docker-流水线自动化部署怎么实现的-问题三段式" tabindex="-1"><a class="header-anchor" href="#技术点-docker-流水线自动化部署怎么实现的-问题三段式" aria-hidden="true">#</a> 技术点：Docker 流水线自动化部署怎么实现的？（问题三段式）</h4><p><strong>面试官：Docker 流水线自动化部署你怎么做的？</strong></p><h5 id="_1-突出问题" tabindex="-1"><a class="header-anchor" href="#_1-突出问题" aria-hidden="true">#</a> 1）突出问题</h5><p>部署是典型“高风险重复劳动”：手工步骤多就会出错，出了问题难追溯；多环境下还容易配置漂移。把部署流水线化，本质是把交付从“人的经验”变成“系统能力”。</p><h5 id="_2-结合项目背景" tabindex="-1"><a class="header-anchor" href="#_2-结合项目背景" aria-hidden="true">#</a> 2）结合项目背景</h5><p>平台服务多、依赖多，必须把部署过程标准化，做到可回滚、可审计、可追溯。</p><h5 id="_3-解决方案" tabindex="-1"><a class="header-anchor" href="#_3-解决方案" aria-hidden="true">#</a> 3）解决方案</h5><p>1）<strong>镜像与依赖一致性</strong>：统一 Dockerfile、基础镜像与构建参数；版本以 commit sha/语义化版本打 tag。 2）<strong>流水线阶段化</strong>：build/test → image build → scan → deploy → verify；每一阶段产出可追溯记录。 3）<strong>配置治理</strong>：配置与密钥分离；环境差异通过配置中心/环境变量管理，避免镜像内写死。 4）<strong>发布与回滚</strong>：支持灰度/回滚；失败自动阻断并告警；验证阶段做健康检查与关键接口探活。</p><hr><h3 id="_6-项目五-xdr-系统-魔方大屏-报表-2025-05-2025-12" tabindex="-1"><a class="header-anchor" href="#_6-项目五-xdr-系统-魔方大屏-报表-2025-05-2025-12" aria-hidden="true">#</a> 6）项目五：XDR 系统 - 魔方大屏 + 报表（2025.05-2025.12）</h3><h4 id="xdr-项目三段式" tabindex="-1"><a class="header-anchor" href="#xdr-项目三段式" aria-hidden="true">#</a> XDR：项目三段式</h4><p><strong>面试官：XDR 大屏和报表你做了什么？</strong></p><h5 id="_1-项目角色-背景-2" tabindex="-1"><a class="header-anchor" href="#_1-项目角色-背景-2" aria-hidden="true">#</a> 1）项目角色（背景）</h5><ul><li>角色：核心开发者。</li><li>背景：安全运营相关的大数据可视化系统，需要高性能渲染与稳定数据链路；同时有“报表自动生成与分发”的自动化诉求。</li></ul><h5 id="_2-做了什么事-2" tabindex="-1"><a class="header-anchor" href="#_2-做了什么事-2" aria-hidden="true">#</a> 2）做了什么事</h5><p>1）大屏：Vue3 + ECharts 可视化组件与渲染链路优化，强调性能与交互。 2）全栈：NestJS 做数据聚合、定时任务、报表生成与邮件推送。 3）导出：支持 PDF/PPT/Excel 等多格式输出。</p><h5 id="_3-价值-2" tabindex="-1"><a class="header-anchor" href="#_3-价值-2" aria-hidden="true">#</a> 3）价值</h5><ul><li>万级数据快速渲染与交互；报表自动化提升运营效率，降低人工成本。</li></ul><hr><h4 id="技术点-报表定时功能怎么实现的-问题三段式" tabindex="-1"><a class="header-anchor" href="#技术点-报表定时功能怎么实现的-问题三段式" aria-hidden="true">#</a> 技术点：报表定时功能怎么实现的？（问题三段式）</h4><p><strong>面试官：你提到报表定时生成，具体怎么做的？</strong></p><h5 id="_1-突出问题-1" tabindex="-1"><a class="header-anchor" href="#_1-突出问题-1" aria-hidden="true">#</a> 1）突出问题</h5><p>定时报表本质是异步任务系统：多实例可能重复执行；导出耗时不稳定会拖垮主服务；失败没有告警与补偿会变成业务事故。</p><h5 id="_2-结合项目背景-1" tabindex="-1"><a class="header-anchor" href="#_2-结合项目背景-1" aria-hidden="true">#</a> 2）结合项目背景</h5><p>报表涉及聚合查询与渲染导出，耗时波动大；同时要保证“按时生成、失败可重试、过程可追溯”。</p><h5 id="_3-解决方案-1" tabindex="-1"><a class="header-anchor" href="#_3-解决方案-1" aria-hidden="true">#</a> 3）解决方案</h5><p>1）<strong>调度 + 幂等</strong>：cron 只负责触发，执行侧用“业务幂等键/分布式锁”保证同一周期只跑一次。 2）<strong>任务状态模型</strong>：任务实例入库（开始/成功/失败/耗时/产物地址/错误信息），支持补跑与审计。 3）<strong>异步化</strong>：导出与重计算走队列/worker，主服务只做编排，避免 CPU/内存被导出占满。 4）<strong>并发与限流</strong>：同一时间控制导出并发，避免高峰期雪崩；超时与重试使用退避策略。 5）<strong>监控告警</strong>：成功率、P95 耗时、队列堆积等指标上报；失败自动告警。</p><hr><h3 id="_7-常见缩写-面试时可随口解释" tabindex="-1"><a class="header-anchor" href="#_7-常见缩写-面试时可随口解释" aria-hidden="true">#</a> 7）常见缩写（面试时可随口解释）</h3><ul><li>RTT（Round-Trip Time）：网络往返时延，影响握手与请求时延。</li><li>FCP（First Contentful Paint）：首次内容绘制。</li><li>LCP（Largest Contentful Paint）：最大内容绘制（通常是首屏主内容块/主图）。</li><li>CLS（Cumulative Layout Shift）：累积布局偏移。</li><li>RUM（Real User Monitoring）：真实用户监控数据（线上采样）。</li></ul><hr>',135),x={},k=(0,a(3744).Z)(x,[["render",function(e,r){const a=(0,i.up)("RouterLink");return(0,i.wg)(),(0,i.iD)(i.HY,null,[t,(0,i._)("blockquote",null,[n,(0,i._)("ul",null,[o,s,(0,i._)("li",null,[d,(0,i.Wm)(a,{to:"/job-description/docs/job-description/ASK_CODE_EXAMPLES.html"},{default:(0,i.w5)((()=>[p])),_:1}),h])])]),l,(0,i._)("p",null,[c,(0,i.Wm)(a,{to:"/job-description/docs/job-description/ASK_CODE_EXAMPLES.html"},{default:(0,i.w5)((()=>[g])),_:1}),u]),_,(0,i._)("p",null,[f,(0,i.Wm)(a,{to:"/job-description/docs/job-description/ASK_CODE_EXAMPLES.html"},{default:(0,i.w5)((()=>[S])),_:1}),b]),m],64)}]])},3744:(e,r)=>{r.Z=(e,r)=>{const a=e.__vccOpts||e;for(const[e,i]of r)a[e]=i;return a}}}]);