"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[1067],{5980:(e,n,l)=>{l.r(n),l.d(n,{data:()=>d});const d={key:"v-7a5ee91d",path:"/webpack/install/npm.html",title:"npm",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"早期的 npm",slug:"早期的-npm",children:[{level:3,title:'那么我们如何去理解"嵌套地狱"呢？',slug:"那么我们如何去理解-嵌套地狱-呢",children:[]},{level:3,title:"那么这样的重复问题会带来什么后果呢？",slug:"那么这样的重复问题会带来什么后果呢",children:[]},{level:3,title:"你在实际的开发会不会出现这样的一些情况",slug:"你在实际的开发会不会出现这样的一些情况",children:[]}]},{level:2,title:"目标",slug:"目标",children:[]},{level:2,title:"安装机制",slug:"安装机制",children:[]},{level:2,title:"参考资料",slug:"参考资料",children:[]}],git:{updatedTime:1745601985e3},filePathRelative:"webpack/install/npm.md"}},4576:(e,n,l)=>{l.r(n),l.d(n,{default:()=>p});var d=l(6252);const a=(0,d.uE)('<h1 id="npm" tabindex="-1"><a class="header-anchor" href="#npm" aria-hidden="true">#</a> npm</h1><h2 id="早期的-npm" tabindex="-1"><a class="header-anchor" href="#早期的-npm" aria-hidden="true">#</a> 早期的 npm</h2><p>其实在最早期的<code>npm</code>版本(npm v2)，<code>npm</code>的设计可以说是非常的简单,在安装依赖的时候会将依赖放到<code> node_modules</code>文件中; 同时,如果某个直接依赖 A 依赖于其他的依赖包 B,那么依赖 B 会作为间接依赖,安装到依赖 A 的文件夹<code>node_modules</code>中,然后可能多个包之间也会有出现同样的依赖递归的,如果项目一旦过大,那么必然会形成一棵巨大的依赖树，依赖包会出现重复,形成<code>嵌套地狱</code>。</p><h3 id="那么我们如何去理解-嵌套地狱-呢" tabindex="-1"><a class="header-anchor" href="#那么我们如何去理解-嵌套地狱-呢" aria-hidden="true">#</a> 那么我们如何去理解&quot;嵌套地狱&quot;呢？</h3><ul><li>首先,项目的依赖树的层级过于深，如果有问题不利于排查和调试</li><li>在依赖的分支中,可能会出现同样版本的相互依赖的问题</li></ul><h3 id="那么这样的重复问题会带来什么后果呢" tabindex="-1"><a class="header-anchor" href="#那么这样的重复问题会带来什么后果呢" aria-hidden="true">#</a> 那么这样的重复问题会带来什么后果呢？</h3><ul><li>首先,会使得安装的结果占据了大量的空间资源,造成了资源的浪费</li><li>同时,因为安装的依赖重复,会造成在安装依赖时,安装时间过长</li><li>甚至是,因为目录层级过深,导致文件路径过长,会在<code>windows</code>系统下删除<code>node_modules</code>文件,出现删除不掉的情况</li></ul><h3 id="你在实际的开发会不会出现这样的一些情况" tabindex="-1"><a class="header-anchor" href="#你在实际的开发会不会出现这样的一些情况" aria-hidden="true">#</a> 你在实际的开发会不会出现这样的一些情况</h3><p>当你项目依赖出现问题的时候, 我们会不会是直接删除<code> node_modules 和 lockfiles</code>依赖, 再重新 <code>npm install</code>,删除大法是否真的好用?这样的使用方案会不会带来什么问题？</p><p>把所有的依赖包都安装到<code>dependencies</code>中,对<code>devDependencies</code> 不区分会不会有问题?</p><p>一个项目中, 你使用 <code>yarn</code>, 我使用<code>npm</code>，会不会有问题呢？</p><p>还有一个问题, <code>lockfiles 文件</code> 我们提交代码的时候需不需要提交到仓库中呢？</p><h2 id="目标" tabindex="-1"><a class="header-anchor" href="#目标" aria-hidden="true">#</a> 目标</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>给你和你的团队、你的公司带来最好的开源库和依赖。 通过这句话,我们可以了解到 npm 最重要的一点就是安装和维护依赖。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="安装机制" tabindex="-1"><a class="header-anchor" href="#安装机制" aria-hidden="true">#</a> 安装机制</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fbc0e4e27c14500a2a9e4fcf4757fae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image.png"></p><p><code>npm install</code>执行之后, 首先会检查和获取 <code>npm的配置</code>,这里的优先级为:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>项目级的.npmrc文件 &gt; 用户级的 .npmrc文件 &gt; 全局级的 .npmrc &gt; npm内置的 .npmrc 文件\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><code>保持npm 版本的一致性</code></p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',20),c={href:"https://www.npmjs.com/",target:"_blank",rel:"noopener noreferrer"},r=(0,d.Uk)("npm-官网"),i={href:"https://juejin.cn/post/6844903870578032647",target:"_blank",rel:"noopener noreferrer"},t=(0,d.Uk)("npm-掘金"),o={},p=(0,l(3744).Z)(o,[["render",function(e,n){const l=(0,d.up)("ExternalLinkIcon");return(0,d.wg)(),(0,d.iD)(d.HY,null,[a,(0,d._)("ul",null,[(0,d._)("li",null,[(0,d._)("p",null,[(0,d._)("a",c,[r,(0,d.Wm)(l)])])]),(0,d._)("li",null,[(0,d._)("p",null,[(0,d._)("a",i,[t,(0,d.Wm)(l)])])])])],64)}]])},3744:(e,n)=>{n.Z=(e,n)=>{const l=e.__vccOpts||e;for(const[e,d]of n)l[e]=d;return l}}}]);