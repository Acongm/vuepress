"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[823],{2049:(n,a,l)=>{l.r(a),l.d(a,{data:()=>s});const s={key:"v-0448c5b6",path:"/interview-prep/project__dji-devops.html",title:"大疆 DevOps 平台维护",lang:"zh-CN",frontmatter:{id:"project__dji-devops",type:"project",title:"大疆 DevOps 平台维护",mastery:"not_started",tags:["vue3","typescript","qiankun","cicd"],projects:["project__dji-devops"],source_refs:[{source:"resume",file:"docs/job-description/web前端开发工程师-彭聪.md",anchor:"大疆 DevOps 平台维护"}],seed_refs:[{source:"outline",file:"docs/job-description/web前端开发工程师-彭聪-面试技术大纲.md",anchor:"6）大疆 DevOps 平台维护：微前端选型 + 各微前端原理"}],updated_at:"2025-12-20T00:00:00.000Z"},excerpt:"",headers:[{level:2,title:"摘要（Auto）",slug:"摘要-auto",children:[]},{level:2,title:"建议追问（Auto）",slug:"建议追问-auto",children:[]},{level:2,title:"关联卡片",slug:"关联卡片",children:[]},{level:2,title:"在我项目中的角色与使用场景",slug:"在我项目中的角色与使用场景",children:[]},{level:2,title:"原理简述",slug:"原理简述",children:[]},{level:2,title:"对比表格",slug:"对比表格",children:[]},{level:2,title:"模拟问答",slug:"模拟问答",children:[]},{level:2,title:"手写代码区",slug:"手写代码区",children:[]},{level:2,title:"我的补充（Manual）",slug:"我的补充-manual",children:[]},{level:2,title:"复盘与反思（Learnings）",slug:"复盘与反思-learnings",children:[]},{level:2,title:"面试官追问（面试官视角）",slug:"面试官追问-面试官视角",children:[]}],git:{updatedTime:1767447745e3},filePathRelative:"interview-prep/project__dji-devops.md"}},9774:(n,a,l)=>{l.r(a),l.d(a,{default:()=>h});var s=l(6252);const e=(0,s.uE)('<h2 id="摘要-auto" tabindex="-1"><a class="header-anchor" href="#摘要-auto" aria-hidden="true">#</a> 摘要（Auto）</h2><ul><li>生成时间：2025-12-20</li><li>简历中出现的项目标题（提取）：大疆用户中心重构 / 大疆售后 RMS 系统重构 / 跨平台公告插件系统 / 大疆 DevOps 平台维护 / XDR 系统 - 魔方大屏 + 报表</li><li>面试大纲关键词（提取 Top10）：1）大疆用户中心重构：性能优化 + HTTP 原理 + Webpack 架构 / 性能指标与方法论 / 简历可落地点（结合你的“优化四板斧”） / HTTP 常考点（从“为什么变快”倒推） / Webpack 架构（工程化面试常考） / 按优化顺序，把方案“串起来”（排查 → 定位 → 选择 → 验证） / 0. 排查与基线（先把问题“量化”） / 1. 先保“可见”——骨架屏预渲染（直接拉低 LCP） / 2. 再减“阻塞”——关键渲染路径（CRP）梳理：CSS/字体/首图优先级 / 3. 再降“下载与解析成本”——更小的包体与更少的无效代码</li></ul><h2 id="建议追问-auto" tabindex="-1"><a class="header-anchor" href="#建议追问-auto" aria-hidden="true">#</a> 建议追问（Auto）</h2><ul><li>你为什么在该项目/场景里选择这个方案？替代方案为何不选？</li><li>最大一次事故/踩坑是什么？如何定位与回滚？</li><li>如果重做：架构/边界/工程化会怎么调整？</li></ul><h2 id="关联卡片" tabindex="-1"><a class="header-anchor" href="#关联卡片" aria-hidden="true">#</a> 关联卡片</h2>',5),t=(0,s.Uk)("技术： "),i=(0,s._)("code",null,"tech__micro-frontend-qiankun",-1),p=(0,s._)("code",null,"tech__typescript",-1),o=(0,s.Uk)("对比： "),u=(0,s._)("code",null,"matrix__monorepo-lerna-nx",-1),c=(0,s._)("code",null,"matrix__cicd-release-strategy",-1),r=(0,s.uE)('<h2 id="在我项目中的角色与使用场景" tabindex="-1"><a class="header-anchor" href="#在我项目中的角色与使用场景" aria-hidden="true">#</a> 在我项目中的角色与使用场景</h2><p>核心开发者。面向多团队、多模块交付场景，通过微前端实现独立部署与统一治理，并通过 CI/CD 提升发布效率。</p><h2 id="原理简述" tabindex="-1"><a class="header-anchor" href="#原理简述" aria-hidden="true">#</a> 原理简述</h2><p>核心目标：在组织层面需要“多团队自治发布”的前提下，做到<strong>独立部署</strong>同时又能<strong>统一治理</strong>（登录/权限/埋点/错误/性能）。</p><ul><li>微前端的主链路： <ul><li>主应用壳：负责路由、权限、菜单、全局样式基座、埋点/错误上报与子应用加载策略。</li><li>子应用：只关心自己的业务域，遵循接入协议暴露生命周期。</li></ul></li><li>隔离策略： <ul><li>JS：开启 sandbox，约束对子应用的全局写入；卸载回滚副作用。</li><li>CSS：前缀化或实验性样式隔离，减少互相污染。</li><li>依赖：共享关键依赖要有“版本约束 + 单例策略”，否则会出现多份运行时冲突。</li></ul></li><li>通信策略： <ul><li>props 注入（同步能力）+ 事件总线（异步广播）+ 共享存储（跨应用状态）。</li><li>约束：协议化（schema），避免子应用直接引用主应用内部模块。</li></ul></li><li>性能策略： <ul><li>只加载当前路由需要的子应用；对高频子应用做预取；</li><li>建立子应用维度的包体预算与 RUM 监控，避免“微前端把性能问题放大”。</li></ul></li></ul><h2 id="对比表格" tabindex="-1"><a class="header-anchor" href="#对比表格" aria-hidden="true">#</a> 对比表格</h2><table><thead><tr><th>方案</th><th>优点</th><th>代价</th><th>适用场景</th></tr></thead><tbody><tr><td>qiankun</td><td>上手快、治理能力较全</td><td>runtime 复杂度</td><td>多团队自治、渐进迁移</td></tr><tr><td>single-spa</td><td>更底层、更灵活</td><td>需要更多自建治理</td><td>平台团队强、想深度定制</td></tr><tr><td>Module Federation</td><td>共享依赖强、性能潜力大</td><td>治理与契约复杂</td><td>同栈、版本控制强</td></tr><tr><td>iframe</td><td>强隔离</td><td>通信成本高、体验一般</td><td>安全/隔离优先</td></tr></tbody></table><h2 id="模拟问答" tabindex="-1"><a class="header-anchor" href="#模拟问答" aria-hidden="true">#</a> 模拟问答</h2><ul><li>[ ] 为什么选 qiankun？哪些约束让它更合适？</li><li>[ ] 子应用资源如何加载与调度？沙箱怎么做？有哪些坑？</li><li>[ ] CI/CD 如何做门禁与回滚？如何保证可追溯（commit→ 构建 → 镜像 → 发布）？</li><li>[ ]（大纲维度）CI/CD 基础链路怎么讲？一条流水线从触发到发布都发生了什么？ <ul><li>可复述要点： <ul><li>触发：push/PR/tag/定时，按分支策略映射环境（dev/staging/prod）。</li><li>阶段：build → test → scan（SAST/依赖漏洞）→ package（artifact/镜像）→ deploy。</li><li>产物：产物仓库/镜像仓库统一管理，带版本号与 buildMeta。</li></ul></li></ul></li><li>[ ]（大纲维度）你怎么做到“可追溯”？如何从线上版本定位到某次提交？ <ul><li>可复述要点： <ul><li>buildMeta：commit hash + build id 写入产物（页面注释/环境变量/接口 header）。</li><li>发布记录：发布单关联 commit/tag、镜像 digest、环境、审批人。</li><li>一键回滚：回滚到上一个稳定镜像/版本，并保留审计记录。</li></ul></li></ul></li><li>[ ]（大纲维度）Docker 镜像分层与缓存你怎么优化？pnpm/yarn cache 怎么做？ <ul><li>可复述要点： <ul><li>分层：先复制 lockfile 再安装依赖，最大化缓存命中；业务代码放后面。</li><li>缓存：开启依赖缓存（pnpm store/yarn cache），CI 内复用；必要时用远端缓存。</li></ul></li></ul></li><li>[ ]（大纲维度）发布策略你怎么选（蓝绿/金丝雀/滚动）？健康检查与回滚怎么设计？ <ul><li>可复述要点： <ul><li>金丝雀：小流量验证，指标异常自动停止扩量并回滚。</li><li>健康检查：readiness/liveness + 关键接口探活；失败自动回滚。</li><li>回滚：镜像级回滚最快，配置与数据迁移要可逆/向后兼容。</li></ul></li></ul></li></ul><p>补充可复述要点：</p><ul><li>选型口径：组织需要自治发布 + 多栈并存 + 存量迁移 → qiankun 综合成本最低。</li><li>沙箱坑： <ul><li>子应用写全局变量/修改原型链 → 必须白名单与回滚；</li><li>样式污染 → 前缀/隔离策略 + 规范；</li><li>多份 React/Vue → 必须单例与版本约束。</li></ul></li><li>CI/CD 可追溯： <ul><li>构建产物带 buildMeta（commit hash/build id）；</li><li>发布记录关联工单/变更，支持一键回滚到上一个稳定版本。</li><li>门禁：lint/typecheck/unit test/scan（按项目选择），确保“坏代码进不来”。</li></ul></li></ul><p>补充可复述要点：</p><ul><li>选型口径：组织需要自治发布 + 多栈并存 + 存量迁移 → qiankun 综合成本最低。</li><li>沙箱坑： <ul><li>子应用写全局变量/修改原型链 → 必须白名单与回滚；</li><li>样式污染 → 前缀/隔离策略 + 规范；</li><li>多份 React/Vue → 必须单例与版本约束。</li></ul></li><li>CI/CD 可追溯： <ul><li>构建产物带 buildMeta（commit hash/build id）；</li><li>发布记录关联工单/变更，支持一键回滚到上一个稳定版本。</li></ul></li></ul><h1 id="current-your-changes" tabindex="-1"><a class="header-anchor" href="#current-your-changes" aria-hidden="true">#</a> &lt;&lt;&lt;&lt;&lt;&lt;&lt; Current (Your changes)</h1><p>再补一组“流水线 + 发布策略”追问（对应面试大纲第 5 部分）：</p><ul><li>[ ] Q4：你们的 CI/CD 基础链路怎么设计（build → test → scan → package → deploy）？ <ul><li>触发：push/PR/tag/定时，按分支映射环境（dev/staging/prod）。</li><li>阶段： <ul><li>build：产物构建 + 生成 buildMeta（commit/buildId）</li><li>test：单测/关键用例（按项目可选覆盖率阈值）</li><li>scan：SAST/依赖漏洞扫描（按风险等级阻断）</li><li>package：Docker 镜像构建与推送（带版本号）</li><li>deploy：蓝绿/金丝雀/滚动发布 + 健康检查 + 自动回滚</li></ul></li><li>关键口径：每一步都能追溯（谁触发、用的什么 commit、产物是什么、部署到哪）。</li></ul></li><li>[ ] Q5：Docker 镜像分层缓存你怎么用来提速？常见踩坑是什么？ <ul><li>原理：镜像分层（layer）可复用，依赖安装层稳定就能命中缓存。</li><li>提速手段： <ul><li>把 <code>package.json</code>/lockfile 先复制并安装依赖，再复制业务代码（避免代码变动导致依赖层失效）</li><li>使用 pnpm/yarn 的 cache（CI 持久化缓存）减少重复下载</li></ul></li><li>坑：把变动频繁的文件放在依赖层之前、或 lockfile 不稳定，会让缓存命中率骤降。</li></ul></li><li>[ ] Q6：蓝绿 / 金丝雀 / 滚动发布分别适合什么场景？你怎么设计回滚？ <ul><li>蓝绿：两套环境切流，回滚快，资源成本高。</li><li>金丝雀：小流量灰度观测（错误率/性能），风险低，发布流程复杂度更高。</li><li>滚动：逐批替换实例，资源成本低，但回滚要更谨慎（需要健康检查与分批回退）。</li><li>回滚口径：基于版本号与 buildMeta 一键回退到上一个稳定镜像；配合变更审计记录。</li></ul></li><li>[ ] Q7：配置/密钥怎么治理？怎么避免“配置泄露/错配导致事故”？ <ul><li>配置分层：代码配置 vs 环境配置（env/secret）严格分离。</li><li>权限最小化：密钥按环境/按服务分发，审批流 + 审计。</li><li>兜底：发布前校验（必填变量/格式）、灰度观察期、出错自动熔断回滚。</li></ul></li></ul><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>Incoming (Background Agent changes)</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h2 id="手写代码区" tabindex="-1"><a class="header-anchor" href="#手写代码区" aria-hidden="true">#</a> 手写代码区</h2><p>通信协议最小实现（主 → 子）：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Event</span> <span class="token operator">=</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> payload<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">}</span>\n<span class="token keyword">type</span> <span class="token class-name">Handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>\n\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createBus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> handlers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set<span class="token operator">&lt;</span>Handler<span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token function">on</span><span class="token punctuation">(</span>h<span class="token operator">:</span> Handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      handlers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span>\n      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> handlers<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">emit</span><span class="token punctuation">(</span>e<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      handlers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="我的补充-manual" tabindex="-1"><a class="header-anchor" href="#我的补充-manual" aria-hidden="true">#</a> 我的补充（Manual）</h2><p>（不会被脚本覆盖）</p><h2 id="复盘与反思-learnings" tabindex="-1"><a class="header-anchor" href="#复盘与反思-learnings" aria-hidden="true">#</a> 复盘与反思（Learnings）</h2><ul><li>如果重做会怎么改？</li></ul><h2 id="面试官追问-面试官视角" tabindex="-1"><a class="header-anchor" href="#面试官追问-面试官视角" aria-hidden="true">#</a> 面试官追问（面试官视角）</h2><ul><li>[ ] 为什么选这个方案？替代方案为什么不选？</li><li>[!] 最大一次事故/踩坑是什么？如何定位与回滚？</li><li>[ ] 如果重做会怎么改？</li><li>[ ] 你如何设计分支策略与环境映射？PR 合并后如何自动发布到 staging？</li><li>[ ] 你如何处理“配置/密钥管理”？env/secret 怎么做到最小权限与可审计？</li><li>[ ] 回滚时遇到数据库/接口变更不兼容怎么办？你如何设计向后兼容与灰度窗口？</li></ul>',26),d={},h=(0,l(3744).Z)(d,[["render",function(n,a){const l=(0,s.up)("RouterLink");return(0,s.wg)(),(0,s.iD)(s.HY,null,[e,(0,s._)("ul",null,[(0,s._)("li",null,[t,(0,s._)("ul",null,[(0,s._)("li",null,[(0,s.Wm)(l,{to:"/interview-prep/tech__micro-frontend-qiankun.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,s.w5)((()=>[i])),_:1})]),(0,s._)("li",null,[(0,s.Wm)(l,{to:"/interview-prep/tech__typescript.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,s.w5)((()=>[p])),_:1})])])]),(0,s._)("li",null,[o,(0,s._)("ul",null,[(0,s._)("li",null,[(0,s.Wm)(l,{to:"/interview-prep/matrix__monorepo-lerna-nx.html#%E5%AF%B9%E6%AF%94%E8%A1%A8%E6%A0%BC"},{default:(0,s.w5)((()=>[u])),_:1})]),(0,s._)("li",null,[(0,s.Wm)(l,{to:"/interview-prep/matrix__cicd-release-strategy.html#%E5%AF%B9%E6%AF%94%E8%A1%A8%E6%A0%BC"},{default:(0,s.w5)((()=>[c])),_:1})])])])]),r],64)}]])},3744:(n,a)=>{a.Z=(n,a)=>{const l=n.__vccOpts||n;for(const[n,s]of a)l[n]=s;return l}}}]);