"use strict";(self.webpackChunkmd_vuepress=self.webpackChunkmd_vuepress||[]).push([[7480],{4317:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-64f60099",path:"/interview-prep/tech__micro-frontend-qiankun.html",title:"微前端（qiankun 原理/隔离/通信）",lang:"zh-CN",frontmatter:{id:"tech__micro-frontend-qiankun",type:"tech",title:"微前端（qiankun 原理/隔离/通信）",mastery:"not_started",tags:["micro-frontend","qiankun","sandbox"],projects:["project__dji-devops"],source_refs:[{source:"resume",file:"docs/job-description/web前端开发工程师-彭聪.md",anchor:"TODO"}],seed_refs:[{source:"outline",file:"docs/job-description/web前端开发工程师-彭聪-面试技术大纲.md",anchor:"TODO"}],updated_at:"2025-12-20T00:00:00.000Z"},excerpt:"",headers:[{level:2,title:"摘要（Auto）",slug:"摘要-auto",children:[]},{level:2,title:"建议追问（Auto）",slug:"建议追问-auto",children:[]},{level:2,title:"关联卡片",slug:"关联卡片",children:[]},{level:2,title:"在我项目中的角色与使用场景",slug:"在我项目中的角色与使用场景",children:[]},{level:2,title:"原理简述",slug:"原理简述",children:[]},{level:2,title:"对比表格",slug:"对比表格",children:[]},{level:2,title:"模拟问答",slug:"模拟问答",children:[]},{level:2,title:"手写代码区",slug:"手写代码区",children:[]},{level:2,title:"我的补充（Manual）",slug:"我的补充-manual",children:[]},{level:2,title:"复盘与反思（Learnings）",slug:"复盘与反思-learnings",children:[]},{level:2,title:"面试官追问（面试官视角）",slug:"面试官追问-面试官视角",children:[]}],git:{updatedTime:1766324604e3},filePathRelative:"interview-prep/tech__micro-frontend-qiankun.md"}},8501:(n,a,s)=>{s.r(a),s.d(a,{default:()=>c});var e=s(6252);const t=(0,e.uE)('<h2 id="摘要-auto" tabindex="-1"><a class="header-anchor" href="#摘要-auto" aria-hidden="true">#</a> 摘要（Auto）</h2><ul><li>生成时间：2025-12-20</li><li>简历中出现的项目标题（提取）：大疆用户中心重构 / 大疆售后 RMS 系统重构 / 跨平台公告插件系统 / 大疆 DevOps 平台维护 / XDR 系统 - 魔方大屏 + 报表</li><li>面试大纲关键词（提取 Top10）：1）大疆用户中心重构：性能优化 + HTTP 原理 + Webpack 架构 / 性能指标与方法论 / 简历可落地点（结合你的“优化四板斧”） / HTTP 常考点（从“为什么变快”倒推） / Webpack 架构（工程化面试常考） / 按优化顺序，把方案“串起来”（排查 → 定位 → 选择 → 验证） / 0. 排查与基线（先把问题“量化”） / 1. 先保“可见”——骨架屏预渲染（直接拉低 LCP） / 2. 再减“阻塞”——关键渲染路径（CRP）梳理：CSS/字体/首图优先级 / 3. 再降“下载与解析成本”——更小的包体与更少的无效代码</li></ul><h2 id="建议追问-auto" tabindex="-1"><a class="header-anchor" href="#建议追问-auto" aria-hidden="true">#</a> 建议追问（Auto）</h2><ul><li>你为什么在该项目/场景里选择这个方案？替代方案为何不选？</li><li>最大一次事故/踩坑是什么？如何定位与回滚？</li><li>如果重做：架构/边界/工程化会怎么调整？</li></ul><h2 id="关联卡片" tabindex="-1"><a class="header-anchor" href="#关联卡片" aria-hidden="true">#</a> 关联卡片</h2>',5),l=(0,e.Uk)("项目： "),i=(0,e._)("code",null,"project__dji-devops",-1),p=(0,e.Uk)("对比： "),o=(0,e._)("code",null,"matrix__tech-compare-micro-frontend",-1),r=(0,e.uE)('<h2 id="在我项目中的角色与使用场景" tabindex="-1"><a class="header-anchor" href="#在我项目中的角色与使用场景" aria-hidden="true">#</a> 在我项目中的角色与使用场景</h2><ul><li>典型场景（DevOps 平台/多业务线）： <ul><li>多团队并行、发布节奏不同：需要“<strong>独立部署</strong> + <strong>独立回滚</strong>”，降低互相阻塞。</li><li>技术栈不完全一致：希望主框架统一壳能力（登录/权限/菜单/埋点），子应用可渐进演进。</li></ul></li><li>我负责的落地： <ul><li>统一主应用壳能力（鉴权、路由、菜单、全局错误与日志链路）。</li><li>定义子应用接入规范：资源加载、通信协议、样式隔离、公共依赖共享策略。</li><li>处理“隔离与共享”的平衡：既要避免污染，又要避免重复依赖导致的体积与性能问题。</li></ul></li></ul><h2 id="原理简述" tabindex="-1"><a class="header-anchor" href="#原理简述" aria-hidden="true">#</a> 原理简述</h2><p>qiankun 基于 single-spa 的微前端框架，核心是三件事：<strong>加载（Load）/挂载（Mount）/隔离（Sandbox）</strong>。</p><ul><li><strong>加载</strong>： <ul><li>主应用根据路由匹配到子应用，拉取子应用的 HTML/JS/CSS（通常是一个 entry）。</li><li>把子应用资源解析并执行，拿到 <code>bootstrap/mount/unmount</code> 生命周期。</li></ul></li><li><strong>挂载</strong>： <ul><li>在主应用提供的容器节点里渲染子应用（React/Vue/Angular 都可以）。</li><li>需要确保子应用的路由基座（basename）与主应用协调。</li></ul></li><li><strong>隔离</strong>： <ul><li>JS 隔离（sandbox）：通过 Proxy/快照等方式隔离对 <code>window</code> 的修改，卸载时回滚。</li><li>样式隔离：通过 scoped/CSS 前缀/Shadow DOM（视方案）减少样式互相污染。</li><li>资源隔离：公共依赖共享与版本约束，避免“多份 React”引发运行时冲突。</li></ul></li></ul><p>权衡与边界：</p><ul><li>微前端不是银弹：会引入额外的运行时复杂度（加载链路、跨应用状态、调试与监控）。</li><li>适合的前提：组织上确实需要“自治发布”，并愿意投入治理（规范、监控、性能预算）。</li></ul><h2 id="对比表格" tabindex="-1"><a class="header-anchor" href="#对比表格" aria-hidden="true">#</a> 对比表格</h2><table><thead><tr><th>方案</th><th>隔离</th><th>通信</th><th>性能</th><th>工程复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>qiankun</td><td>JS sandbox + 样式策略</td><td>props/全局事件/共享模块</td><td>中（有额外 runtime）</td><td>中</td><td>多团队自治、渐进迁移</td></tr><tr><td>iframe</td><td>天然强隔离</td><td>postMessage</td><td>较差（资源重复/通信成本）</td><td>低</td><td>强隔离/安全优先、低集成需求</td></tr><tr><td>Module Federation</td><td>共享依赖强</td><td>共享模块/契约</td><td>佳（可共享依赖）</td><td>高</td><td>同栈、追求共享与性能、治理能力强</td></tr></tbody></table><p>回滚/风险控制：</p><ul><li>子应用独立回滚（按版本/灰度），主应用只负责加载策略。</li><li>关键依赖（React 等）统一版本与加载方式，避免“多份运行时”。</li></ul><h2 id="模拟问答" tabindex="-1"><a class="header-anchor" href="#模拟问答" aria-hidden="true">#</a> 模拟问答</h2><ul><li>[ ] Q1：你怎么做 JS 隔离？如果子应用改了 <code>window</code> 怎么办？ <ul><li>解释：qiankun sandbox 会拦截对子应用的全局写入；卸载时回滚或还原快照，避免污染主应用与其他子应用。</li><li>兜底：对必须共享的全局（埋点 SDK/国际化）走白名单与只读约束。</li></ul></li><li>[ ] Q2：微前端性能怎么治理？ <ul><li>分层：首屏只加载壳与必要子应用；其他子应用按路由懒加载 + 预取。</li><li>预算：子应用包体上限、关键资源 preload、共享依赖策略（避免重复 React）。</li><li>监控：子应用维度的 Web Vitals/错误/接口耗时上报并聚合。</li></ul></li><li>[ ] Q3：注册与加载链路能讲到什么粒度？（entry 获取/HTML 解析/资源注入/生命周期调度） <ul><li>可复述要点： <ul><li>注册：主应用根据路由规则（activeRule）决定何时激活子应用。</li><li>获取 entry：拉取子应用 HTML，解析出脚本/样式资源地址。</li><li>资源注入：把资源按顺序加载执行，拿到 <code>bootstrap/mount/unmount</code>。</li><li>调度：在容器内挂载；切换路由时卸载并回收副作用。</li></ul></li></ul></li><li>[ ] Q4：CSS 隔离你怎么选？Shadow DOM、前缀化、严格隔离各有什么坑？ <ul><li>Shadow DOM：隔离强但样式穿透/第三方组件适配有成本。</li><li>前缀化：成本低但不能 100% 防冲突（全局选择器/第三方库）。</li><li>严格隔离：体验更“干净”，但需要更强治理与调试能力。</li></ul></li><li>[ ] Q5：通信怎么做才不“隐式耦合”？props/event bus/共享状态怎么划界？ <ul><li>props：同步能力注入（token、用户信息、埋点函数），适合“只读能力”。</li><li>event bus：跨应用广播与解耦，但要有 schema（事件类型/版本）防止乱发乱收。</li><li>共享状态：仅限少数全局状态（登录态/权限），其余尽量业务域内自洽。</li></ul></li></ul><h2 id="手写代码区" tabindex="-1"><a class="header-anchor" href="#手写代码区" aria-hidden="true">#</a> 手写代码区</h2><p>一个最小 qiankun 接入片段（主应用注册子应用）：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> registerMicroApps<span class="token punctuation">,</span> start <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;qiankun&#39;</span>\n\n<span class="token function">registerMicroApps</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n  <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">&#39;sub-app-a&#39;</span><span class="token punctuation">,</span>\n    entry<span class="token operator">:</span> <span class="token string">&#39;//localhost:7100&#39;</span><span class="token punctuation">,</span>\n    container<span class="token operator">:</span> <span class="token string">&#39;#subapp-container&#39;</span><span class="token punctuation">,</span>\n    activeRule<span class="token operator">:</span> <span class="token string">&#39;/app-a&#39;</span><span class="token punctuation">,</span>\n    props<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token function-variable function">tokenGetter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&#39;token&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n<span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  sandbox<span class="token operator">:</span> <span class="token punctuation">{</span> experimentalStyleIsolation<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  prefetch<span class="token operator">:</span> <span class="token string">&#39;all&#39;</span> <span class="token comment">// 可根据路由热度策略化</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="我的补充-manual" tabindex="-1"><a class="header-anchor" href="#我的补充-manual" aria-hidden="true">#</a> 我的补充（Manual）</h2><p>（不会被脚本覆盖：踩坑、细节、反例、排查路径）</p><h2 id="复盘与反思-learnings" tabindex="-1"><a class="header-anchor" href="#复盘与反思-learnings" aria-hidden="true">#</a> 复盘与反思（Learnings）</h2><ul><li>如果重做会怎么改？</li></ul><h2 id="面试官追问-面试官视角" tabindex="-1"><a class="header-anchor" href="#面试官追问-面试官视角" aria-hidden="true">#</a> 面试官追问（面试官视角）</h2><ul><li>[ ] 为什么选这个方案？替代方案为什么不选？</li><li>[!] 最大一次事故/踩坑是什么？如何定位与回滚？</li><li>[ ] 如果重做会怎么改？</li></ul>',22),u={},c=(0,s(3744).Z)(u,[["render",function(n,a){const s=(0,e.up)("RouterLink");return(0,e.wg)(),(0,e.iD)(e.HY,null,[t,(0,e._)("ul",null,[(0,e._)("li",null,[l,(0,e._)("ul",null,[(0,e._)("li",null,[(0,e.Wm)(s,{to:"/interview-prep/project__dji-devops.html#%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"},{default:(0,e.w5)((()=>[i])),_:1})])])]),(0,e._)("li",null,[p,(0,e._)("ul",null,[(0,e._)("li",null,[(0,e.Wm)(s,{to:"/interview-prep/matrix__tech-compare-micro-frontend.html"},{default:(0,e.w5)((()=>[o])),_:1})])])])]),r],64)}]])},3744:(n,a)=>{a.Z=(n,a)=>{const s=n.__vccOpts||n;for(const[n,e]of a)s[n]=e;return s}}}]);