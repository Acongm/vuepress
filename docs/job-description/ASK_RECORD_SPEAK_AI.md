# 模拟面试回答稿（书面版 + 口语版）

> 使用方法：
>
> - 书面版用于“投递材料/复盘整理/背诵结构”。
> - 口语版用于“现场表达/语气自然/信息密度适中”。
> - 代码相关的内容单独放在 [docs/job-description/ASK_CODE_EXAMPLES.md](docs/job-description/ASK_CODE_EXAMPLES.md)。

---

## B. 口语版（面试现场口播）

> 口语版原则：不“总结优势”，只讲事实与决策过程，让面试官从你的表达里感受到能力。

> 结构记忆：
>
> - 项目：角色（背景）→ 做了什么 → 价值
> - 问题：问题是什么 → 为什么在这个场景更难 → 我怎么解决并验证

### 1）自我介绍（口语）

**面试官：请做一个自我介绍。**

面试官你好，我叫彭聪，彭于晏的彭，王思聪的聪，毕业于江西财经大学计算机应用技术专业。我从 2016 年毕业开始做前端，2019 年开始做前端负责人相关的工作。

我近几年主要在中后台复杂系统做两件事：
第一类是重构与长期治理，比如用户中心入口系统的多端统一和性能链路治理；
第二类是工程化与提效，比如 RMS 工单系统里把 TypeScript/ESLint/CI 这套质量体系从 0 到 1 建起来，并沉淀业务组件和低代码物料。

另外我也独立交付过跨系统公告插件 SDK，以及参与 DevOps 平台和 NestJS 报表定时任务的全栈交付。

您想先听哪个？我可以先从用户中心这个入口项目讲起。

---

### 2）用户中心重构（口语）

**面试官：介绍一下用户中心重构。**

我先按三段讲。

第一段，背景和角色：
用户中心是核心登录入口，1000W+ 注册用户，日均登录 120W+；我当时是项目前端负责人。这个项目最大的约束不是技术，而是风险——入口链路不能炸，所以必须能灰度、能回滚。

第二段，我做了什么：
我们没有硬切新框架，而是增量演进。
1）把 PC/移动两套实现用响应式融合成一套代码，先把维护成本收敛；
2）把性能按链路治理：包体积、关键资源优先级、主线程长任务、弱网兜底，逐项定位逐项解决；
3）工程侧配合拆包和长缓存，保证每次调整可度量、可回滚。

第三段，结果：
多端统一后维护成本下降约 50%，登录转化提升 18%，客诉下降 12%；首屏指标也有明显改善（口径是线上 RUM 采样）。

如果您想追问，我可以展开：拆包和缓存怎么做、三方脚本怎么管、以及我们怎么用 RUM 做验证闭环。

**面试官：打包优化是怎么做的？**

先把问题说清楚：
登录页的包一旦变大，下载、解析、执行都会变慢，弱网下会直接影响转化。

在用户中心这个场景，历史包袱主要来自 polyfill、重复依赖、字体/图片、以及首屏不需要的业务模块。
我先做产物分析和 diff 把大头定位出来，然后按几件事去落地：
polyfill 按需、
`splitChunks` 拆稳定依赖、
`runtimeChunk` 稳定缓存、
路由/功能动态 import、
以及字体图片的治理。

最后每次改动我都用“体积 diff + RUM 指标对比”验收，避免只把体积做小但体验没变好。

**面试官：更快的加载是怎么做的？**

我一般先分型：到底是连接/握手慢，还是关键资源没有优先级，还是脚本把主线程占满。

对应策略我会按“每一招解决什么问题”讲清楚：
1）网络侧协同（解决：握手 RTT、连接数、并发效率）

- HTTP/2：把多资源并发做成“单连接多路复用”，减少开多条 TCP 连接的开销，页面小资源多的时候首屏更稳。
- TLS 1.3：握手轮次更少（1-RTT，恢复可到 0-RTT），主要解决“TLS 握手慢导致的白等”。
- 连接复用/会话恢复：尽量复用已建连与会话，减少重复握手与慢启动。

2）关键资源优先级（解决：关键资源排队、关键路径被低价值资源抢带宽）

- `dns-prefetch`/`preconnect`：提前把 DNS + TCP + TLS 做掉，减少关键域名首次请求的等待。
- `preload`/`modulepreload`：把“确定影响首屏”的 CSS/字体/关键 chunk 提前高优先级拉取。
- `prefetch`：只给“下一跳可能用到”的资源，低优先级后台拉取，避免抢首屏带宽。

3）渲染阻塞治理（解决：解析阻塞、长任务、交互卡顿）

- CSS：关键 CSS 靠前（必要时抽关键 CSS），字体配合 `font-display`，避免 FOIT。
- JS：业务脚本默认 `defer` 保证顺序且不阻塞解析；三方脚本尽量延后并加超时/失败降级。

最后还是回到验证：上线看 RUM 的 LCP/错误率/失败率波动，确保收益稳定。

**面试官：JS 顺序怎么管？**

我的做法是“先分层，再控序”。

脚本层面我会把“加载方式”和“执行方式”一起讲：
1）加载方式（解决：阻塞解析、顺序不可控）

- 业务关键脚本：用 `defer`，不阻塞 HTML 解析，并且能保证执行顺序。
- 三方脚本：能延后就延后；必须并行加载的用 `async`（但不保证顺序），同时加超时/失败降级，避免拖住首屏。
- 非首屏模块：用动态 `import()`，减少首屏下载与解析。

2）执行方式（解决：等待不可控、串行太慢、失败难兜底）

- 用 `async/await` 把初始化流程变成“可读、可控”：关键依赖 `await` 保证顺序；可并行的用 `Promise.all/Promise.allSettled` 并发；对三方初始化加 timeout + fallback。

目标就两个：首屏别被脚本卡住，交互别被长任务卡住。

**面试官：WebP 怎么兜底？**

WebP 收益很大，但入口页不能为性能牺牲可用性。

我会做三层兜底：
1）前端用 `<picture>/<srcset>` 优先 WebP，自动 fallback；
2）构建侧产出双份资源，缓存策略保持稳定；
3）必要时做能力探测并缓存结果，服务端也可以基于 `Accept` 做内容协商。

上线后看图片失败率和 LCP 波动，异常就能快速回滚。

---

### 3）RMS 重构（口语）

**面试官：说说 RMS 系统重构。**

我也按三段讲。

第一段背景：RMS 是全球售后工单系统，日均处理工单 1W+，页面 100+，权限链路复杂；我担任项目前端负责人。痛点是复杂度上来以后，风格和质量不统一会让交付波动很大。

第二段我做了什么：我按“先稳工程 → 再做复用 → 最后提效”的顺序推进。
1）工程基础 0-1：TypeScript/ESLint/CI，把容易出问题的点工具化卡住；
2）复用体系：把权限/空态/错误/加载这些边界收敛成可复用组件，并逐步物料化；
3）低代码落地：先在表单/配置类页面试点，再规模化扩面。

第三段结果：整体开发效率提升约 30%，团队 Bug 率下降约 25%，体验一致性更稳定。

**面试官：ESLint 为什么要从 0-1 做？是怎么做的？**

因为系统一大，靠人肉 Review 是守不住的，最后会变成线上 bug 或长期维护成本。

我当时做法是：先把问题分类（变量/类型/import/异步/模块边界），再把规则分级（必须 error / 建议 warn / 暂缓）。工程上用 lint-staged 做提交前自动修复，用 CI 做强制卡点。

存量代码不一刀切：先让新增代码必须过规则，再按目录逐步收紧，这样团队能接受、也能持续推进。

**面试官：组件高可用是怎么做的？**

我会把“高可用”理解成三件事：边界一致、契约稳定、可观测可止损。

落地上：loading/empty/error 统一，关键区域用 Error Boundary 隔离；组件 API 做契约化，类型收口；关键失败有上报和降级开关。

最后把配置项、默认值、校验和事件整理成物料描述，为后续 schema 驱动打基础。

**面试官：低代码怎么落地？**

我不会一上来推全量低代码，而是先选“高重复、结构稳定”的表单/配置页试点。

关键点有三块：
1）物料标准化：每个组件都有配置 schema、默认值、校验和事件；
2）运行态渲染：递归渲染 + 表达式解析 + 事件分发，把联动收敛；
3）治理：schema 版本化和迁移，表达式能力白名单 + 权限裁剪。

这样做的目标是：提效的同时不降稳定性。

---

### 4）公告插件 / DevOps / XDR（口语简版）

我再用每个项目 20 秒的版本补充一下：

公告插件：目标是跨系统低成本接入。我提供 CDN/ESM/Web Component 多形态，SDK 支持 init/destroy 热插拔，做了错误/样式隔离和监控；产物体积控制在 15KB 以内，接入成本能压到半天左右。

DevOps：核心是把部署这类高风险重复劳动流水线化，围绕镜像一致性、分阶段流水线、安全扫描、按环境发布、健康检查和回滚，提升可追溯与稳定性。

XDR：报表定时本质是异步任务系统，我关注的是幂等与锁、任务状态持久化、队列 worker、并发控制与监控告警，保证按时生成、失败可追溯可补跑。
