# 模拟面试回答稿（书面版 + 口语版）

> 使用方法：
>
> - 书面版用于“投递材料/复盘整理/背诵结构”。
> - 口语版用于“现场表达/语气自然/信息密度适中”。
> - 代码相关的内容单独放在 [docs/job-description/ASK_CODE_EXAMPLES.md](docs/job-description/ASK_CODE_EXAMPLES.md)。

---

## A. 书面版（结构化答题稿）

### 1）自我介绍

**面试官：请做一个自我介绍。**

你好，我叫彭聪，毕业于江西财经大学计算机应用技术专业。2016 年开始做前端开发，2019 年开始承担前端负责人的角色。

过去几年我主要在中后台/复杂系统里做重构与长期治理：做过千万级用户入口系统的重构与性能优化，也做过全球售后工单系统的重构与工程化落地；同时独立交付过跨系统公告插件 SDK，以及参与 DevOps 平台与可视化报表的前后端一体化交付。

如果方便，我可以先从“用户中心重构的方案选择与性能链路治理”开始讲。

---

### 2）项目一：大疆用户中心重构（2022.02-2022.09）

#### 用户中心：项目介绍（项目背景/出发点与选型 → 做了什么事 → 价值）

**面试官：介绍一下用户中心重构。**

**项目背景 / 出发点（含选型）**：用户中心是核心入口，承载 1000W+ 注册用户、日均登录 120W+。当时的真实痛点不是“想换新技术”，而是三件事叠加：
1）PC/移动端两套代码，需求改动要改两份，容易不一致；
2）工程历史包袱重（依赖冗余、构建链路旧），线上性能与回归成本都偏高；
3）登录链路对业务转化敏感，不能冒险大改造成不可控风险。

所以选型的核心原则是：**稳定优先、增量演进、可度量**。技术栈仍以 Vue2 + webpack 为主（避免大迁移风险），同时引入 TypeScript/工程化约束提升可维护性，并用响应式方案把多端统一。

**做了什么事**：我作为项目前端负责人，把方案拆成“可灰度、可回滚”的阶段：

- 响应式融合：一套代码适配多端。
- 性能链路治理：从“资源体积/关键资源优先级/主线程任务/弱网兜底”四个方向把首屏体验拉起来。
- 工程治理：拆包与长缓存、构建产物分析、字体/图片等静态资源治理。

**价值**：PC/移动端统一后维护成本下降 50%，登录转化率提升 18%，客诉率下降 12%；性能指标上把首屏关键指标（以线上 RUM 采样为口径）明显拉升。

---

#### 技术点 1：打包优化怎么实现的？

**面试官：你提到打包优化，具体怎么做的？**

**1、问题出现的原因 + 为什么必须处理（典型前端问题）**：
这是“历史工程增长型”问题：依赖越积越多、polyfill/库引入不按需、静态资源没治理，结果就是包体积变大、首屏下载与解析时间变长。对登录页来说，首屏慢会直接影响转化，属于必须优先治理的典型问题。

**2、结合项目背景（你在项目里怎么发现/怎么定位）**：
我先用构建产物分析（bundle analyzer + 产物 diff）把“体积主要来自哪里”做拆解：polyfill、重复依赖、字体/图片、以及首屏不需要的业务模块。

**3、解决方案（适当展开技术细节）**：
1）**polyfill 策略**：用 browserslist 固定兼容矩阵，Babel 采用 `useBuiltIns: 'usage'` 按需注入，并定期检查“是否引入了过度兼容”。
2）**拆包策略**：

要点包括：`splitChunks` 拆稳定依赖（vendors）与公共业务（common）；`runtimeChunk: 'single'` 稳定 runtime，减少小改动导致全量缓存失效；路由级/功能级动态 `import()`，确保首屏不背后续页面代码。

3）**长缓存与发布**：JS/CSS 产物使用 `contenthash`，静态资源走 CDN 强缓存，配合发布策略保证“可回滚”。
4）**CSS 与 Tree Shaking**：

要点包括：CSS 压缩与提取（避免运行时注入带来的抖动）；并且 `sideEffects` 不能一刀切为 false，需要明确保留 `*.css/*.scss` 等副作用文件，避免样式被错误摇掉。

5）**静态资源治理**：字体 woff2 + 子集化；图片压缩与格式升级；图标走 svg sprite。
6）**验证闭环**：每次调整都做“产物体积 diff + 首屏 RUM 指标对比”，防止只优化体积却没有提升体验。

（代码示例在 [docs/job-description/ASK_CODE_EXAMPLES.md](docs/job-description/ASK_CODE_EXAMPLES.md) 的 Webpack/产物分析小节。）

---

#### 技术点 2：更快的加载怎么实现的？

**面试官：你说“更快的加载”，具体做了哪些？**

**1、问题出现的原因 + 为什么必须处理（典型前端问题）**：
首屏慢通常是“网络 + 资源优先级 + 渲染阻塞”共同作用：握手/连接耗时、关键资源没有优先级、CSS/JS 阻塞关键渲染路径。登录页属于典型“首屏即转化”的页面，必须把关键链路做到可控。

**2、结合项目背景（你在项目里怎么发现/怎么定位）**：
我用 Network/Performance 先确认瓶颈类型：是 TTFB 偏大、连接耗时偏长、还是主线程被脚本占满；并把第三方脚本对关键链路的影响单独拉出来对比。

**3、解决方案（适当展开技术细节）**：
1）**网络侧协同**：把关键链路升级到 HTTP/2，并开启 TLS 1.3 与会话复用（收益与 RTT/复用命中强相关），降低连接与握手成本。
2）**关键资源优先级**：

要点包括：对关键域名 `preconnect`；对确定影响首屏的资源用 `preload`（首屏图片/字体/关键 chunk）；`prefetch` 只用于“下一跳可能用到”的低优先级资源。

3）**关键渲染路径治理**：

要点包括：关键 CSS 尽量靠前（必要时做关键 CSS 提取）；业务脚本默认 `defer` 避免阻塞 HTML 解析；并通过拆分任务/延后非关键逻辑降低主线程 Long Task。

4）**压缩与缓存**：静态资源 gzip/brotli + CDN 缓存；并配合 `cache-control/etag` 做可控更新。
5）**三方脚本治理**：延后加载、失败降级、超时保护、隔离错误上报，避免把关键链路拖垮。

（代码示例在 [docs/job-description/ASK_CODE_EXAMPLES.md](docs/job-description/ASK_CODE_EXAMPLES.md) 的 Resource Hints/RUM 上报小节。）

---

#### 技术点 3：JS 加载顺序怎么实现的？

**面试官：JS 加载顺序/优先级你是怎么做的？**

**1、问题出现的原因 + 为什么必须处理（典型前端问题）**：
脚本治理是典型的“前端工程化问题”：脚本越多越容易出现阻塞、执行顺序不稳定、长任务卡交互。登录页又常见第三方 SDK/埋点/风控脚本，一旦抢占主线程，用户会感觉“点了没反应”。

**2、结合项目背景**：登录页往往既有业务逻辑也有埋点/风控 SDK，如果默认同步加载，首屏会被拖慢，甚至影响交互。

**3、解决方案（适当展开技术细节）**：
1）**脚本分层**：

要点包括：业务关键脚本默认 `defer`（保证顺序且不阻塞解析）；与业务无强依赖的脚本用 `async` 或延后执行；强不确定性三方脚本加超时、失败降级与隔离。

2）**模块化与拆分**：路由/功能维度动态 import，首屏不加载“登录后才用”的模块。
3）**主线程治理**：

要点包括：把非关键计算移到空闲时段（idle/延时）；重计算/解析用 Worker；渲染侧避免一次性渲染过多节点（分页/虚拟化）。

4）**可回收**：对第三方 SDK 的事件监听、定时器、observer 做统一注册与销毁，避免内存泄漏。

---

#### 技术点 4：WebP 怎么做兜底处理？

**面试官：WebP 升级怎么做兼容？**

**1、问题出现的原因 + 为什么必须处理（典型前端问题）**：
图片是首屏体积大户，格式升级能带来明显收益；但 WebView/老浏览器支持不一致，如果没有兜底会造成“关键图片缺失”，属于可用性事故。

**2、结合项目背景**：用户中心覆盖面广，设备/浏览器碎片化，不能为了性能牺牲可用性。

**3、解决方案（适当展开技术细节）**：
1）**运行时兜底**：`<picture>`/`srcset` 优先 WebP，fallback 到原格式。
2）**构建生成双份**：同一资源产出 webp + jpg/png；同时保证缓存 key/路径策略稳定。
3）**按能力选择**：对特定 WebView 做能力探测，并缓存结果；必要时服务端基于 `Accept` 做内容协商（CDN 侧也可配）。
4）**监控与回滚**：关注图片失败率、LCP 变化与错误率；出现异常可快速回滚到原格式。

---

### 3）项目二：大疆售后 RMS 系统重构（2022.10-2024.04）

#### RMS：项目介绍（项目背景/出发点与选型 → 做了什么事 → 价值）

**面试官：说说 RMS 系统重构。**

**项目背景 / 出发点（含选型）**：RMS 是全球售后工单系统（日均处理工单 1W+，页面 100+，权限链路复杂）。当时的出发点是“让系统能持续迭代且质量可控”：历史代码风格不统一、复杂度高、变量声明与类型定义不规范、模块边界不清晰，导致开发效率与质量波动。

选型上我们统一到 React 18 + TypeScript + Umi（用于工程组织与路由/构建体系）以及统一 UI 体系，目的是把复杂系统的工程基础打牢：可读、可测、可协作、可持续。

**做了什么事**：我作为项目前端负责人，按“先稳住工程基础 → 再提升复用 → 再做低代码提效”推进：
1）从 0-1 建立 ESLint/TypeScript 的工程约束与目录分层规范；
2）沉淀业务组件（错误边界/空态/权限/数据失败处理统一），并把组件逐步“物料化”；
3）参与低代码组件/物料贡献与深度使用：先贡献可复用组件，再在表单/配置类页面规模化使用，形成后期交付提效。

**价值**：整体开发效率提升约 30%，UI 体验一致性提升，团队 Bug 率下降 25%。

---

#### 技术点 1：ESLint 规范制定怎么实现的？

**面试官：你说制定 ESLint 规范，怎么落地的？**

**1、问题出现的原因 + 为什么必须处理（典型前端问题）**：
多人协作的典型痛点是“风格不统一 + 复杂度上升后缺少约束”，会直接带来：Review 争议、隐性 bug（变量遮蔽/未处理的 Promise/any 泛滥）、类型定义漂移、import 顺序混乱导致循环依赖与可读性差。系统越大，这类问题越会指数级放大，所以必须做 0-1 的工程规范落地。

**2、结合项目背景（你在项目里怎么发现/怎么推动）**：
RMS 权限与流程链路复杂，很多问题如果靠人工 Review 会漏掉。我先把历史问题做分类（变量/类型/import/异步处理/模块边界），再把规则拆成“必须 error / 建议 warn / 暂不启用”，保证团队能接受并逐步落地。

**3、解决方案（强调 0-1 架构规范能力，适当展开技术细节）**：
1）**从 0-1 定义规则体系**：

要点包括：parser 选择 TypeScript parser；插件组合使用 typescript-eslint、import、promise、react-hooks 等；规则重点放在“会出错/会劣化”的地方，例如变量声明规范、禁止隐式 any、Promise 必须处理、hooks 规则、import 顺序与分组、以及循环依赖的触发点。

2）**目录与模块边界**：用规则约束跨层引用（例如页面层不能直接引用基础设施层的内部实现），让架构靠工具“守住”。
3）**自动修复与一致性**：

要点包括：Prettier 只管格式，ESLint 管质量；import 排序与分组尽量自动修复，减少争议。

4）**落地策略（不炸存量）**：

要点包括：新增/修改必须过 lint（CI 卡点）；存量分阶段治理，按目录/模块逐步收紧。

5）**工程集成**：commit 前（lint-staged）+ CI + MR 规则，保证规范不是“文档”，而是“流水线能力”。

---

#### 技术点 2：业务组件高可用怎么实现的？（并为低代码物料做铺垫）

**面试官：业务组件高可用你具体做了什么？**

**1、问题出现的原因 + 为什么必须处理（典型前端问题）**：
复杂系统里复用组件会天然遇到“需求差异 + 边界条件爆炸”：权限/空数据/慢接口/失败重试/多语言等。组件如果只为单页写，很快会演变成大量 copy；但一旦复用又怕破坏性改动。所以组件必须具备“边界自洽、可观测、可扩展”，否则后面低代码/物料化也无从谈起。

**2、结合项目背景**：RMS 模块多、权限多，组件需要面对大量边界条件（无权限/空数据/接口失败/慢接口）。

**3、解决方案（适当展开技术细节）**：
1）**统一“边界三件套”**：loading/empty/error 的 UI 与交互一致；关键区域用 Error Boundary 隔离错误，不让单点崩溃扩散。
2）**契约化**：

要点包括：Props 设计分层（必选/可选/默认值）；类型定义避免 any 扩散（尤其是数据结构与回调签名）；对外 API 保持稳定，扩展点用 render props/slot 方式开放。

3）**可观测与降级**：关键失败上报 + 开关降级（例如接口失败时的降级展示）。
4）**物料化铺垫**：把组件的“配置项、默认值、校验规则、事件定义”整理成物料描述，为后续低代码接入降低成本。

---

#### 技术点 3：低代码平台接入落地怎么实现的？（贡献组件 → 深度使用 → 提效）

**面试官：低代码平台你是怎么落地的？**

**1、问题出现的原因 + 为什么必须处理（典型前端问题）**：
表单/配置类页面是典型“高重复 + 高变更”场景：字段换一换、规则改一改就要重新开发/测试，长期会把团队产能耗在重复劳动上。要提效必须靠“标准化组件 + schema 驱动”，否则低代码只会变成另一个维护负担。

**2、结合项目背景**：RMS 很多页面是“字段差异 + 规则差异”，适合 schema 驱动；但也有复杂交互不适合低代码，需要边界清晰。

**3、解决方案（适当展开技术细节）**：
1）**路径设计：先“可控收益”再“规模化”**：先从结构稳定、风险低的页面试点；沉淀模板后再扩面。
2）**物料与 schema 的对应关系**：

要点包括：每个物料组件都有配置面板 schema、默认值、校验规则、事件定义；schema 描述组件树 + props + 事件 + 校验 + 数据源绑定。

3）**运行态渲染器**：递归渲染 + 表达式解析 + 事件分发；对联动场景用依赖图/事件总线避免“散落在页面代码里”。
4）**版本与迁移**：schema 版本化；当 schema 结构演进时提供 migration，避免历史页面打不开。
5）**安全与权限**：表达式能力白名单化，禁止任意执行；运行态按权限裁剪组件/配置。
6）**性能**：虚拟滚动/按需渲染/批量更新；编辑器与运行态拆包，避免把编辑器代码带到线上运行包。

---

### 4）项目三：跨平台公告插件系统（2023.02-2023.03）

#### 公告插件：项目介绍（背景 → 做了什么事 → 价值）

**面试官：跨平台公告插件你怎么做的？**

**项目背景**：多个内部系统缺少统一的“紧急公告/发版公告”能力，如果每个系统各做一套会重复建设；同时各系统技术栈不同，需要极简、跨平台、易接入。

**做了什么事**：我独立设计并交付了一个公告插件 SDK：

- 统一接入协议（token/appId 等），服务端配置投放策略。
- 运行时热插拔（init/destroy）、错误隔离、资源隔离。
- 多模式植入：CDN/ESM/Web Component（必要时 iframe 兜底）。
- 构建用 Rollup 做 Tree Shaking，渲染用 Preact 追求极小体积。

**价值**：包体积 < 15KB，单系统接入成本 < 0.5 人日，跨 5 个系统标准化接入，紧急公告触达率 100%。

---

### 技术点 1：多模式植入方案怎么设计的？

**面试官：多模式植入你怎么设计？**

**1、突出问题**：不同系统技术栈/构建方式不同，如果只提供一种接入形态，接入成本会很高。

**2、结合项目背景**：有的系统是老项目无法改构建链路，有的系统能走 npm；还需要支持快速临时接入（CDN）。

**3、解决方案**：
1）**CDN/UMD**：最简单，适合快速接入与老系统。
2）**ESM/NPM**：适合现代工程体系，按需引入、可 Tree Shaking。
3）**Web Component**：框架无关，作为通用形态。
4）**iframe 兜底（可选）**：在强隔离场景（样式冲突严重/安全要求高）用 iframe，代价是通信与性能。

---

### 技术点 2：为什么选择 Preact？

**面试官：为什么不用 React，而用 Preact？**

**1、突出问题**：SDK 目标是“无感接入、体积极小”，React 体积对 SDK 过重，且宿主可能已有 React 版本冲突风险。

**2、结合项目背景**：公告本质是一个轻量 UI + 数据拉取，不需要重型生态；关键是不能影响宿主性能。

**3、解决方案**：
1）**体积**：Preact 内核小，配合压缩与 Tree Shaking 更容易把 SDK 控制在 < 15KB。
2）**性能与渲染**：小组件渲染链路更短；必要时用 signal/细粒度更新减少重渲染。
3）**兼容策略**：输出多格式，避免强绑定宿主框架。

---

### 技术点 3：为什么选择 Rollup 打包？

**面试官：为什么选择 Rollup，而不是 Webpack？**

**1、突出问题**：SDK 场景更关注“产物体积与 Tree Shaking 效果”，而不是大型应用的复杂构建能力。

**2、结合项目背景**：公告 SDK 代码以 ESM 为主，依赖需要极简，产物要同时支持 UMD/ESM。

**3、解决方案**：
1）Rollup 对库模式与 Tree Shaking 更友好，配置更聚焦。
2）多格式输出（UMD/ESM）更顺手，适配多接入方式。
3）配合 terser/压缩策略，更容易把体积压到目标范围。

---

### 5）项目四：大疆 DevOps 平台维护（2024.03-2025.04）

#### DevOps：项目介绍（背景 → 做了什么事 → 价值）

**面试官：DevOps 平台你做了什么？**

**项目背景**：内部 DevOps 平台支撑研发流程（权限/需求/自动化测试/文档等），需要持续迭代并保持稳定。

**做了什么事**：我作为核心开发者，做功能迭代与平台治理，包括 Jira 插件对接、流水线体验优化、Workspace 审批流等。

**价值**：提升流程审批效率与部署效率，降低人工操作与出错概率，保障流水线稳定运行。

---

#### 技术点：Docker 流水线自动化部署怎么实现的？

**面试官：Docker 流水线自动化部署你怎么做的？**

**1、问题出现的原因 + 为什么必须处理（典型工程问题）**：
部署是典型“高风险重复劳动”：手工步骤多就会出错，出了问题也难追溯；在多环境下更容易配置漂移。把部署流水线化，本质是把交付从“人的经验”变成“系统能力”。

**2、结合项目背景**：平台服务多、依赖多，需要把部署过程标准化，做到可回滚、可审计。

**3、解决方案（适当展开技术细节）**：
1）**镜像与依赖一致性**：统一 Dockerfile、基础镜像与构建参数；版本以 commit sha/语义化版本打 tag。
2）**流水线阶段化**：build/test → image build → scan → deploy → verify；每一阶段产出可追溯记录。
3）**配置治理**：配置与密钥分离；环境差异通过配置中心/环境变量管理，避免镜像内写死。
4）**发布与回滚**：支持灰度/回滚；失败自动阻断并告警；验证阶段做健康检查与关键接口探活。

---

### 6）项目五：XDR 系统 - 魔方大屏 + 报表（2025.05-2025.12）

#### XDR：项目介绍（背景 → 做了什么事 → 价值）

**面试官：XDR 大屏和报表你做了什么？**

**项目背景**：这是安全运营相关的大数据可视化系统，需要高性能渲染与稳定的数据链路；同时存在“报表生成与分发”的自动化诉求。

**做了什么事**：我作为核心开发者，主要负责：

- 大屏可视化组件与渲染（Vue3 + ECharts），强调性能与交互体验。
- NestJS 全栈：数据聚合、定时任务、报表生成与邮件推送。
- 报表导出：支持 PDF/PPT/Excel 等多格式。

**价值**：万级数据快速渲染与交互；报表自动化提升运营效率，并降低人工成本。

---

#### 技术点：报表定时功能怎么实现的？

**面试官：你提到报表定时生成，具体怎么做的？**

**1、问题出现的原因 + 为什么必须处理（典型后端/全栈问题）**：
定时报表是典型“异步任务系统”问题：多实例会导致重复执行；导出耗时会拖垮主服务；失败如果没有告警与补偿就会变成业务事故。

**2、结合项目背景**：报表可能涉及聚合查询与渲染导出，耗时不稳定；还要保证“每天按时生成、生成失败可重试、可追溯”。

**3、解决方案（适当展开技术细节）**：
1）**调度 + 幂等**：cron 只负责触发，执行侧用“业务幂等键/分布式锁”保证同一周期只跑一次。
2）**任务状态模型**：任务实例入库（开始/成功/失败/耗时/产物地址/错误信息），支持补跑与审计。
3）**异步化**：导出与重计算走队列/worker，主服务只做编排，避免 CPU/内存被导出占满。
4）**并发与限流**：同一时间控制导出并发，避免高峰期雪崩；超时与重试使用退避策略。
5）**监控告警**：成功率、P95 耗时、队列堆积等指标上报；失败自动告警。

---

### 7）常见缩写（面试时可随口解释）

- RTT（Round-Trip Time）：网络往返时延，影响握手与请求时延。
- FCP（First Contentful Paint）：首次内容绘制。
- LCP（Largest Contentful Paint）：最大内容绘制（通常是首屏主内容块/主图）。
- CLS（Cumulative Layout Shift）：累积布局偏移。
- RUM（Real User Monitoring）：真实用户监控数据（线上采样）。

---
