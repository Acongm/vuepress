# Web 前端开发工程师（彭聪）- 面试技术大纲

> 目标：按项目经历拆解高频面试方向，形成可持续扩展的题库骨架（核心概念 → 常考点 → 深挖追问 → 落地实践/踩坑）。

---

## 1）大疆用户中心重构：性能优化 + HTTP 原理 + Webpack 架构

### 性能指标与方法论

- **指标体系**：LCP / FCP / TTI / CLS / INP、首屏/白屏时间、资源体积、接口耗时、缓存命中率
- **定位手段**：Performance / Network 面板、Lighthouse、Web Vitals 上报、Long Task 分析
- **优化策略**：关键渲染路径优化、渐进式渲染（骨架屏 / 占位 / 分片渲染）

### 简历可落地点（结合你的“优化四板斧”）

- **骨架屏预渲染**：怎么做（预生成/服务端直出/静态骨架）、一致性（闪烁/布局偏移）、对 LCP 的影响评估
- **更小的代码体积**：`core-js` 精简、字体子集化/压缩、CSS 打包策略（提取/合并/按需）
- **更快的加载与渲染**：资源优先级（preload/prefetch）、合理加载顺序、gzip/br、首屏关键资源最小化
- **传输层优化**：TLS 1.3 的收益点（握手/复用/延迟），以及真实线上观测方法
- **图片优化**：WebP/AVIF 接入、兼容兜底策略、图片尺寸与懒加载、占位与解码开销

### HTTP 常考点（从“为什么变快”倒推）

- **HTTP/1.1 vs HTTP/2 vs HTTP/3**：队头阻塞、并发模型、HPACK/QPACK、0-RTT
- **TLS**：握手流程、证书链、会话复用、OCSP Stapling、连接复用与域名拆分的取舍
- **缓存体系**：强缓存/协商缓存、CDN 缓存、版本号/哈希策略、Service Worker 缓存与更新

### Webpack 架构（工程化面试常考）

- **构建流程**：entry → module graph → loader → plugin → chunks → assets
- **产物与优化**：splitChunks、runtimeChunk、tree-shaking（sideEffects）、scope hoisting
- **构建性能**：持久化缓存、并行压缩、sourceMap 策略、bundle 分析与预算（budgets）
- **现代替代**：Webpack vs Vite（依赖预构建/ESM dev server）什么时候选谁、迁移风险点

### 按优化顺序，把方案“串起来”（排查 → 定位 → 选择 → 验证）

> 面试复述主线：我先把目标收敛到 **LCP/首屏**（简历：LCP 2.3s → 1.4s，首屏 < 1.5s），然后沿着浏览器关键链路 **网络 → 解析 → 渲染 → 资源加载** 分段拆解瓶颈，做到“每一刀都有证据、每一刀都有回归验证”。

#### 0. 排查与基线（先把问题“量化”）

- **先定指标**：以 LCP/首屏为主，辅以 FCP/CLS/INP 与关键接口耗时、缓存命中率，建立对比基线（同机型/同网络/同账号/同页面路径）。
- **再抓证据**：
  - Network：看首屏关键资源（HTML/CSS/JS/字体/首图）耗时、阻塞关系、是否命中缓存、压缩比、协议版本。
  - Performance：看长任务（Long Task）、主线程忙点、是否存在明显的解析/执行阻塞。
  - Lighthouse/Web Vitals：把“体感慢”对齐到可度量指标（LCP/TTFB/资源体积/阻塞时长）。

#### 1. 先保“可见”——骨架屏预渲染（直接拉低 LCP）

- **为什么先做这个**：首屏慢最影响转化；骨架屏让“关键内容更早可见”，对 LCP 的改善最直接（你简历里也有明确收益）。
- **怎么做（可讲实现）**：骨架结构尽量接近最终布局，避免布局抖动；必要时对骨架做预生成/内联关键 CSS，减少等待 JS 执行才出内容。
- **提升对比**：LCP **2.3s → 1.4s**；同时重点解释如何控制 CLS（骨架与真实内容尺寸一致、占位策略）。

#### 2. 再减“阻塞”——关键渲染路径（CRP）梳理：CSS/字体/首图优先级

- **浏览器原理串联**：HTML 解析生成 DOM；CSS 会影响 render tree，**关键 CSS 阻塞首屏渲染**；字体可能触发 FOIT/FOUT；首图通常成为 LCP 候选。
- **为什么这么做**：如果首屏被 CSS/字体/首图阻塞，再快的接口也救不了 LCP。
- **典型落地动作**：
  - 关键 CSS 优先（提取/内联/拆分），非关键样式延后加载。
  - 字体压缩/子集化，配合合理的 `font-display`，减少阻塞与重排。
  - 首图优先级提升（preload/合理格式），非首屏图片懒加载。
- **验证方式**：对比首屏关键资源 waterfall：阻塞链缩短、首屏 render 更早发生；CLS 保持可控。

#### 3. 再降“下载与解析成本”——更小的包体与更少的无效代码

- **为什么选择精简体积**：JS 体积不仅影响下载，还会影响 **parse/compile/execute**（主线程占用），在中低端机更明显。
- **你简历可对应的动作**：精简 `core-js`、优化打包 CSS、字体压缩，做到“只给首屏必须的”。
- **验证方式**：对比 bundle 体积、首屏 chunk 数量、主线程长任务占比是否下降。

#### 4. 再优化“传输层”——gzip + TLS 1.3（让关键资源更快到达）

- **浏览器原理串联**：首屏每个关键请求都要经历连接建立/握手/传输；在弱网下握手与 RTT 很敏感。
- **为什么选 TLS 1.3**：减少握手开销、提升连接建立效率（配合 HTTP/2 复用更明显）；属于“全站收益”的优化点。
- **为什么选 gzip**：对文本资源（HTML/CSS/JS/JSON）压缩收益明显，直接减少传输字节数。
- **验证方式**：看响应头 `content-encoding`、压缩比、TTFB/下载耗时变化；对比首屏关键资源总下载字节与耗时。

#### 5. 最后补“图片格式”——WebP（兼顾体积与视觉）

- **为什么放在后面**：它主要改善的是“图片传输体积”，通常要在关键链路梳理完后做收尾提速；同时需要考虑兼容兜底。
- **怎么做（可讲兜底）**：按 UA/能力探测选择 WebP，旧环境回退 png/jpg；结合响应式图片与尺寸裁剪避免“传大图缩小显示”。
- **验证方式**：对比同一首图资源体积与下载耗时，确认 LCP 候选资源更快完成。

#### 6. 回归与守护（防止“优化回退”）

- **回归矩阵**：不同端（PC/移动）、不同网络（4G/弱网）、不同页面路径的对比；重点盯 LCP/CLS/错误率。
- **长期治理**：建立性能预算（bundle/首屏资源上限）、上线前 Lighthouse/关键指标门禁、线上 Web Vitals 监控告警。

---

## 2）Umi：ESLint 规范有哪些，以及如何整合到实践

### 规范维度（“你定了哪些规则”）

- **职责边界**：Prettier（格式化）与 ESLint（语义规则/质量）的分工与冲突处理
- **React 规范**：Hooks 规则、JSX 可读性、key、受控/非受控、可访问性（a11y）基础
- **TypeScript 规范**：noImplicitAny、no-unused-vars、类型收窄、联合类型/枚举取舍、any 的管控策略
- **import 规范**：import/order、禁止深层路径、依赖分层（domain/ui/shared）、循环依赖治理
- **安全与质量**：no-eval、危险 API、Promise 处理（如 no-floating-promises）、错误边界与日志

### Umi 落地方式（“如何让团队真的执行”）

- **配置策略**：extends/override、不同包/目录的差异化规则、渐进收敛（warning → error）
- **开发体验**：IDE 保存自动修复、统一 Node/TS 版本、避免“本地过/CI 不过”
- **流程约束**：husky + lint-staged + commitlint，PR 门禁（lint/类型检查/单测可选）
- **技术债治理**：老代码豁免策略（文件/目录）、技术债清单与收敛节奏

### 末尾补充细节（结合简历：用规则做 Code Review + commit 校验 + CI/CD 门禁）

#### A. 背景口径（面试可复述）

- **背景**：RMS/中后台多人协作，页面多、交叉开发频繁，最怕“风格不统一 + 隐性 Bug + 模块乱引用”，Review 会被拉成“挑格式/找引用”的低效劳动。
- **做法**：把格式交给 Prettier，把质量/边界交给 ESLint，并串成闭环：**IDE 自动修复 → 提交拦截（lint-staged）→ PR/CI 门禁（max-warnings=0）**。

#### B. Review 时“高收益”规则清单（你重点盯这些）

- **Hooks 正确性**：`react-hooks/rules-of-hooks`、`react-hooks/exhaustive-deps`（避免线上难复现问题）
- **TS 边界**：限制 `any`（如 `@typescript-eslint/no-explicit-any`，少量豁免必须写注释原因），关键模块鼓励更严格的类型约束
- **import 可读性**：`import/order`（导入分组清晰，文件更好读）
- **模块化边界**：`no-restricted-imports`（禁止跨层/跨域/深层路径引用，只允许从模块出口 `index.ts` 导入，防止绕过封装）
- **循环依赖**：`import/no-cycle`（避免运行时奇怪行为）
- **基础质量**：`no-debugger`、`no-console`（按环境）、unused 相关规则（减少死代码/误用）

#### C. Umi + commit + CI/CD 的落地链路（保证“真的执行”）

- **Umi 基座**：基于 Umi 推荐的 eslint 配置（例如 `eslint-config-umi` / `@umijs/fabric` 一类）统一 extends，再按团队补齐 TS/Hooks/import 边界规则
- **commit 校验**：
  - lint-staged：只检查改动文件，反馈快
  - commitlint：统一提交信息（Conventional Commits），便于回滚与追溯
  - husky：把校验固化为钩子，不依赖口头约束
- **PR/CI 门禁**：lint（可用 `--max-warnings=0`）+ typecheck +（按项目）单测/覆盖率；老代码用“目录豁免 + 逐步收敛”治理技术债

#### D. “规范代码模块化”的面试回答模板

- **结构建议**：`shared`（通用）/ `features`（领域能力）/ `pages`（路由页）/ `services`（接口层）
- **规则固化**：用 `no-restricted-imports` 把“只能从出口导入、禁止跨层依赖”写死，让模块边界可自动检查；Review 重点从“挑格式/找乱引用”转回“业务正确性与架构演进”，整体可读性显著提升。

---

## 3）跨平台公告插件系统：Rollup / Webpack / Vite 横向对比 + Preact 选型

### 构建工具横向（以“插件库”视角）

- **Rollup**：库友好（ESM/CJS/UMD 输出）、tree-shaking 强、产物干净（你简历：包体积 < 15KB）
- **Webpack**：应用友好（复杂依赖、生态成熟、运行时/分包能力强）
- **Vite**：开发快（ESM dev server），打包多基于 Rollup；库模式/应用模式如何选与配置差异
- **对比维度**：产物格式、tree-shaking、code-splitting、polyfill 策略、体积与构建时间、调试体验

### Preact 选型（你简历：极简内核 + signals）

- **与 React 对比**：体积、兼容层（preact/compat）、生态差异与风险
- **signals 心智模型**：更新粒度与性能收益、与 hooks 的协同方式、可维护性权衡
- **典型追问**：为什么不是纯原生？为什么不是 Web Components-only？什么时候一定要 React？

---

## 4）跨平台公告插件系统：如何实现热插拔 + 如何实现多路复用

### 热插拔（加载/卸载/升级可控）

- **生命周期设计**：init → mount → update → unmount（资源回收：事件/定时器/DOM/订阅）
- **隔离策略**：
  - CSS：shadow DOM / 命名空间 / 样式前缀
  - JS：iframe / sandbox / 全局污染治理
- **灰度与回滚**：版本号、远端开关、异常兜底（fallback UI/禁用/熔断）、可观测性（监控/告警）
- **植入模式取舍**：CDN / Iframe / Web Component（隔离性、通信成本、性能、接入复杂度）

### 多路复用（一次构建/一次运行服务多个系统）

- **复用层级**：
  - 构建产物复用：同一包多系统使用（版本治理、兼容性）
  - 运行时复用：共享 runtime、避免重复初始化
  - 配置复用：策略中心（公告内容/规则/权限）统一下发
- **资源缓存与去重**：脚本缓存/预加载、单例加载器（避免重复注入）、依赖去重与冲突处理
- **通信复用**：统一协议（postMessage/event bus），多宿主路由/鉴权/埋点如何对齐
- **典型追问**：多系统不同 React/Vue 版本怎么接？冲突怎么隔离？如何做到接入 < 0.5 人日？

---

## 5）大疆 DevOps 平台维护：流水线 CI/CD 原理

### CI/CD 基础链路

- **触发方式**：push/PR/tag/定时；多分支策略与环境映射
- **流水线阶段**：build → test → scan → package → deploy
- **产物管理**：artifact、版本号策略、可追溯（commit → 构建 → 镜像 → 发布）
- **环境治理**：dev/staging/prod，配置/密钥管理（env/secret），审批流（你简历：Workspace 审批流程）

### Docker 与发布策略

- **镜像原理**：分层、缓存命中、依赖安装优化（pnpm/yarn cache）
- **发布模式**：蓝绿/金丝雀/滚动、健康检查、回滚策略、变更审计

### 质量与安全

- **门禁**：lint/类型检查/单测/覆盖率、代码扫描（SAST）、依赖漏洞扫描、权限最小化

---

## 6）大疆 DevOps 平台维护：微前端选型 + 各微前端原理

### 选型维度（为什么是 qiankun）

- **组织与交付**：多团队独立部署、技术栈混用、历史系统包袱、统一路由/权限/菜单
- **体验与成本**：首屏、子应用加载、公共依赖共享、预加载策略与运行时开销

### 核心原理（面试深挖点）

- **注册与加载**：entry 获取、HTML 解析、资源注入、生命周期调度
- **隔离机制**：CSS 隔离（shadow/strict sandbox）、JS sandbox（proxy/快照/白名单）
- **通信方式**：props、全局事件、状态共享、URL 协议；如何避免耦合与“隐式依赖”
- **方案对比**：single-spa、Module Federation、iframe：边界、代价、适用场景

---

## 7）魔方大屏：低代码内部原理

### 核心架构（Schema 驱动）

- **物料体系**：组件元信息（props schema / 事件 schema / 默认值 / 版本治理）
- **渲染器**：schema → runtime tree；布局系统（栅格/自由布局/约束）
- **编辑器能力**：拖拽、吸附/对齐、缩放、撤销重做（命令模式）、多选/编组

### 数据与交互

- **数据源**：静态/接口/订阅；数据加工（transform）；刷新策略与容错
- **事件编排**：组件联动、全局变量、表达式引擎（安全沙箱/白名单）

### 工程化与稳定性

- **运行时性能**：高频刷新、局部更新、虚拟化、渲染降级与节流
- **兼容与升级**：schema 迁移、物料兼容、线上配置回滚与灰度

---

## 8）报表：NestJS 的 SSR 原理

### SSR 本质（Nest 视角）

- **渲染流程**：路由命中 → 拉取数据 → renderToString / stream → 返回 HTML
- **Hydration**：客户端接管、同构数据注水（dehydrate）、一致性与边界（时间/随机数/环境差异）
- **流式 SSR**：TTFB、chunk 传输、边渲染边发的收益与坑（错误处理/中断/缓存）

### 报表场景的 SSR 价值

- **价值点**：首屏/SEO、权限鉴权、直出可下载页面（配合导出 PDF/PPT/DOCS）
- **缓存策略**：页面级缓存、数据级缓存、按用户/按权限隔离缓存与失效机制

### 典型追问点

- **与 Next.js/Remix 的差别**：Nest 做 BFF + 自研 SSR 的成本/收益/边界
- **稳定性与降级**：渲染失败回退 CSR、超时控制、资源泄露与并发治理
