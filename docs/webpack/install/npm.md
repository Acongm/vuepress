# npm

## 早期的 npm

其实在最早期的`npm`版本(npm v2)，`npm`的设计可以说是非常的简单,在安装依赖的时候会将依赖放到` node_modules`文件中; 同时,如果某个直接依赖 A 依赖于其他的依赖包 B,那么依赖 B 会作为间接依赖,安装到依赖 A 的文件夹`node_modules`中,然后可能多个包之间也会有出现同样的依赖递归的,如果项目一旦过大,那么必然会形成一棵巨大的依赖树，依赖包会出现重复,形成`嵌套地狱`。

### 那么我们如何去理解"嵌套地狱"呢？

- 首先,项目的依赖树的层级过于深，如果有问题不利于排查和调试
- 在依赖的分支中,可能会出现同样版本的相互依赖的问题

### 那么这样的重复问题会带来什么后果呢？

- 首先,会使得安装的结果占据了大量的空间资源,造成了资源的浪费
- 同时,因为安装的依赖重复,会造成在安装依赖时,安装时间过长
- 甚至是,因为目录层级过深,导致文件路径过长,会在`windows`系统下删除`node_modules`文件,出现删除不掉的情况

### 你在实际的开发会不会出现这样的一些情况

当你项目依赖出现问题的时候, 我们会不会是直接删除` node_modules 和 lockfiles`依赖, 再重新 `npm install`,删除大法是否真的好用?这样的使用方案会不会带来什么问题？

把所有的依赖包都安装到`dependencies`中,对`devDependencies` 不区分会不会有问题?

一个项目中, 你使用 `yarn`, 我使用`npm`，会不会有问题呢？

还有一个问题, `lockfiles 文件` 我们提交代码的时候需不需要提交到仓库中呢？

## 目标

```
给你和你的团队、你的公司带来最好的开源库和依赖。 通过这句话,我们可以了解到 npm 最重要的一点就是安装和维护依赖。
```

## 安装机制

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fbc0e4e27c14500a2a9e4fcf4757fae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

`npm install`执行之后, 首先会检查和获取 `npm的配置`,这里的优先级为:

```
项目级的.npmrc文件 > 用户级的 .npmrc文件 > 全局级的 .npmrc > npm内置的 .npmrc 文件
```

`保持npm 版本的一致性`

## 参考资料

- [npm-官网](https://www.npmjs.com/)

- [npm-掘金](https://juejin.cn/post/6844903870578032647)
