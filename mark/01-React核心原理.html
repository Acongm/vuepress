<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.32">
    <link rel="apple-touch-icon" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#3eaf7c"><meta name="msapplication-TileImage" content="/favicon.ico"><link rel="manifest" href="/manifest.webmanifest"><meta name="theme-color" content="#3eaf7c"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="msapplication-TileColor" content="#000000"><script src="https://hm.baidu.com/hm.js?8e5be87f55d52e1115a38afce593d2bb"></script><title>React 16+ 各版本区别 & React 核心原理 | acongm</title><meta name="description" content="前端常用知识、踩坑记录、软件推荐等">
    <link rel="preload" href="/vuepress/assets/js/runtime~app.50eb729e.js" as="script"><link rel="preload" href="/vuepress/assets/css/styles.fc93d6da.css" as="style"><link rel="preload" href="/vuepress/assets/js/5316.94e78182.js" as="script"><link rel="preload" href="/vuepress/assets/js/app.8a17bbf0.js" as="script">
    <link rel="stylesheet" href="/vuepress/assets/css/styles.fc93d6da.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/vuepress/" class=""><img class="logo" src="/vuepress/logo.jpg" alt="acongm"><span class="site-name can-hide">acongm</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="基础语言"><span class="title">基础语言</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="基础语言"><span class="title">基础语言</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>JavaScript</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/JavaScript/" class="" aria-label="js 基础知识"><!--[--><!--]--> js 基础知识 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/JavaScript/%E7%BB%8F%E5%85%B8%E9%97%AD%E5%8C%85%E5%A4%84%E7%90%86.html" class="" aria-label="经典闭包处理"><!--[--><!--]--> 经典闭包处理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/JavaScript/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-%E9%97%AD%E5%8C%85.html" class="" aria-label="执行上下文-作用域链-闭包"><!--[--><!--]--> 执行上下文-作用域链-闭包 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/JavaScript/call%E3%80%81apply%E4%B8%8Ebind.html" class="" aria-label="call、apply 与 bind"><!--[--><!--]--> call、apply 与 bind <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/JavaScript/js%E6%A8%A1%E6%8B%9Fbind%E6%96%B9%E6%B3%95.html" class="" aria-label="js 模拟 bind 方法"><!--[--><!--]--> js 模拟 bind 方法 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/JavaScript/js%E6%A8%A1%E6%8B%9Fnew%E6%93%8D%E4%BD%9C.html" class="" aria-label="能否模拟实现 JS 的 new 操作符"><!--[--><!--]--> 能否模拟实现 JS 的 new 操作符 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>TypeScript</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/TypeScript/" class="" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/TypeScript/Study.html" class="" aria-label="每天学一点 TS"><!--[--><!--]--> 每天学一点 TS <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>CSS</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/css/" class="" aria-label="CSS 语法相关"><!--[--><!--]--> CSS 语法相关 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/css/skill.html" class="" aria-label="CSS 奇淫技巧"><!--[--><!--]--> CSS 奇淫技巧 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/css/scss.html" class="" aria-label="常用 SCSS 宏"><!--[--><!--]--> 常用 SCSS 宏 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="框架生态"><span class="title">框架生态</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="框架生态"><span class="title">框架生态</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>React</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/react/class-hooks.html" class="" aria-label="react"><!--[--><!--]--> react <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/react/react16.html" class="" aria-label="十五分钟读懂 React 16"><!--[--><!--]--> 十五分钟读懂 React 16 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/react/react17.html" class="" aria-label="十五分钟读懂 React 17"><!--[--><!--]--> 十五分钟读懂 React 17 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/react/react18.html" class="" aria-label="React 18 新特性"><!--[--><!--]--> React 18 新特性 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/react/react-render.html" class="" aria-label="React 的渲染流程"><!--[--><!--]--> React 的渲染流程 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Vue</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/vue_theory.html" class="" aria-label="vue 原理"><!--[--><!--]--> vue 原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/vue_interview.html" class="" aria-label="vue 面试题"><!--[--><!--]--> vue 面试题 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/vue3.html" class="" aria-label="vue3 原理 - 总结"><!--[--><!--]--> vue3 原理 - 总结 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/code/Object.defineproperty.html" class="" aria-label="Object.defineproperty 核心代码 自定义实现"><!--[--><!--]--> Object.defineproperty 核心代码 自定义实现 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/code/Proxy.html" class="" aria-label="Proxy 核心代码 自定义实现"><!--[--><!--]--> Proxy 核心代码 自定义实现 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/code/proxy-observe.html" class="" aria-label="proxy-observe 核心代码 自定义实现"><!--[--><!--]--> proxy-observe 核心代码 自定义实现 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/vue-render.html" class="" aria-label="Vue 的渲染流程"><!--[--><!--]--> Vue 的渲染流程 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/vue2.html" class="" aria-label="vue 原理"><!--[--><!--]--> vue 原理 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>设计模式</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/Pattern/%E6%A8%A1%E5%BC%8F%E6%9D%A5%E6%BA%90%E4%B8%8E%E7%B1%BB%E6%AF%94.html" class="" aria-label="这些跨组件通信模式，你可能在哪见过？（来源与类比）"><!--[--><!--]--> 这些跨组件通信模式，你可能在哪见过？（来源与类比） <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/Pattern/" class="" aria-label="跨组件通信模式合集"><!--[--><!--]--> 跨组件通信模式合集 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工程化"><span class="title">工程化</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工程化"><span class="title">工程化</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>构建工具</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86.html" class="" aria-label="Webpack - 介绍"><!--[--><!--]--> Webpack - 介绍 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86.html" class="" aria-label="Webpack - 架构及原理"><!--[--><!--]--> Webpack - 架构及原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/vite-%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86.html" class="" aria-label="vite - 知识梳理"><!--[--><!--]--> vite - 知识梳理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/vite-%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86.html" class="" aria-label="vite - 架构及原理"><!--[--><!--]--> vite - 架构及原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/webpack-vite-rollup.html" class="" aria-label="Webpack、Vite、Rollup"><!--[--><!--]--> Webpack、Vite、Rollup <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/install/ni.html" class="" aria-label="install"><!--[--><!--]--> install <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/install/npm.html" class="" aria-label="npm"><!--[--><!--]--> npm <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/install/pnpm.html" class="" aria-label="/webpack/install/pnpm.md"><!--[--><!--]--> /webpack/install/pnpm.md <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/install/yarn.html" class="" aria-label="install"><!--[--><!--]--> install <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7.html" class="" aria-label="install"><!--[--><!--]--> install <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Node.js</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/node/npm.html" class="" aria-label="npm 相关"><!--[--><!--]--> npm 相关 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/node/toolkit.html" class="" aria-label="常用工具包"><!--[--><!--]--> 常用工具包 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Git</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/git/" class="" aria-label="Git"><!--[--><!--]--> Git <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/git/command.html" class="" aria-label="Git 命令清单"><!--[--><!--]--> Git 命令清单 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/git/commit.html" class="" aria-label="Git commit 规范"><!--[--><!--]--> Git commit 规范 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>性能优化</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/performance/" class="" aria-label="用户中心前端性能优化实战文档"><!--[--><!--]--> 用户中心前端性能优化实战文档 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="进阶专题"><span class="title">进阶专题</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="进阶专题"><span class="title">进阶专题</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>技能提炼</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/" class="router-link-active" aria-label="自我面试"><!--[--><!--]--> 自我面试 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html" class="router-link-active router-link-exact-active router-link-active" aria-label="React 16+ 各版本区别 &amp; React 核心原理"><!--[--><!--]--> React 16+ 各版本区别 &amp; React 核心原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E8%A1%A5%E5%85%85.html" class="" aria-label="React 19 新特性详解 &amp; useMemo/useCallback 深度解析"><!--[--><!--]--> React 19 新特性详解 &amp; useMemo/useCallback 深度解析 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/02-Webpack%E4%B8%8E%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html" class="" aria-label="Webpack 架构 &amp; 与 Rollup、Vite 对比 &amp; 核心原理"><!--[--><!--]--> Webpack 架构 &amp; 与 Rollup、Vite 对比 &amp; 核心原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/03-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" class="" aria-label="性能优化流程 &amp; 从浏览器请求链路解释&quot;为什么这么优化&quot;"><!--[--><!--]--> 性能优化流程 &amp; 从浏览器请求链路解释&quot;为什么这么优化&quot; <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/04-%E5%BE%AE%E5%89%8D%E7%AB%AF.html" class="" aria-label="微前端对比 &amp; 各方案实现原理"><!--[--><!--]--> 微前端对比 &amp; 各方案实现原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/05-%E4%BD%8E%E4%BB%A3%E7%A0%81.html" class="" aria-label="低代码 &amp; 核心原理"><!--[--><!--]--> 低代码 &amp; 核心原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/06-%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F.html" class="" aria-label="热插拔插件系统对比 &amp; 各方案实现原理差异"><!--[--><!--]--> 热插拔插件系统对比 &amp; 各方案实现原理差异 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/07-NestJS%E4%B8%8ESSR.html" class="" aria-label="从 NestJS 全栈开发到 SSR &amp; SSR 核心原理"><!--[--><!--]--> 从 NestJS 全栈开发到 SSR &amp; SSR 核心原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/08-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.html" class="" aria-label="代码规范 &amp; Umi/ESLint 规范为什么这样设计 &amp; 如何落地"><!--[--><!--]--> 代码规范 &amp; Umi/ESLint 规范为什么这样设计 &amp; 如何落地 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/09-Promise%E5%8E%9F%E7%90%86.html" class="" aria-label="JS 为什么会设计 Promise &amp; 如何手写实现一个 Promise"><!--[--><!--]--> JS 为什么会设计 Promise &amp; 如何手写实现一个 Promise <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/10-%E9%AA%A8%E6%9E%B6%E5%B1%8F.html" class="" aria-label="骨架屏怎么提升性能的？骨架屏的原理及实现"><!--[--><!--]--> 骨架屏怎么提升性能的？骨架屏的原理及实现 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/11-HTTP%E4%B8%8E%E7%BC%93%E5%AD%98.html" class="" aria-label="从性能优化到 HTTP 变化及缓存"><!--[--><!--]--> 从性能优化到 HTTP 变化及缓存 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/React%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3.html" class="" aria-label="React 更新流程详解"><!--[--><!--]--> React 更新流程详解 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>AI 开发</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/ai/" class="" aria-label="AI 相关"><!--[--><!--]--> AI 相关 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>踩坑记录</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/issue/h5.html" class="" aria-label="H5 相关"><!--[--><!--]--> H5 相关 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/issue/pc.html" class="" aria-label="PC 相关"><!--[--><!--]--> PC 相关 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工具箱"><span class="title">工具箱</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工具箱"><span class="title">工具箱</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>工具函数</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/utils/regexp.html" class="" aria-label="常用正则"><!--[--><!--]--> 常用正则 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/utils/function.html" class="" aria-label="常用方法"><!--[--><!--]--> 常用方法 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/utils/library.html" class="" aria-label="库收集"><!--[--><!--]--> 库收集 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>在线工具</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/online-tools/" class="" aria-label="网页工具"><!--[--><!--]--> 网页工具 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/online-tools/bookmark-scripts.html" class="" aria-label="书签脚本"><!--[--><!--]--> 书签脚本 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>软件推荐</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/software/cross-platform.html" class="" aria-label="多平台"><!--[--><!--]--> 多平台 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/mac.html" class="" aria-label="Mac 平台"><!--[--><!--]--> Mac 平台 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/windows.html" class="" aria-label="Windows 平台"><!--[--><!--]--> Windows 平台 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/browser.html" class="" aria-label="浏览器扩展"><!--[--><!--]--> 浏览器扩展 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/vscode.html" class="" aria-label="Visual Studio Code 扩展"><!--[--><!--]--> Visual Studio Code 扩展 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/webstorm.html" class="" aria-label="WebStorm 配置"><!--[--><!--]--> WebStorm 配置 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/zsh.html" class="" aria-label="zsh"><!--[--><!--]--> zsh <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/claude-skills-guide.html" class="" aria-label="Claude Skills 基础原理与编写指南"><!--[--><!--]--> Claude Skills 基础原理与编写指南 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="面试"><span class="title">面试</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="面试"><span class="title">面试</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>面试准备</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/interview-prep/" class="" aria-label="知识列表"><!--[--><!--]--> 知识列表 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/theory/" class="" aria-label="面试题库"><!--[--><!--]--> 面试题库 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/interview/2025-04-28.md" class="" aria-label="面试记录"><!--[--><!--]--> 面试记录 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>简历问答</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/job-description/ASK_LIST.md" class="" aria-label="问答大纲"><!--[--><!--]--> 问答大纲 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/job-description/ASK_RECORD_SPEAK_AI.md" class="" aria-label="口语版"><!--[--><!--]--> 口语版 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/job-description/ASK_CODE_EXAMPLES.md" class="" aria-label="代码版"><!--[--><!--]--> 代码版 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/job-description/ASK_RECORD_KEY.md" class="" aria-label="知识点索引"><!--[--><!--]--> 知识点索引 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/job-description/ASK_RECORD_BOOK_AI.md" class="" aria-label="书面版"><!--[--><!--]--> 书面版 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="主页"><span class="title">主页</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="主页"><span class="title">主页</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://www.acongm.com" rel="noopener noreferrer" target="_blank" aria-label="Blog"><!--[--><!--]--> Blog <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://github.com/Acongm" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/vuepress/job-description/web前端开发工程师-彭聪.md" class="" aria-label="简历"><!--[--><!--]--> 简历 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><!--]--></nav><!--[--><!--]--><!----><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="基础语言"><span class="title">基础语言</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="基础语言"><span class="title">基础语言</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>JavaScript</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/JavaScript/" class="" aria-label="js 基础知识"><!--[--><!--]--> js 基础知识 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/JavaScript/%E7%BB%8F%E5%85%B8%E9%97%AD%E5%8C%85%E5%A4%84%E7%90%86.html" class="" aria-label="经典闭包处理"><!--[--><!--]--> 经典闭包处理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/JavaScript/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-%E9%97%AD%E5%8C%85.html" class="" aria-label="执行上下文-作用域链-闭包"><!--[--><!--]--> 执行上下文-作用域链-闭包 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/JavaScript/call%E3%80%81apply%E4%B8%8Ebind.html" class="" aria-label="call、apply 与 bind"><!--[--><!--]--> call、apply 与 bind <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/JavaScript/js%E6%A8%A1%E6%8B%9Fbind%E6%96%B9%E6%B3%95.html" class="" aria-label="js 模拟 bind 方法"><!--[--><!--]--> js 模拟 bind 方法 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/JavaScript/js%E6%A8%A1%E6%8B%9Fnew%E6%93%8D%E4%BD%9C.html" class="" aria-label="能否模拟实现 JS 的 new 操作符"><!--[--><!--]--> 能否模拟实现 JS 的 new 操作符 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>TypeScript</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/TypeScript/" class="" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/TypeScript/Study.html" class="" aria-label="每天学一点 TS"><!--[--><!--]--> 每天学一点 TS <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>CSS</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/css/" class="" aria-label="CSS 语法相关"><!--[--><!--]--> CSS 语法相关 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/css/skill.html" class="" aria-label="CSS 奇淫技巧"><!--[--><!--]--> CSS 奇淫技巧 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/css/scss.html" class="" aria-label="常用 SCSS 宏"><!--[--><!--]--> 常用 SCSS 宏 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="框架生态"><span class="title">框架生态</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="框架生态"><span class="title">框架生态</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>React</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/react/class-hooks.html" class="" aria-label="react"><!--[--><!--]--> react <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/react/react16.html" class="" aria-label="十五分钟读懂 React 16"><!--[--><!--]--> 十五分钟读懂 React 16 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/react/react17.html" class="" aria-label="十五分钟读懂 React 17"><!--[--><!--]--> 十五分钟读懂 React 17 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/react/react18.html" class="" aria-label="React 18 新特性"><!--[--><!--]--> React 18 新特性 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/react/react-render.html" class="" aria-label="React 的渲染流程"><!--[--><!--]--> React 的渲染流程 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Vue</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/vue_theory.html" class="" aria-label="vue 原理"><!--[--><!--]--> vue 原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/vue_interview.html" class="" aria-label="vue 面试题"><!--[--><!--]--> vue 面试题 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/vue3.html" class="" aria-label="vue3 原理 - 总结"><!--[--><!--]--> vue3 原理 - 总结 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/code/Object.defineproperty.html" class="" aria-label="Object.defineproperty 核心代码 自定义实现"><!--[--><!--]--> Object.defineproperty 核心代码 自定义实现 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/code/Proxy.html" class="" aria-label="Proxy 核心代码 自定义实现"><!--[--><!--]--> Proxy 核心代码 自定义实现 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/code/proxy-observe.html" class="" aria-label="proxy-observe 核心代码 自定义实现"><!--[--><!--]--> proxy-observe 核心代码 自定义实现 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/vue-render.html" class="" aria-label="Vue 的渲染流程"><!--[--><!--]--> Vue 的渲染流程 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/vue/vue2.html" class="" aria-label="vue 原理"><!--[--><!--]--> vue 原理 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>设计模式</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/Pattern/%E6%A8%A1%E5%BC%8F%E6%9D%A5%E6%BA%90%E4%B8%8E%E7%B1%BB%E6%AF%94.html" class="" aria-label="这些跨组件通信模式，你可能在哪见过？（来源与类比）"><!--[--><!--]--> 这些跨组件通信模式，你可能在哪见过？（来源与类比） <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/Pattern/" class="" aria-label="跨组件通信模式合集"><!--[--><!--]--> 跨组件通信模式合集 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工程化"><span class="title">工程化</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工程化"><span class="title">工程化</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>构建工具</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86.html" class="" aria-label="Webpack - 介绍"><!--[--><!--]--> Webpack - 介绍 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86.html" class="" aria-label="Webpack - 架构及原理"><!--[--><!--]--> Webpack - 架构及原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/vite-%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86.html" class="" aria-label="vite - 知识梳理"><!--[--><!--]--> vite - 知识梳理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/vite-%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86.html" class="" aria-label="vite - 架构及原理"><!--[--><!--]--> vite - 架构及原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/webpack-vite-rollup.html" class="" aria-label="Webpack、Vite、Rollup"><!--[--><!--]--> Webpack、Vite、Rollup <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/install/ni.html" class="" aria-label="install"><!--[--><!--]--> install <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/install/npm.html" class="" aria-label="npm"><!--[--><!--]--> npm <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/install/pnpm.html" class="" aria-label="/webpack/install/pnpm.md"><!--[--><!--]--> /webpack/install/pnpm.md <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/install/yarn.html" class="" aria-label="install"><!--[--><!--]--> install <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/webpack/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7.html" class="" aria-label="install"><!--[--><!--]--> install <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Node.js</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/node/npm.html" class="" aria-label="npm 相关"><!--[--><!--]--> npm 相关 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/node/toolkit.html" class="" aria-label="常用工具包"><!--[--><!--]--> 常用工具包 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Git</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/git/" class="" aria-label="Git"><!--[--><!--]--> Git <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/git/command.html" class="" aria-label="Git 命令清单"><!--[--><!--]--> Git 命令清单 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/git/commit.html" class="" aria-label="Git commit 规范"><!--[--><!--]--> Git commit 规范 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>性能优化</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/performance/" class="" aria-label="用户中心前端性能优化实战文档"><!--[--><!--]--> 用户中心前端性能优化实战文档 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="进阶专题"><span class="title">进阶专题</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="进阶专题"><span class="title">进阶专题</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>技能提炼</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/" class="router-link-active" aria-label="自我面试"><!--[--><!--]--> 自我面试 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html" class="router-link-active router-link-exact-active router-link-active" aria-label="React 16+ 各版本区别 &amp; React 核心原理"><!--[--><!--]--> React 16+ 各版本区别 &amp; React 核心原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E8%A1%A5%E5%85%85.html" class="" aria-label="React 19 新特性详解 &amp; useMemo/useCallback 深度解析"><!--[--><!--]--> React 19 新特性详解 &amp; useMemo/useCallback 深度解析 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/02-Webpack%E4%B8%8E%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html" class="" aria-label="Webpack 架构 &amp; 与 Rollup、Vite 对比 &amp; 核心原理"><!--[--><!--]--> Webpack 架构 &amp; 与 Rollup、Vite 对比 &amp; 核心原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/03-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" class="" aria-label="性能优化流程 &amp; 从浏览器请求链路解释&quot;为什么这么优化&quot;"><!--[--><!--]--> 性能优化流程 &amp; 从浏览器请求链路解释&quot;为什么这么优化&quot; <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/04-%E5%BE%AE%E5%89%8D%E7%AB%AF.html" class="" aria-label="微前端对比 &amp; 各方案实现原理"><!--[--><!--]--> 微前端对比 &amp; 各方案实现原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/05-%E4%BD%8E%E4%BB%A3%E7%A0%81.html" class="" aria-label="低代码 &amp; 核心原理"><!--[--><!--]--> 低代码 &amp; 核心原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/06-%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F.html" class="" aria-label="热插拔插件系统对比 &amp; 各方案实现原理差异"><!--[--><!--]--> 热插拔插件系统对比 &amp; 各方案实现原理差异 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/07-NestJS%E4%B8%8ESSR.html" class="" aria-label="从 NestJS 全栈开发到 SSR &amp; SSR 核心原理"><!--[--><!--]--> 从 NestJS 全栈开发到 SSR &amp; SSR 核心原理 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/08-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.html" class="" aria-label="代码规范 &amp; Umi/ESLint 规范为什么这样设计 &amp; 如何落地"><!--[--><!--]--> 代码规范 &amp; Umi/ESLint 规范为什么这样设计 &amp; 如何落地 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/09-Promise%E5%8E%9F%E7%90%86.html" class="" aria-label="JS 为什么会设计 Promise &amp; 如何手写实现一个 Promise"><!--[--><!--]--> JS 为什么会设计 Promise &amp; 如何手写实现一个 Promise <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/10-%E9%AA%A8%E6%9E%B6%E5%B1%8F.html" class="" aria-label="骨架屏怎么提升性能的？骨架屏的原理及实现"><!--[--><!--]--> 骨架屏怎么提升性能的？骨架屏的原理及实现 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/11-HTTP%E4%B8%8E%E7%BC%93%E5%AD%98.html" class="" aria-label="从性能优化到 HTTP 变化及缓存"><!--[--><!--]--> 从性能优化到 HTTP 变化及缓存 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/mark/React%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3.html" class="" aria-label="React 更新流程详解"><!--[--><!--]--> React 更新流程详解 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>AI 开发</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/ai/" class="" aria-label="AI 相关"><!--[--><!--]--> AI 相关 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>踩坑记录</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/issue/h5.html" class="" aria-label="H5 相关"><!--[--><!--]--> H5 相关 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/issue/pc.html" class="" aria-label="PC 相关"><!--[--><!--]--> PC 相关 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工具箱"><span class="title">工具箱</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工具箱"><span class="title">工具箱</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>工具函数</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/utils/regexp.html" class="" aria-label="常用正则"><!--[--><!--]--> 常用正则 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/utils/function.html" class="" aria-label="常用方法"><!--[--><!--]--> 常用方法 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/utils/library.html" class="" aria-label="库收集"><!--[--><!--]--> 库收集 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>在线工具</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/online-tools/" class="" aria-label="网页工具"><!--[--><!--]--> 网页工具 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/online-tools/bookmark-scripts.html" class="" aria-label="书签脚本"><!--[--><!--]--> 书签脚本 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>软件推荐</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/software/cross-platform.html" class="" aria-label="多平台"><!--[--><!--]--> 多平台 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/mac.html" class="" aria-label="Mac 平台"><!--[--><!--]--> Mac 平台 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/windows.html" class="" aria-label="Windows 平台"><!--[--><!--]--> Windows 平台 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/browser.html" class="" aria-label="浏览器扩展"><!--[--><!--]--> 浏览器扩展 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/vscode.html" class="" aria-label="Visual Studio Code 扩展"><!--[--><!--]--> Visual Studio Code 扩展 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/webstorm.html" class="" aria-label="WebStorm 配置"><!--[--><!--]--> WebStorm 配置 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/zsh.html" class="" aria-label="zsh"><!--[--><!--]--> zsh <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/software/claude-skills-guide.html" class="" aria-label="Claude Skills 基础原理与编写指南"><!--[--><!--]--> Claude Skills 基础原理与编写指南 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="面试"><span class="title">面试</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="面试"><span class="title">面试</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>面试准备</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/interview-prep/" class="" aria-label="知识列表"><!--[--><!--]--> 知识列表 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/theory/" class="" aria-label="面试题库"><!--[--><!--]--> 面试题库 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/interview/2025-04-28.md" class="" aria-label="面试记录"><!--[--><!--]--> 面试记录 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>简历问答</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress/job-description/ASK_LIST.md" class="" aria-label="问答大纲"><!--[--><!--]--> 问答大纲 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/job-description/ASK_RECORD_SPEAK_AI.md" class="" aria-label="口语版"><!--[--><!--]--> 口语版 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/job-description/ASK_CODE_EXAMPLES.md" class="" aria-label="代码版"><!--[--><!--]--> 代码版 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/job-description/ASK_RECORD_KEY.md" class="" aria-label="知识点索引"><!--[--><!--]--> 知识点索引 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress/job-description/ASK_RECORD_BOOK_AI.md" class="" aria-label="书面版"><!--[--><!--]--> 书面版 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="主页"><span class="title">主页</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="主页"><span class="title">主页</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://www.acongm.com" rel="noopener noreferrer" target="_blank" aria-label="Blog"><!--[--><!--]--> Blog <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://github.com/Acongm" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/vuepress/job-description/web前端开发工程师-彭聪.md" class="" aria-label="简历"><!--[--><!--]--> 简历 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p class="sidebar-item sidebar-heading active">技能提炼 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/vuepress/mark/" class="router-link-active sidebar-item" aria-label="自我面试"><!--[--><!--]--> 自我面试 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="React 16+ 各版本区别 &amp; React 核心原理"><!--[--><!--]--> React 16+ 各版本区别 &amp; React 核心原理 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html#笔试题-6-题" class="router-link-active router-link-exact-active sidebar-item" aria-label="笔试题（6 题）"><!--[--><!--]--> 笔试题（6 题） <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html#_1-react-16-17-18-版本核心特性对比" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. React 16/17/18 版本核心特性对比"><!--[--><!--]--> 1. React 16/17/18 版本核心特性对比 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html#_2-fiber-架构详解" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. Fiber 架构详解"><!--[--><!--]--> 2. Fiber 架构详解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html#_3-react-更新流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. React 更新流程"><!--[--><!--]--> 3. React 更新流程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html#_4-协调-reconciliation-与-key" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. 协调（Reconciliation）与 Key"><!--[--><!--]--> 4. 协调（Reconciliation）与 Key <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html#_5-并发-concurrent-vs-并行-parallel" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. 并发（Concurrent）vs 并行（Parallel）"><!--[--><!--]--> 5. 并发（Concurrent）vs 并行（Parallel） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html#_6-react-18-automatic-batching" class="router-link-active router-link-exact-active sidebar-item" aria-label="6. React 18 Automatic Batching"><!--[--><!--]--> 6. React 18 Automatic Batching <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html#面试题-4-题" class="router-link-active router-link-exact-active sidebar-item" aria-label="面试题（4 题）"><!--[--><!--]--> 面试题（4 题） <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html#_1-fiber-架构的可中断性" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. Fiber 架构的可中断性"><!--[--><!--]--> 1. Fiber 架构的可中断性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html#_2-render-阶段-vs-commit-阶段" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. Render 阶段 vs Commit 阶段"><!--[--><!--]--> 2. Render 阶段 vs Commit 阶段 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><li><a href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E8%A1%A5%E5%85%85.html" class="sidebar-item" aria-label="React 19 新特性详解 &amp; useMemo/useCallback 深度解析"><!--[--><!--]--> React 19 新特性详解 &amp; useMemo/useCallback 深度解析 <!--[--><!--]--></a><!----></li><li><a href="/vuepress/mark/02-Webpack%E4%B8%8E%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html" class="sidebar-item" aria-label="Webpack 架构 &amp; 与 Rollup、Vite 对比 &amp; 核心原理"><!--[--><!--]--> Webpack 架构 &amp; 与 Rollup、Vite 对比 &amp; 核心原理 <!--[--><!--]--></a><!----></li><li><a href="/vuepress/mark/03-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" class="sidebar-item" aria-label="性能优化流程 &amp; 从浏览器请求链路解释&quot;为什么这么优化&quot;"><!--[--><!--]--> 性能优化流程 &amp; 从浏览器请求链路解释&quot;为什么这么优化&quot; <!--[--><!--]--></a><!----></li><li><a href="/vuepress/mark/04-%E5%BE%AE%E5%89%8D%E7%AB%AF.html" class="sidebar-item" aria-label="微前端对比 &amp; 各方案实现原理"><!--[--><!--]--> 微前端对比 &amp; 各方案实现原理 <!--[--><!--]--></a><!----></li><li><a href="/vuepress/mark/05-%E4%BD%8E%E4%BB%A3%E7%A0%81.html" class="sidebar-item" aria-label="低代码 &amp; 核心原理"><!--[--><!--]--> 低代码 &amp; 核心原理 <!--[--><!--]--></a><!----></li><li><a href="/vuepress/mark/06-%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F.html" class="sidebar-item" aria-label="热插拔插件系统对比 &amp; 各方案实现原理差异"><!--[--><!--]--> 热插拔插件系统对比 &amp; 各方案实现原理差异 <!--[--><!--]--></a><!----></li><li><a href="/vuepress/mark/07-NestJS%E4%B8%8ESSR.html" class="sidebar-item" aria-label="从 NestJS 全栈开发到 SSR &amp; SSR 核心原理"><!--[--><!--]--> 从 NestJS 全栈开发到 SSR &amp; SSR 核心原理 <!--[--><!--]--></a><!----></li><li><a href="/vuepress/mark/08-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.html" class="sidebar-item" aria-label="代码规范 &amp; Umi/ESLint 规范为什么这样设计 &amp; 如何落地"><!--[--><!--]--> 代码规范 &amp; Umi/ESLint 规范为什么这样设计 &amp; 如何落地 <!--[--><!--]--></a><!----></li><li><a href="/vuepress/mark/09-Promise%E5%8E%9F%E7%90%86.html" class="sidebar-item" aria-label="JS 为什么会设计 Promise &amp; 如何手写实现一个 Promise"><!--[--><!--]--> JS 为什么会设计 Promise &amp; 如何手写实现一个 Promise <!--[--><!--]--></a><!----></li><li><a href="/vuepress/mark/10-%E9%AA%A8%E6%9E%B6%E5%B1%8F.html" class="sidebar-item" aria-label="骨架屏怎么提升性能的？骨架屏的原理及实现"><!--[--><!--]--> 骨架屏怎么提升性能的？骨架屏的原理及实现 <!--[--><!--]--></a><!----></li><li><a href="/vuepress/mark/11-HTTP%E4%B8%8E%E7%BC%93%E5%AD%98.html" class="sidebar-item" aria-label="从性能优化到 HTTP 变化及缓存"><!--[--><!--]--> 从性能优化到 HTTP 变化及缓存 <!--[--><!--]--></a><!----></li><li><a href="/vuepress/mark/React%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3.html" class="sidebar-item" aria-label="React 更新流程详解"><!--[--><!--]--> React 更新流程详解 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="react-16-各版本区别-react-核心原理" tabindex="-1"><a class="header-anchor" href="#react-16-各版本区别-react-核心原理" aria-hidden="true">#</a> React 16+ 各版本区别 &amp; React 核心原理</h1><h2 id="笔试题-6-题" tabindex="-1"><a class="header-anchor" href="#笔试题-6-题" aria-hidden="true">#</a> 笔试题（6 题）</h2><h3 id="_1-react-16-17-18-版本核心特性对比" tabindex="-1"><a class="header-anchor" href="#_1-react-16-17-18-版本核心特性对比" aria-hidden="true">#</a> 1. React 16/17/18 版本核心特性对比</h3><p>请写出 React 16、17、18 三个版本在&quot;渲染/更新&quot;层面的关键变化点，每个版本至少 3 条。</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>React 16:
1. Fiber 架构 - 重写了核心调和算法，支持可中断的渲染
2. 异步渲染基础 - 引入 time slicing，为后续并发特性铺路
3. Error Boundaries - 新增错误边界机制，componentDidCatch
4. Fragments - 支持返回数组和 Fragment，无需额外 DOM 包裹
5. Portals - 支持渲染到父组件 DOM 层级之外

React 17:
1. 无新特性版本 - 主要是过渡版本，为 18 做准备
2. 事件委托改变 - 从 document 改为 root 容器，支持多版本共存
3. 去除事件池 - 简化事件处理，提升性能
4. 新的 JSX 转换 - 不再需要 import React，编译优化
5. useEffect 清理时机 - 改为异步执行，提升性能

React 18:
1. 并发渲染（Concurrent Rendering）- 支持渲染可中断和优先级调度
2. Automatic Batching - 自动批处理扩展到所有场景（setTimeout、Promise、原生事件）
3. Transitions API - startTransition 区分紧急和非紧急更新
4. Suspense SSR - 支持流式 SSR 和选择性 Hydration
5. useId/useTransition/useDeferredValue - 新增并发特性相关 Hooks
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><hr><h3 id="_2-fiber-架构详解" tabindex="-1"><a class="header-anchor" href="#_2-fiber-架构详解" aria-hidden="true">#</a> 2. Fiber 架构详解</h3><p>解释 Fiber 是什么：它解决了什么问题？核心数据结构包含哪些关键字段？Fiber 节点之间如何建立关联？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Fiber 解决的问题：
1. React 15 及之前采用递归的 Stack Reconciler，一旦开始无法中断
2. 大组件树更新会长时间占用主线程，导致页面卡顿、掉帧
3. 无法区分任务优先级，用户交互得不到及时响应
4. Fiber 通过时间切片（Time Slicing）实现可中断、可恢复的渲染
5. 支持任务优先级调度，高优先级任务可以打断低优先级任务

Fiber 核心数据结构字段：
// 实例相关
type: 组件类型（函数组件/类组件/原生标签）
stateNode: 对应的真实 DOM 节点或组件实例
key/ref: React 元素的 key 和 ref

// 树结构
return: 父 Fiber 节点
child: 第一个子 Fiber 节点
sibling: 下一个兄弟 Fiber 节点

// 状态和副作用
pendingProps: 新的 props
memoizedProps: 上次渲染的 props
memoizedState: 上次渲染的 state
updateQueue: 更新队列
flags (effectTag): 副作用标记（Placement/Update/Deletion）

// 调度相关
lanes: 优先级车道模型
alternate: 指向 workInProgress/current 树的对应节点（双缓冲）

Fiber 节点关联方式：
1. 单链表结构：child（第一个子节点）+ sibling（兄弟节点）+ return（父节点）
2. 双缓冲机制：current 树和 workInProgress 树通过 alternate 互相指向
3. 深度优先遍历：先 child，无 child 找 sibling，无 sibling 回到 return
4. 这种结构支持中断后从断点继续，只需保存当前 Fiber 引用即可
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><hr><h3 id="_3-react-更新流程" tabindex="-1"><a class="header-anchor" href="#_3-react-更新流程" aria-hidden="true">#</a> 3. React 更新流程</h3><p>React 中一次 setState/状态更新，从触发到 DOM 更新完成，大致经历哪些阶段？每个阶段的主要工作是什么？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>阶段1：调度阶段（Schedule）
- 触发更新：setState/useState/useReducer/forceUpdate
- 创建 Update 对象，加入 updateQueue
- 根据优先级（lanes）决定是否立即调度
- 通过 Scheduler 调度，将任务加入任务队列
- 主要工作：优先级计算、任务调度、时间切片

阶段2：协调阶段（Render/Reconciliation）- 可中断
- beginWork：从根节点开始，深度优先遍历 Fiber 树
- 对比新旧 props/state，标记需要更新的节点
- 调用组件函数/render 方法，生成新的 ReactElement
- diff 算法：复用 Fiber 节点，标记 effectTag（Placement/Update/Deletion）
- completeWork：完成节点处理，创建/更新 DOM 属性
- 构建 effectList 链表（待提交的副作用列表）
- 主要工作：Diff 计算、Fiber 树构建、副作用收集

阶段3：提交阶段（Commit）- 不可中断，同步执行
- before mutation：执行 getSnapshotBeforeUpdate
- mutation：根据 effectList 执行真实 DOM 操作（增删改）
- layout：执行 useLayoutEffect/componentDidMount/componentDidUpdate
- 切换 current 指针，从 workInProgress 树变为新的 current 树
- 主要工作：DOM 变更、生命周期执行、ref 更新

阶段4：副作用执行（Effect）- 异步
- 在浏览器完成绘制后异步执行 useEffect
- 先执行上一次的清理函数（cleanup）
- 再执行本次的副作用函数
- 不阻塞浏览器渲染，提升用户体验
- 主要工作：异步副作用执行、订阅清理
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><hr><h3 id="_4-协调-reconciliation-与-key" tabindex="-1"><a class="header-anchor" href="#_4-协调-reconciliation-与-key" aria-hidden="true">#</a> 4. 协调（Reconciliation）与 Key</h3><p>什么是协调（reconciliation）？key 的作用是什么？错误使用 key（如使用 index）会导致什么问题？请举例说明。</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>协调的定义：
协调（Reconciliation）是 React 中用于比较新旧虚拟 DOM 树，计算出最小变更集的算法过程。
React 通过 Diff 算法找出两棵树之间的差异，决定哪些节点需要新增、更新或删除。
协调是 Render 阶段的核心工作，目标是高效复用现有节点，最小化 DOM 操作。
React 的协调算法复杂度从 O(n³) 优化到 O(n)，基于三个假设：
1. 不同类型的元素会产生不同的树
2. 通过 key 属性标识哪些元素在不同渲染中保持稳定
3. 同层级节点对比，不跨层级移动

key 的作用：
1. 唯一标识：帮助 React 识别列表中哪些元素改变、添加或删除
2. 性能优化：相同 key 的元素会被复用，避免不必要的销毁和重建
3. 状态保持：有 key 的组件在列表重新排序时能保持自己的状态
4. Diff 优化：React 通过 key 快速判断节点是移动还是新增/删除
5. 避免渲染错误：防止组件实例混淆导致的状态错乱

错误使用 key 的问题及示例：
❌ 使用 index 作为 key 的问题：
// 错误示例
items.map((item, index) =&gt; &lt;TodoItem key={index} {...item} /&gt;)

问题场景：
1. 列表重新排序时，index 变化导致组件实例错位
2. 删除中间项时，后面所有项的 index 改变，触发不必要的重渲染
3. 有内部状态的组件会出现状态错乱

具体案例：
初始：[{id: &#39;a&#39;, text: &#39;任务A&#39;}, {id: &#39;b&#39;, text: &#39;任务B&#39;}]
删除第一项后：[{id: &#39;b&#39;, text: &#39;任务B&#39;}]

使用 index 作为 key：
- 删除前：key=0 对应 &#39;任务A&#39;，key=1 对应 &#39;任务B&#39;
- 删除后：key=0 对应 &#39;任务B&#39;
- React 认为 key=0 的组件被更新（而非删除），key=1 的组件被删除
- 如果组件有内部状态（如输入框内容），会导致状态绑定错误

✅ 正确做法：
items.map(item =&gt; &lt;TodoItem key={item.id} {...item} /&gt;)
使用稳定的唯一标识（如数据库 ID、UUID）作为 key
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><hr><h3 id="_5-并发-concurrent-vs-并行-parallel" tabindex="-1"><a class="header-anchor" href="#_5-并发-concurrent-vs-并行-parallel" aria-hidden="true">#</a> 5. 并发（Concurrent）vs 并行（Parallel）</h3><p>React 18 的并发（Concurrent）与传统意义的&quot;并行&quot;有什么本质区别？React 如何实现并发渲染？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>并发 vs 并行的区别：
【并行（Parallel）】
- 定义：多个任务在同一时刻真正同时执行
- 要求：需要多核 CPU，真正的多线程
- 特点：同一时间有多个任务在进行
- 例子：多个 CPU 核心同时计算不同的数据

【并发（Concurrent）】
- 定义：多个任务在同一时间段内交替执行，看起来像同时进行
- 要求：单核也可以实现，通过时间切片
- 特点：快速切换任务，每个任务执行一小段时间
- 例子：单核 CPU 通过时间片轮转执行多个程序

React 18 的并发是：
- 在单线程（JavaScript 主线程）中实现
- 通过时间切片将长任务拆分成多个小任务
- 在多个小任务之间切换，让高优先级任务插队
- 本质是任务调度，而非真正的并行计算

类比：
- 并行 = 多个厨师同时做不同的菜（多核心）
- 并发 = 一个厨师快速切换做多道菜（单核心）

React 如何实现并发渲染：
1. Fiber 架构基础
   - 将渲染工作拆分为多个 Fiber 节点的小单元
   - 每个单元执行时间短，可以暂停和恢复
   - 通过链表结构保存断点信息

2. 时间切片（Time Slicing）
   - 每个时间片默认 5ms（React 内部可配置）
   - 执行一部分工作后，检查是否超时
   - 超时则让出主线程，通过 Scheduler 调度下一帧继续
   - 利用 MessageChannel/setTimeout 实现异步调度

3. 优先级调度（Priority Scheduling）
   - Lane 模型：31 条车道表示不同优先级
   - 紧急更新（用户输入）&gt; 普通更新（状态变化）&gt; 低优先级更新（数据预加载）
   - 高优先级任务可以打断低优先级任务
   - 饥饿问题处理：低优先级任务过期后提升优先级

4. 双缓冲机制
   - current 树（当前屏幕显示）
   - workInProgress 树（后台构建）
   - 渲染可中断，但提交是原子性的，一次性切换

5. startTransition API
   - 标记非紧急更新，允许被打断
   - 保持 UI 响应性，同时处理大量数据更新

实现关键：
- Scheduler 负责任务调度和时间切片
- Reconciler（Fiber）负责可中断的协调
- 两者配合实现并发渲染
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><hr><h3 id="_6-react-18-automatic-batching" tabindex="-1"><a class="header-anchor" href="#_6-react-18-automatic-batching" aria-hidden="true">#</a> 6. React 18 Automatic Batching</h3><p>React 18 的 automatic batching 覆盖哪些场景？举例说明与 React 17 的差异，并解释为什么能实现这种改进。</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>React 18 automatic batching 覆盖场景：
React 18 扩展了批处理的覆盖范围，包括：
1. ✅ 事件处理函数（React 17 也支持）
2. ✅ setTimeout/setInterval 回调（新增）
3. ✅ Promise.then 回调（新增）
4. ✅ 原生事件监听器（新增）
5. ✅ async/await 异步函数（新增）
6. ✅ fetch 请求回调（新增）

总结：React 18 在所有场景下都自动批处理，无论更新来源

与 React 17 的差异示例：
// React 17 的行为
function handleClick() {
  setCount(c =&gt; c + 1);  // 触发一次渲染
  setFlag(f =&gt; !f);      // 触发一次渲染
  // ✅ React 事件中会批处理 → 只渲染 1 次
}

function handleClick17() {
  setTimeout(() =&gt; {
    setCount(c =&gt; c + 1);  // 触发一次渲染 ❌
    setFlag(f =&gt; !f);      // 触发一次渲染 ❌
    // ❌ 异步回调中不批处理 → 渲染 2 次
  }, 0);
}

fetch(&#39;/api&#39;).then(() =&gt; {
  setCount(c =&gt; c + 1);  // 触发一次渲染 ❌
  setFlag(f =&gt; !f);      // 触发一次渲染 ❌
  // ❌ Promise 中不批处理 → 渲染 2 次
});

// React 18 的行为
function handleClick18() {
  setTimeout(() =&gt; {
    setCount(c =&gt; c + 1);
    setFlag(f =&gt; !f);
    // ✅ 自动批处理 → 只渲染 1 次
  }, 0);
}

fetch(&#39;/api&#39;).then(() =&gt; {
  setCount(c =&gt; c + 1);
  setFlag(f =&gt; !f);
  // ✅ 自动批处理 → 只渲染 1 次
});

// 如果需要强制同步更新（退出批处理）
import { flushSync } from &#39;react-dom&#39;;

flushSync(() =&gt; {
  setCount(c =&gt; c + 1);  // 立即渲染
});
setFlag(f =&gt; !f);  // 再次渲染

实现原理：
1. React 17 的限制
   - 批处理依赖于 React 的事件系统
   - 通过 isBatchingUpdates 标志控制
   - 只在 React 合成事件处理函数执行期间启用
   - 异步回调时 React 上下文已丢失，无法批处理

2. React 18 的改进
   - 引入 createRoot API，启用并发特性
   - 所有更新默认进入更新队列
   - 通过微任务（microtask）延迟提交
   - 在同一事件循环中的所有更新自动合并

3. 技术实现
   - 利用 JavaScript 事件循环机制
   - 将多个 setState 放入更新队列
   - 在微任务中统一处理，合并为一次渲染
   - 无需区分更新来源，统一处理

4. 性能提升
   - 减少渲染次数，提升性能
   - 避免中间状态展示，防止闪烁
   - 降低浏览器重绘重排次数

5. 向后兼容
   - 使用 ReactDOM.createRoot 才启用
   - 旧的 ReactDOM.render 保持 React 17 行为
   - 提供 flushSync 作为逃生舱
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br></div></div><hr><h2 id="面试题-4-题" tabindex="-1"><a class="header-anchor" href="#面试题-4-题" aria-hidden="true">#</a> 面试题（4 题）</h2><h3 id="_1-fiber-架构的可中断性" tabindex="-1"><a class="header-anchor" href="#_1-fiber-架构的可中断性" aria-hidden="true">#</a> 1. Fiber 架构的可中断性</h3><p>讲清楚&quot;Fiber 架构&quot;为什么能中断/恢复渲染？底层依赖哪些机制？你会如何用类比的方式解释给技术新人听？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>为什么 Fiber 能中断/恢复渲染：

1. 数据结构支持
   - Fiber 是链表结构，每个节点独立
   - 包含 child/sibling/return 指针，可以从任意节点继续遍历
   - 保存了当前工作状态（pendingProps、memoizedState、updateQueue）
   - 中断时只需保存当前 Fiber 节点引用，恢复时从该节点继续

2. 工作单元拆分
   - 将整棵树的渲染拆分为一个个小的工作单元（每个 Fiber 节点）
   - 每完成一个工作单元就检查时间片是否用完
   - 用完则保存进度，将控制权交还浏览器
   - 下一帧再从断点继续

3. 双缓冲机制
   - current 树：当前屏幕显示的内容
   - workInProgress 树：正在后台构建的新树
   - 渲染过程可以多次中断，但只在完全构建好后才一次性提交
   - 保证用户始终看到完整的 UI，不会看到半成品

底层依赖的机制：

1. Scheduler（调度器）
   - 负责任务调度和时间切片管理
   - 使用 MessageChannel 或 setTimeout 实现异步调度
   - 维护任务队列，按优先级排序
   - 提供 shouldYield() 方法判断是否需要让出主线程

2. 时间切片（Time Slicing）
   - 每个时间片约 5ms（一帧 16.6ms 的 1/3）
   - 工作循环：while (workInProgress &amp;&amp; !shouldYield()) { performUnitOfWork() }
   - 超时后通过 requestIdleCallback 概念在下一帧继续

3. 优先级调度（Lane Model）
   - 31 条车道（lane）表示不同优先级
   - 高优先级任务可以打断低优先级任务
   - 被打断的任务等待高优任务完成后重新开始

4. 工作循环（Work Loop）
   - performUnitOfWork：处理单个 Fiber 节点
   - beginWork：向下遍历，diff 和创建子 Fiber
   - completeWork：向上回溯，收集副作用
   - 每个单元执行时间可控，便于中断

类比解释给新人听：

【类比1：盖楼房】
- React 15（递归）= 一口气盖完楼，中途不能停
  &quot;包工头说必须连续干，直到楼封顶，期间不能处理其他事&quot;
  问题：盖 50 层楼时，紧急电话都没法接

- Fiber（可中断）= 盖完一层就检查一下
  &quot;每盖完一层就问：有没有紧急事？没有就继续盖下一层&quot;
  优势：随时可以暂停去处理紧急事，之后再回来继续盖

【类比2：餐厅厨师】
- React 15 = 一道菜必须做完才能做下一道
  炒菜必须从开火到装盘一气呵成，期间不能切换

- Fiber = 可以在多道菜之间切换
  &quot;炒菜A 30秒 → 紧急订单来了 → 先做紧急菜 → 回来继续炒菜A&quot;
  如何做到：用小火保温（保存状态），贴便签记录进度（Fiber 节点）

【类比3：看书 vs 递归算法】
- 递归（Stack）= 没有书签的书
  必须一次看完，中途停下就忘了看到哪里

- Fiber = 有书签的书
  每一页都是一个 Fiber 节点
  随时可以插书签（保存当前节点）
  下次打开从书签继续看
  甚至可以先看后面的重要章节（高优先级），再回来看前面

【关键点总结】
Fiber 就像给 React 加了&quot;书签&quot;和&quot;暂停键&quot;：
1. 书签 = Fiber 节点的链表结构，记录位置
2. 暂停键 = 时间切片，定期检查是否需要暂停
3. 任务管理器 = Scheduler，决定先做什么后做什么
4. 草稿本 = workInProgress 树，可以反复修改，不影响正式版
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br></div></div><hr><h3 id="_2-render-阶段-vs-commit-阶段" tabindex="-1"><a class="header-anchor" href="#_2-render-阶段-vs-commit-阶段" aria-hidden="true">#</a> 2. Render 阶段 vs Commit 阶段</h3><p>React 为什么要把 render 和 commit 分开？commit 阶段为什么不能被打断？如果 commit 阶段也能中断会有什么问题？</p><p><strong>【作答】：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>为什么要把 Render 和 Commit 分开：

1. 职责分离
   - Render 阶段：计算&quot;要做什么&quot;（纯计算，无副作用）
     → 对比新旧虚拟 DOM，标记需要变更的节点
     → 可以被打断、重新开始，不影响用户界面

   - Commit 阶段：执行&quot;真正的变更&quot;（副作用，修改 DOM）
     → 根据 Render 阶段的计算结果修改真实 DOM
     → 必须同步完成，保证 UI 一致性

2. 性能优化
   - Render 阶段可以中断，高优先级任务可以插队
   - 被打断的低优先级渲染可以丢弃，重新计算
   - 避免在计算阶段阻塞用户交互

3. 幂等性保证
   - Render 阶段是纯函数，多次执行结果相同
   - 可以安全地中断、重启、重算
   - Commit 阶段有副作用，不能重复执行

4. 架构灵活性
   - Render 阶段可跨平台复用（React Native/RN Web）
   - Commit 阶段针对不同平台有不同实现
   - React-dom、React-native 共享 Reconciler（Render），各自实现 Renderer（Commit）

Commit 阶段为什么不能被打断：

1. DOM 一致性问题
   - DOM 操作是副作用，会直接影响用户看到的界面
   - 如果中断，用户会看到不完整的 UI
   - 例如：插入一半的列表、只改变了一部分样式

2. 生命周期顺序保证
   - componentDidMount/useLayoutEffect 必须在 DOM 更新后立即同步执行
   - 如果中断，生命周期执行顺序会错乱
   - 父组件的 didMount 必须在子组件之后执行

3. ref 引用问题
   - ref 的赋值必须与 DOM 操作同步
   - 中断会导致 ref 指向旧的或不存在的 DOM 节点
   - 用户在生命周期中访问 ref 会出错

4. 视觉一致性
   - 多个 DOM 变更应该在同一帧中完成
   - 浏览器一次性重绘，避免闪烁
   - 中断会导致多次重绘，出现视觉抖动

如果 Commit 阶段也能中断会有什么问题：

【问题1：UI 撕裂】
场景：更新一个列表，插入 5 个新元素
- 中断时机：插入了 3 个就被打断
- 结果：用户看到不完整的列表
- 体验：界面一会多 3 个，一会又多 2 个，闪烁抖动

【问题2：状态不一致】
场景：同时更新文本和样式
```jsx
&lt;div style={{color: isActive ? &#39;red&#39; : &#39;blue&#39;}}&gt;
  {isActive ? &#39;激活&#39; : &#39;未激活&#39;}
&lt;/div&gt;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br></div></div><ul><li>中断时机：只更新了颜色，文本还没更新</li><li>结果：蓝色的&quot;激活&quot;或红色的&quot;未激活&quot;</li><li>问题：短暂的状态不一致，用户困惑</li></ul><p>【问题 3：生命周期混乱】 场景：组件挂载过程被打断</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 此时 DOM 可能还没真正插入</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>divRef<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 报错！</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>中断导致 didMount 执行时 DOM 还未完全更新</li><li>ref 可能指向旧节点或 null</li></ul><p>【问题 4：第三方库兼容性】 场景：使用 echarts 等需要 DOM 的库</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> chart <span class="token operator">=</span> echarts<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>chartRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span> <span class="token comment">// 此时 DOM 可能还没准备好</span>
  chart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>如果 Commit 可中断，第三方库会在不稳定的 DOM 上操作</li><li>导致渲染错误、内存泄漏</li></ul><p>【问题 5：浏览器回流抖动】</p><ul><li>每次部分 DOM 更新都会触发浏览器回流（reflow）</li><li>如果分多次提交，会有多次回流，性能反而更差</li><li>一次性提交所有变更，浏览器可以优化为一次回流</li></ul><p>【对比总结】</p><table><thead><tr><th>阶段</th><th>能否中断</th><th>原因</th><th>副作用</th></tr></thead><tbody><tr><td>Render</td><td>✅ 可以</td><td>纯计算，不影响 UI</td><td>无</td></tr><tr><td>Commit</td><td>❌ 不可以</td><td>DOM 操作，必须原子性</td><td>有</td></tr></tbody></table><p>【类比】</p><ul><li>Render = 建筑师画图纸 → 可以画一半改主意，重新画，用户看不到</li><li>Commit = 工人按图纸施工 → 必须一次性完成，不能墙砌一半就停，否则房子会塌</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>
---

### 3. React 18 并发模式的实践问题
React 18 下你遇到过哪些&quot;并发带来的坑&quot;（比如副作用执行时序、状态不一致）？如何规避这些问题？Strict Mode 的双重调用是为了什么？

**【作答】：**

</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>并发模式带来的常见问题：</p><p>【问题 1：useEffect 重复执行】 现象：</p><ul><li>Strict Mode 下，组件挂载时 useEffect 执行 2 次</li><li>先执行 effect → cleanup → effect</li></ul><p>案例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> subscription <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 订阅了 2 次！</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> subscription<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>影响：</p><ul><li>WebSocket 重复连接</li><li>API 重复请求</li><li>事件监听器重复绑定</li></ul><p>规避方法：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 方法1：正确处理清理函数</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> ignore <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ignore<span class="token punctuation">)</span> <span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment">// 防止过期数据</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    ignore <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span> <span class="token comment">// cleanup 设置标志</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// ✅ 方法2：使用 useRef 防止重复</span>
<span class="token keyword">const</span> subscriptionRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>subscriptionRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    subscriptionRef<span class="token punctuation">.</span>current <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    subscriptionRef<span class="token punctuation">.</span>current<span class="token operator">?.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    subscriptionRef<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>【问题 2：中间状态可见（Tearing）】 现象：</p><ul><li>同一状态在不同组件中看到不同的值</li><li>并发渲染时，状态在渲染过程中被更新</li></ul><p>案例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// 外部 store（非 React 状态）</span>
<span class="token keyword">let</span> externalStore <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">function</span> <span class="token function">ComponentA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> value <span class="token operator">=</span> externalStore <span class="token comment">// 读取时是 0</span>
  <span class="token comment">// ... 耗时渲染 ...</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token comment">// 可能还是 0</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">ComponentB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> value <span class="token operator">=</span> externalStore <span class="token comment">// 读取时已经是 1</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token comment">// 显示 1</span>
<span class="token punctuation">}</span>

<span class="token comment">// 中途 externalStore 变成 1</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  externalStore <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>结果：两个组件显示不同的值（UI 撕裂）</p><p>规避方法：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 使用 useSyncExternalStore（React 18 新增）</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useSyncExternalStore <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span>

<span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useSyncExternalStore</span><span class="token punctuation">(</span>
  store<span class="token punctuation">.</span>subscribe<span class="token punctuation">,</span> <span class="token comment">// 订阅函数</span>
  store<span class="token punctuation">.</span>getSnapshot<span class="token punctuation">,</span> <span class="token comment">// 获取快照</span>
  store<span class="token punctuation">.</span>getServerSnapshot <span class="token comment">// SSR 快照（可选）</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>【问题 3：过时的闭包问题】 现象：</p><ul><li>并发渲染时，渲染可能被放弃重来</li><li>useEffect 中捕获的值可能已过时</li></ul><p>案例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">SearchBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>query<span class="token punctuation">,</span> setQuery<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果渲染被打断重来，这个 query 可能是旧值</span>
      <span class="token function">fetchResults</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>query<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>规避方法：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 使用 useTransition 明确标记</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">handleSearch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setQuery</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// 紧急更新，立即响应输入</span>
  <span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setResults</span><span class="token punctuation">(</span><span class="token function">searchResults</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 非紧急，可以延迟</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// ✅ 使用 useDeferredValue</span>
<span class="token keyword">const</span> deferredQuery <span class="token operator">=</span> <span class="token function">useDeferredValue</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">fetchResults</span><span class="token punctuation">(</span>deferredQuery<span class="token punctuation">)</span> <span class="token comment">// 使用延迟的值</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>deferredQuery<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>【问题 4：状态批处理时序变化】 现象：</p><ul><li>React 18 所有更新都自动批处理</li><li>以前同步的 setState 现在可能是异步的</li></ul><p>案例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// React 17</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 立即渲染</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">// &quot;1&quot;</span>
  <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 再次渲染</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>

<span class="token comment">// React 18</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 不立即渲染</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">// &quot;0&quot;（还没更新）</span>
  <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 批处理，只渲染一次</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>规避方法：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 使用 flushSync 强制同步</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> flushSync <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react-dom&#39;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 立即同步渲染</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">// &quot;1&quot;</span>
  <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 再次渲染</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>【问题 5：Suspense 导致的多次渲染】 现象：</p><ul><li>组件可能被渲染多次后才最终提交</li><li>Render 阶段的代码可能执行多次</li></ul><p>案例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 可能触发多次</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;render&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 会打印多次</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>data<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>规避方法：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ❌ 不要在 render 中执行副作用</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  analytics<span class="token punctuation">.</span><span class="token function">track</span><span class="token punctuation">(</span><span class="token string">&#39;render&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 错误！会重复上报</span>
<span class="token punctuation">}</span>

<span class="token comment">// ✅ 副作用放在 useEffect 中</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    analytics<span class="token punctuation">.</span><span class="token function">track</span><span class="token punctuation">(</span><span class="token string">&#39;mount&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 正确，只在提交后执行一次</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Strict Mode 的双重调用是为了什么：</p><p>【目的】 帮助开发者提前发现并发模式下的问题</p><p>【具体行为（仅开发环境）】</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>第一次：render → effect → cleanup
第二次：render → effect
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>【检测的问题】</p><ol><li><p>✅ 副作用是否正确清理</p><ul><li>如果没有 cleanup，第二次执行可能导致内存泄漏</li></ul></li><li><p>✅ 组件是否是纯函数</p><ul><li>render 执行两次，结果应该相同</li><li>检测 render 中的副作用（不应该有）</li></ul></li><li><p>✅ 并发渲染的兼容性</p><ul><li>模拟组件被卸载后重新挂载的场景</li><li>确保组件能够正确恢复状态</li></ul></li></ol><p>【典型错误示例】</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ❌ 没有清理，会导致重复订阅</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 缺少 return () =&gt; unsubscribe();</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// ❌ 在 render 中修改外部状态</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  externalCounter<span class="token operator">++</span> <span class="token comment">// 错误！执行两次会导致计数错误</span>
<span class="token punctuation">}</span>

<span class="token comment">// ✅ 正确写法</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    externalCounter<span class="token operator">++</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>【最佳实践总结】</p><ol><li>✅ 始终为 useEffect 提供正确的 cleanup 函数</li><li>✅ Render 阶段保持纯净，不执行副作用</li><li>✅ 使用 useSyncExternalStore 处理外部状态</li><li>✅ 使用 useTransition/useDeferredValue 处理非紧急更新</li><li>✅ 需要同步更新时使用 flushSync（谨慎使用）</li><li>✅ 在 Strict Mode 下充分测试</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>
---

### 4. 性能优化决策
你如何判断一个组件该使用 memo/useMemo/useCallback？给出你的原则与反例（过度优化的场景）。如何量化优化效果？

**【作答】：**

</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>判断是否需要优化的原则：</p><p>【何时使用 React.memo】 ✅ 应该使用的场景：</p><ol><li>组件渲染成本高（复杂计算、大列表）</li><li>组件频繁渲染，但 props 很少变化</li><li>组件在列表中重复渲染</li><li>父组件频繁更新，但该子组件不需要同步更新</li></ol><p>示例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 适合：复杂的列表项组件</span>
<span class="token keyword">const</span> ListItem <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> id<span class="token punctuation">,</span> title<span class="token punctuation">,</span> description <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>complex-item<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token comment">/* 复杂的渲染逻辑 */</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// ✅ 适合：纯展示组件</span>
<span class="token keyword">const</span> UserCard <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> user <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token plain-text"> - </span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>email<span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>❌ 不应该使用的场景：</p><ol><li>props 每次都变化（memo 反而增加对比成本）</li><li>组件本身很简单（一个 div + 文本）</li><li>组件很少重新渲染</li><li>props 包含复杂对象且没有稳定引用</li></ol><p>反例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ❌ 过度优化：组件太简单</span>
<span class="token keyword">const</span> Button <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> label <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>label<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
<span class="token comment">// 对比 props 的成本 &gt; 重新渲染的成本</span>

<span class="token comment">// ❌ 过度优化：props 总是变化</span>
<span class="token keyword">const</span> Clock <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> time <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>time<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
<span class="token comment">// time 每秒都变，memo 毫无意义</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>【何时使用 useMemo】 ✅ 应该使用的场景：</p><ol><li>计算成本高（循环、递归、复杂运算）</li><li>依赖项很少变化</li><li>结果被用作其他 Hook 的依赖</li><li>结果传递给使用了 React.memo 的子组件</li></ol><p>示例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 适合：昂贵计算</span>
<span class="token keyword">const</span> expensiveValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> hugeList
    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">complexCondition</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">expensiveTransform</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>hugeList<span class="token punctuation">,</span> condition<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// ✅ 适合：作为依赖项</span>
<span class="token keyword">const</span> memoizedData <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> name <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>id<span class="token punctuation">,</span> name<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">fetchRelatedData</span><span class="token punctuation">(</span>memoizedData<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>memoizedData<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 避免无限循环</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>❌ 不应该使用的场景：</p><ol><li>简单的计算（加减乘除、字符串拼接）</li><li>依赖项频繁变化</li><li>创建简单对象或数组</li></ol><p>反例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ❌ 过度优化：计算太简单</span>
<span class="token keyword">const</span> fullName <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">&#39; &#39;</span> <span class="token operator">+</span> lastName
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 直接计算更快</span>

<span class="token comment">// ❌ 过度优化：依赖项总变</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">timestamp</span><span class="token operator">:</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 每次都变，毫无意义</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>【何时使用 useCallback】 ✅ 应该使用的场景：</p><ol><li>函数传递给使用了 React.memo 的子组件</li><li>函数作为 useEffect/useMemo 的依赖项</li><li>函数包含复杂逻辑且依赖项稳定</li><li>自定义 Hook 返回的函数</li></ol><p>示例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ✅ 适合：传递给 memo 组件</span>
<span class="token keyword">const</span> MemoChild <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> onClick <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Click</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> handleClick <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;clicked&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 稳定引用，避免 MemoChild 重渲染</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MemoChild</span></span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token punctuation">}</span>

<span class="token comment">// ✅ 适合：作为依赖项</span>
<span class="token keyword">const</span> fetchData <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> api<span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
  <span class="token function">setData</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>fetchData<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 避免无限循环</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>❌ 不应该使用的场景：</p><ol><li>子组件没有用 memo</li><li>函数仅在当前组件内部使用</li><li>函数没有被作为依赖项传递</li></ol><p>反例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ❌ 过度优化：子组件没有 memo</span>
<span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> handleClick <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child</span></span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span> <span class="token comment">// Child 没有 memo，无意义</span>
<span class="token punctuation">}</span>

<span class="token comment">// ❌ 过度优化：仅内部使用</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> helper <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">*</span> <span class="token number">2</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token comment">// 仅在此组件内调用，不需要缓存</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>【优化决策流程图】</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>是否有性能问题？
  ↓ 否 → 不要优化
  ↓ 是
用 Profiler 分析慢在哪？
  ↓
组件重渲染过多？
  ↓ 是
  props 经常不变？
    ↓ 是 → 使用 React.memo
    ↓ 否 → 检查是否可以拆分组件
  ↓
有昂贵计算？
  ↓ 是
  依赖项稳定？
    ↓ 是 → 使用 useMemo
    ↓ 否 → 考虑移到组件外或 Web Worker
  ↓
函数引用导致子组件重渲染？
  ↓ 是 → 使用 useCallback
  ↓ 否 → 不需要优化
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>【过度优化的典型反例】</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// ❌ 反例1：全家桶优化（没必要）</span>
<span class="token keyword">const</span> Component <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> data <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> processedData <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> data<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>data<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> handleClick <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>processedData<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>processedData<span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>processedData<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 如果组件本身很简单，这些优化都是浪费</span>

<span class="token comment">// ❌ 反例2：过早优化</span>
<span class="token keyword">const</span> TodoItem <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> todo <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> formattedDate <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>todo<span class="token punctuation">.</span>date<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLocaleDateString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>todo<span class="token punctuation">.</span>date<span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span>todo<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token plain-text"> - </span><span class="token punctuation">{</span>formattedDate<span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 日期格式化很快，useMemo 反而更慢</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>【如何量化优化效果】</p><ol><li>使用 React DevTools Profiler</li></ol><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// 在组件外包裹 Profiler</span>
<span class="token punctuation">;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Profiler</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ComponentName<span class="token punctuation">&quot;</span></span> <span class="token attr-name">onRender</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>callback<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Component</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Profiler</span></span><span class="token punctuation">&gt;</span></span>

<span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span>
  id<span class="token punctuation">,</span>
  phase<span class="token punctuation">,</span> <span class="token comment">// &quot;mount&quot; 或 &quot;update&quot;</span>
  actualDuration<span class="token punctuation">,</span> <span class="token comment">// 本次渲染耗时</span>
  baseDuration<span class="token punctuation">,</span> <span class="token comment">// 理想情况下耗时</span>
  startTime<span class="token punctuation">,</span>
  commitTime
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>phase<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 耗时: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>actualDuration<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">ms</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ol start="2"><li>Chrome DevTools Performance</li></ol><ul><li>录制 6fps 以下的场景</li><li>查看 Main thread 中的 React 相关任务</li><li>对比优化前后的 Scripting 时间</li></ul><ol start="3"><li>自定义性能监控</li></ol><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// 测量渲染次数</span>
<span class="token keyword">let</span> renderCount <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  renderCount<span class="token operator">++</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Render count:&#39;</span><span class="token punctuation">,</span> renderCount<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 测量计算耗时</span>
console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">&#39;expensive-calc&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">expensiveCalculation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">&#39;expensive-calc&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol start="4"><li>性能指标对比</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>优化前：
- 组件平均渲染时间：15ms
- 每秒重渲染次数：30次
- 总耗时：450ms/秒

优化后（使用 memo）：
- 组件平均渲染时间：15ms
- 每秒重渲染次数：5次（减少83%）
- 总耗时：75ms/秒（减少83%）

投入产出比：值得！
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>【最佳实践原则】</p><ol><li>⚡ 先测量，再优化（不要猜）</li><li>⚡ 优化瓶颈，而非全部</li><li>⚡ 简单组件不优化</li><li>⚡ memo/useMemo/useCallback 需要配合使用才有效</li><li>⚡ 关注用户体验指标（FPS、响应时间）</li><li>⚡ 避免过早优化，除非有明确证据</li></ol><p>【何时停止优化】</p><ul><li>✅ FPS 稳定在 60fps</li><li>✅ 交互响应时间 &lt; 100ms</li><li>✅ Profiler 中无明显性能瓶颈</li><li>✅ 用户无卡顿感知</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>
---

</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/vuepress/mark/" class="router-link-active" aria-label="自我面试"><!--[--><!--]--> 自我面试 <!--[--><!--]--></a></span><span class="next"><a href="/vuepress/mark/01-React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E8%A1%A5%E5%85%85.html" class="" aria-label="React 19 新特性详解 &amp; useMemo/useCallback 深度解析"><!--[--><!--]--> React 19 新特性详解 &amp; useMemo/useCallback 深度解析 <!--[--><!--]--></a></span></p></nav><!--[--><!--[--><div style="display:none"></div><div class="adsbygoogle-box"><ins class="adsbygoogle" style="display:block;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6846038091720568" data-ad-slot="1554369026"></ins></div><div style="display:none"> (adsbygoogle = window.adsbygoogle || []).push({}); </div><!--]--><!--]--></main><!--]--></div><!----><!----><!--]--></div>
    <script src="/vuepress/assets/js/runtime~app.50eb729e.js" defer></script><script src="/vuepress/assets/js/5316.94e78182.js" defer></script><script src="/vuepress/assets/js/app.8a17bbf0.js" defer></script>
  </body>
</html>
